<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/digitalbazaar/forge">node-forge (v0.7.1)</a>
</h1>
<h4>JavaScript implementations of network transports, cryptography, ciphers, PKI, message digests, and various utilities.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge">module node-forge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.</span>aes.Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher">
            function <span class="apidocSignatureSpan">node-forge.</span>cipher.BlockCipher
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.</span>des.Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger">
            function <span class="apidocSignatureSpan">node-forge.</span>jsbn.BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbkdf2">
            function <span class="apidocSignatureSpan">node-forge.</span>pbkdf2
            <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer">
            function <span class="apidocSignatureSpan">node-forge.</span>util.ByteBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer">
            function <span class="apidocSignatureSpan">node-forge.</span>util.DataBuffer
            <span class="apidocSignatureSpan">(b, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>aes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>aes.Algorithm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>asn1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.BlockCipher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.algorithms</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.cbc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.cfb.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.ctr.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.ecb.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.gcm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>cipher.modes.ofb.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>des</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>des.Algorithm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>forge</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>form</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>hmac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>jsbn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>jsbn.BigInteger.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>kem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>kem.rsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>log.consoleLogger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>md</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>md5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>mgf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>mgf1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>oids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pbe</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pkcs1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pkcs12</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pkcs5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pkcs7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pkcs7asn1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pki</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>prime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>prng</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>pss</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>random.plugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>rc2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>rsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha256</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha384</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha512</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha512.sha224</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>sha512.sha256</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>ssh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>task</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>util.ByteBuffer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>util.DataBuffer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.</span>xhr</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.aes">module node-forge.aes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes._expandKey">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>_expandKey
            <span class="apidocSignatureSpan">(key, decrypt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes._updateBlock">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>_updateBlock
            <span class="apidocSignatureSpan">(w, input, output, decrypt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.createDecryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>createDecryptionCipher
            <span class="apidocSignatureSpan">(key, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.createEncryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>createEncryptionCipher
            <span class="apidocSignatureSpan">(key, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.startDecrypting">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>startDecrypting
            <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.startEncrypting">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>startEncrypting
            <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.aes.Algorithm">module node-forge.aes.Algorithm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.Algorithm.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.aes.</span>Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.aes.Algorithm.prototype">module node-forge.aes.Algorithm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.aes.Algorithm.prototype.initialize">
            function <span class="apidocSignatureSpan">node-forge.aes.Algorithm.prototype.</span>initialize
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.asn1">module node-forge.asn1</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.copy">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>copy
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.create">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>create
            <span class="apidocSignatureSpan">(tagClass, type, constructed, value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.dateToGeneralizedTime">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>dateToGeneralizedTime
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.dateToUtcTime">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>dateToUtcTime
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.derToInteger">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>derToInteger
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.derToOid">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>derToOid
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.equals">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>equals
            <span class="apidocSignatureSpan">(obj1, obj2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.fromDer">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>fromDer
            <span class="apidocSignatureSpan">(bytes, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.generalizedTimeToDate">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>generalizedTimeToDate
            <span class="apidocSignatureSpan">(gentime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.getBerValueLength">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>getBerValueLength
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.integerToDer">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>integerToDer
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.oidToDer">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>oidToDer
            <span class="apidocSignatureSpan">(oid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.prettyPrint">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>prettyPrint
            <span class="apidocSignatureSpan">(obj, level, indentation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.toDer">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>toDer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.utcTimeToDate">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>utcTimeToDate
            <span class="apidocSignatureSpan">(utc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.asn1.validate">
            function <span class="apidocSignatureSpan">node-forge.asn1.</span>validate
            <span class="apidocSignatureSpan">(obj, v, capture, errors)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.asn1.</span>Class</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.asn1.</span>Type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher">module node-forge.cipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>BlockCipher
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.createCipher">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>createCipher
            <span class="apidocSignatureSpan">(algorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.createDecipher">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>createDecipher
            <span class="apidocSignatureSpan">(algorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.getAlgorithm">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>getAlgorithm
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.registerAlgorithm">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>registerAlgorithm
            <span class="apidocSignatureSpan">(name, algorithm)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.cipher.</span>algorithms</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.cipher.</span>modes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.BlockCipher">module node-forge.cipher.BlockCipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher.BlockCipher">
            function <span class="apidocSignatureSpan">node-forge.cipher.</span>BlockCipher
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.BlockCipher.prototype">module node-forge.cipher.BlockCipher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.finish">
            function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>finish
            <span class="apidocSignatureSpan">(pad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.update">
            function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>update
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.algorithms">module node-forge.cipher.algorithms</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.3DES-CBC">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CBC
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.3DES-CFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.3DES-CTR">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CTR
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.3DES-ECB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-ECB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.3DES-OFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-OFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-CBC">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CBC
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-CFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-CTR">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CTR
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-ECB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-ECB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-GCM">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-GCM
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.AES-OFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-OFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.DES-CBC">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CBC
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.DES-CFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.DES-CTR">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CTR
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.DES-ECB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-ECB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.algorithms.DES-OFB">
            function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-OFB
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes">module node-forge.cipher.modes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>cbc
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cfb">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>cfb
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ctr">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ctr
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ecb
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>gcm
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ofb">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ofb
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.cbc.prototype">module node-forge.cipher.modes.cbc.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.pad">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>pad
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.unpad">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>unpad
            <span class="apidocSignatureSpan">(output, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.cfb.prototype">module node-forge.cipher.modes.cfb.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.ctr.prototype">module node-forge.cipher.modes.ctr.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.ecb.prototype">module node-forge.cipher.modes.ecb.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.pad">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>pad
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.unpad">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>unpad
            <span class="apidocSignatureSpan">(output, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.gcm.prototype">module node-forge.cipher.modes.gcm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.afterFinish">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>afterFinish
            <span class="apidocSignatureSpan">(output, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.generateHashTable">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>generateHashTable
            <span class="apidocSignatureSpan">(h, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.generateSubHashTable">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>generateSubHashTable
            <span class="apidocSignatureSpan">(mid, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.ghash">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>ghash
            <span class="apidocSignatureSpan">(h, y, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.multiply">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>multiply
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.pow">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>pow
            <span class="apidocSignatureSpan">(x, out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.tableMultiply">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>tableMultiply
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.cipher.modes.ofb.prototype">module node-forge.cipher.modes.ofb.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.decrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.encrypt">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(input, output, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.start">
            function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.debug">module node-forge.debug</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.debug.clear">
            function <span class="apidocSignatureSpan">node-forge.debug.</span>clear
            <span class="apidocSignatureSpan">(cat, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.debug.get">
            function <span class="apidocSignatureSpan">node-forge.debug.</span>get
            <span class="apidocSignatureSpan">(cat, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.debug.set">
            function <span class="apidocSignatureSpan">node-forge.debug.</span>set
            <span class="apidocSignatureSpan">(cat, name, data)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.debug.</span>storage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.des">module node-forge.des</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.des.</span>Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.createDecryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.des.</span>createDecryptionCipher
            <span class="apidocSignatureSpan">(key, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.createEncryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.des.</span>createEncryptionCipher
            <span class="apidocSignatureSpan">(key, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.startDecrypting">
            function <span class="apidocSignatureSpan">node-forge.des.</span>startDecrypting
            <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.startEncrypting">
            function <span class="apidocSignatureSpan">node-forge.des.</span>startEncrypting
            <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.des.Algorithm">module node-forge.des.Algorithm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.Algorithm.Algorithm">
            function <span class="apidocSignatureSpan">node-forge.des.</span>Algorithm
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.des.Algorithm.prototype">module node-forge.des.Algorithm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.des.Algorithm.prototype.initialize">
            function <span class="apidocSignatureSpan">node-forge.des.Algorithm.prototype.</span>initialize
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.forge">module node-forge.forge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.forge.pbkdf2">
            function <span class="apidocSignatureSpan">node-forge.forge.</span>pbkdf2
            <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>aes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>asn1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>des</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>form</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>hmac</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>jsbn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>kem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>md</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>md5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>mgf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>mgf1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>oids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pbe</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pkcs1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pkcs12</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pkcs5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pkcs7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pkcs7asn1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pki</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>prime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>prng</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>pss</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>rc2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>rsa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>sha1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>sha256</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>sha384</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>sha512</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>ssh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>task</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.forge.</span>xhr</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.hmac">module node-forge.hmac</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.hmac.create">
            function <span class="apidocSignatureSpan">node-forge.hmac.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.http">module node-forge.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.http.createClient">
            function <span class="apidocSignatureSpan">node-forge.http.</span>createClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.http.createRequest">
            function <span class="apidocSignatureSpan">node-forge.http.</span>createRequest
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.http.createResponse">
            function <span class="apidocSignatureSpan">node-forge.http.</span>createResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.http.parseUrl">
            function <span class="apidocSignatureSpan">node-forge.http.</span>parseUrl
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.http.withinCookieDomain">
            function <span class="apidocSignatureSpan">node-forge.http.</span>withinCookieDomain
            <span class="apidocSignatureSpan">(url, cookie)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.jsbn">module node-forge.jsbn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger">
            function <span class="apidocSignatureSpan">node-forge.jsbn.</span>BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.jsbn.BigInteger">module node-forge.jsbn.BigInteger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.BigInteger">
            function <span class="apidocSignatureSpan">node-forge.jsbn.</span>BigInteger
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.jsbn.BigInteger.prototype">module node-forge.jsbn.BigInteger.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.abs">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.add">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>add
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.addTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>addTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.am">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>am
            <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.and">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>and
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.andNot">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>andNot
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitCount">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitLength">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitwiseTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitwiseTo
            <span class="apidocSignatureSpan">(a, op, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.byteValue">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>byteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.changeBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>changeBit
            <span class="apidocSignatureSpan">(n, op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.chunkSize">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>chunkSize
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clamp">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clearBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clearBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clone">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.compareTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>compareTo
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.copyTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>copyTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dAddOffset">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dAddOffset
            <span class="apidocSignatureSpan">(n, w)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dMultiply">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dMultiply
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divRemTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divRemTo
            <span class="apidocSignatureSpan">(m, q, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divide">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divide
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divideAndRemainder">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divideAndRemainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dlShiftTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dlShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.drShiftTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>drShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.equals">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>equals
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.exp">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>exp
            <span class="apidocSignatureSpan">(e, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.flipBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>flipBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromInt">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromInt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromNumber">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromNumber
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromRadix">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromRadix
            <span class="apidocSignatureSpan">(s, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromString">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromString
            <span class="apidocSignatureSpan">(s, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.gcd">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>gcd
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.getLowestSetBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>getLowestSetBit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.intValue">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>intValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.invDigit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>invDigit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.isEven">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.isProbablePrime">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>isProbablePrime
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.lShiftTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>lShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.max">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>max
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.millerRabin">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>millerRabin
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.min">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>min
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.mod">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>mod
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modInt">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modInverse">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modInverse
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modPow">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modPow
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modPowInt">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modPowInt
            <span class="apidocSignatureSpan">(e, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiply">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiply
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyLowerTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyLowerTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyUpperTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyUpperTo
            <span class="apidocSignatureSpan">(a, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.negate">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.not">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.or">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>or
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.pow">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>pow
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.rShiftTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>rShiftTo
            <span class="apidocSignatureSpan">(n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.remainder">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>remainder
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.setBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>setBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftRight">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shortValue">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shortValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.signum">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>signum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.squareTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>squareTo
            <span class="apidocSignatureSpan">(r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.subTo">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>subTo
            <span class="apidocSignatureSpan">(a, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.subtract">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>subtract
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.testBit">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>testBit
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toByteArray">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toByteArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toRadix">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toRadix
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toString">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toString
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.xor">
            function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>xor
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>DB</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>DM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>DV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>F1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>F2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>FV</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.kem">module node-forge.kem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.kem.kdf1">
            function <span class="apidocSignatureSpan">node-forge.kem.</span>kdf1
            <span class="apidocSignatureSpan">(md, digestLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.kem.kdf2">
            function <span class="apidocSignatureSpan">node-forge.kem.</span>kdf2
            <span class="apidocSignatureSpan">(md, digestLength)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.kem.</span>rsa</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.kem.rsa">module node-forge.kem.rsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.kem.rsa.create">
            function <span class="apidocSignatureSpan">node-forge.kem.rsa.</span>create
            <span class="apidocSignatureSpan">(kdf, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.log">module node-forge.log</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.addLogger">
            function <span class="apidocSignatureSpan">node-forge.log.</span>addLogger
            <span class="apidocSignatureSpan">(logger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.debug">
            function <span class="apidocSignatureSpan">node-forge.log.</span>debug
            <span class="apidocSignatureSpan">(category, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.error">
            function <span class="apidocSignatureSpan">node-forge.log.</span>error
            <span class="apidocSignatureSpan">(category, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.info">
            function <span class="apidocSignatureSpan">node-forge.log.</span>info
            <span class="apidocSignatureSpan">(category, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.lock">
            function <span class="apidocSignatureSpan">node-forge.log.</span>lock
            <span class="apidocSignatureSpan">(logger, lock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.logMessage">
            function <span class="apidocSignatureSpan">node-forge.log.</span>logMessage
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.makeLogger">
            function <span class="apidocSignatureSpan">node-forge.log.</span>makeLogger
            <span class="apidocSignatureSpan">(logFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.prepareFull">
            function <span class="apidocSignatureSpan">node-forge.log.</span>prepareFull
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.prepareStandard">
            function <span class="apidocSignatureSpan">node-forge.log.</span>prepareStandard
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.prepareStandardFull">
            function <span class="apidocSignatureSpan">node-forge.log.</span>prepareStandardFull
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.setLevel">
            function <span class="apidocSignatureSpan">node-forge.log.</span>setLevel
            <span class="apidocSignatureSpan">(logger, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.verbose">
            function <span class="apidocSignatureSpan">node-forge.log.</span>verbose
            <span class="apidocSignatureSpan">(category, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.warning">
            function <span class="apidocSignatureSpan">node-forge.log.</span>warning
            <span class="apidocSignatureSpan">(category, message)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.log.</span>INTERPOLATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.log.</span>LEVEL_LOCKED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.log.</span>NO_LEVEL_CHECK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.log.</span>consoleLogger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.log.</span>levels</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.log.consoleLogger">module node-forge.log.consoleLogger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.log.consoleLogger.f">
            function <span class="apidocSignatureSpan">node-forge.log.consoleLogger.</span>f
            <span class="apidocSignatureSpan">(logger, message)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.log.consoleLogger.</span>flags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">node-forge.log.consoleLogger.</span>level</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.md5">module node-forge.md5</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.md5.create">
            function <span class="apidocSignatureSpan">node-forge.md5.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.mgf1">module node-forge.mgf1</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.mgf1.create">
            function <span class="apidocSignatureSpan">node-forge.mgf1.</span>create
            <span class="apidocSignatureSpan">(md)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.net">module node-forge.net</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.net.createSocket">
            function <span class="apidocSignatureSpan">node-forge.net.</span>createSocket
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.net.createSocketPool">
            function <span class="apidocSignatureSpan">node-forge.net.</span>createSocketPool
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.net.destroySocketPool">
            function <span class="apidocSignatureSpan">node-forge.net.</span>destroySocketPool
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.net.</span>socketPools</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pbe">module node-forge.pbe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbe.generatePkcs12Key">
            function <span class="apidocSignatureSpan">node-forge.pbe.</span>generatePkcs12Key
            <span class="apidocSignatureSpan">(password, salt, id, iter, n, md)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbe.getCipher">
            function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipher
            <span class="apidocSignatureSpan">(oid, params, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbe.getCipherForPBES2">
            function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipherForPBES2
            <span class="apidocSignatureSpan">(oid, params, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbe.getCipherForPKCS12PBE">
            function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipherForPKCS12PBE
            <span class="apidocSignatureSpan">(oid, params, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pbe.opensslDeriveBytes">
            function <span class="apidocSignatureSpan">node-forge.pbe.</span>opensslDeriveBytes
            <span class="apidocSignatureSpan">(password, salt, dkLen, md)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pem">module node-forge.pem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pem.decode">
            function <span class="apidocSignatureSpan">node-forge.pem.</span>decode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pem.encode">
            function <span class="apidocSignatureSpan">node-forge.pem.</span>encode
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pkcs1">module node-forge.pkcs1</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs1.decode_rsa_oaep">
            function <span class="apidocSignatureSpan">node-forge.pkcs1.</span>decode_rsa_oaep
            <span class="apidocSignatureSpan">(key, em, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs1.encode_rsa_oaep">
            function <span class="apidocSignatureSpan">node-forge.pkcs1.</span>encode_rsa_oaep
            <span class="apidocSignatureSpan">(key, message, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pkcs12">module node-forge.pkcs12</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs12.generateKey">
            function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>generateKey
            <span class="apidocSignatureSpan">(password, salt, id, iter, n, md)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs12.pkcs12FromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>pkcs12FromAsn1
            <span class="apidocSignatureSpan">(obj, strict, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs12.toPkcs12Asn1">
            function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>toPkcs12Asn1
            <span class="apidocSignatureSpan">(key, cert, password, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pkcs5">module node-forge.pkcs5</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs5.pbkdf2">
            function <span class="apidocSignatureSpan">node-forge.pkcs5.</span>pbkdf2
            <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pkcs7">module node-forge.pkcs7</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.createEncryptedData">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createEncryptedData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.createEnvelopedData">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createEnvelopedData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.createSignedData">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createSignedData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.messageFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageFromAsn1
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.messageFromPem">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageFromPem
            <span class="apidocSignatureSpan">(pem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pkcs7.messageToPem">
            function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageToPem
            <span class="apidocSignatureSpan">(msg, maxline)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.pkcs7.</span>asn1</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pki">module node-forge.pki</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.CRIAttributesAsArray">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>CRIAttributesAsArray
            <span class="apidocSignatureSpan">(attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.RDNAttributesAsArray">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>RDNAttributesAsArray
            <span class="apidocSignatureSpan">(rdn, md)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateExtensionFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionFromAsn1
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateExtensionToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionToAsn1
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateExtensionsFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionsFromAsn1
            <span class="apidocSignatureSpan">(exts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateExtensionsToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionsToAsn1
            <span class="apidocSignatureSpan">(exts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateFromAsn1
            <span class="apidocSignatureSpan">(obj, computeHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateFromPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateFromPem
            <span class="apidocSignatureSpan">(pem, computeHash, strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateToAsn1
            <span class="apidocSignatureSpan">(cert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificateToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateToPem
            <span class="apidocSignatureSpan">(cert, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificationRequestFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestFromAsn1
            <span class="apidocSignatureSpan">(obj, computeHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificationRequestFromPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestFromPem
            <span class="apidocSignatureSpan">(pem, computeHash, strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificationRequestToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestToAsn1
            <span class="apidocSignatureSpan">(csr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.certificationRequestToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestToPem
            <span class="apidocSignatureSpan">(csr, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.createCaStore">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>createCaStore
            <span class="apidocSignatureSpan">(certs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.createCertificate">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>createCertificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.createCertificationRequest">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>createCertificationRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.decryptPrivateKeyInfo">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>decryptPrivateKeyInfo
            <span class="apidocSignatureSpan">(obj, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.decryptRsaPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>decryptRsaPrivateKey
            <span class="apidocSignatureSpan">(pem, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.distinguishedNameToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>distinguishedNameToAsn1
            <span class="apidocSignatureSpan">(dn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.encryptPrivateKeyInfo">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptPrivateKeyInfo
            <span class="apidocSignatureSpan">(obj, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.encryptRsaPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptRsaPrivateKey
            <span class="apidocSignatureSpan">(rsaKey, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.encryptedPrivateKeyFromPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptedPrivateKeyFromPem
            <span class="apidocSignatureSpan">(pem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.encryptedPrivateKeyToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptedPrivateKeyToPem
            <span class="apidocSignatureSpan">(epki, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.getCertificationRequestInfo">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>getCertificationRequestInfo
            <span class="apidocSignatureSpan">(csr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.getPublicKeyFingerprint">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>getPublicKeyFingerprint
            <span class="apidocSignatureSpan">(key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.getTBSCertificate">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>getTBSCertificate
            <span class="apidocSignatureSpan">(cert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.pemToDer">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>pemToDer
            <span class="apidocSignatureSpan">(pem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyFromAsn1
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyFromPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyFromPem
            <span class="apidocSignatureSpan">(pem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyInfoToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyInfoToPem
            <span class="apidocSignatureSpan">(pki, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToAsn1
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToPem
            <span class="apidocSignatureSpan">(key, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.privateKeyToRSAPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToRSAPrivateKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyFromAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyFromAsn1
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyFromPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyFromPem
            <span class="apidocSignatureSpan">(pem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyToAsn1">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToAsn1
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyToPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToPem
            <span class="apidocSignatureSpan">(key, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyToRSAPublicKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToRSAPublicKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyToRSAPublicKeyPem">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToRSAPublicKeyPem
            <span class="apidocSignatureSpan">(key, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.publicKeyToSubjectPublicKeyInfo">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToSubjectPublicKeyInfo
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.setRsaPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>setRsaPrivateKey
            <span class="apidocSignatureSpan">( n, e, d, p, q, dP, dQ, qInv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.setRsaPublicKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>setRsaPublicKey
            <span class="apidocSignatureSpan">(n, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.verifyCertificateChain">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>verifyCertificateChain
            <span class="apidocSignatureSpan">(caStore, chain, verify)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pki.wrapRsaPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.pki.</span>wrapRsaPrivateKey
            <span class="apidocSignatureSpan">(rsaKey)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.pki.</span>certificateError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.pki.</span>oids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.pki.</span>pbe</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.pki.</span>rsa</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.prime">module node-forge.prime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.prime.generateProbablePrime">
            function <span class="apidocSignatureSpan">node-forge.prime.</span>generateProbablePrime
            <span class="apidocSignatureSpan">(bits, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.prng">module node-forge.prng</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.prng.create">
            function <span class="apidocSignatureSpan">node-forge.prng.</span>create
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.pss">module node-forge.pss</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.pss.create">
            function <span class="apidocSignatureSpan">node-forge.pss.</span>create
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.random">module node-forge.random</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.collect">
            function <span class="apidocSignatureSpan">node-forge.random.</span>collect
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.collectInt">
            function <span class="apidocSignatureSpan">node-forge.random.</span>collectInt
            <span class="apidocSignatureSpan">(i, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.createInstance">
            function <span class="apidocSignatureSpan">node-forge.random.</span>createInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.generate">
            function <span class="apidocSignatureSpan">node-forge.random.</span>generate
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.generateSync">
            function <span class="apidocSignatureSpan">node-forge.random.</span>generateSync
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.getBytes">
            function <span class="apidocSignatureSpan">node-forge.random.</span>getBytes
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.getBytesSync">
            function <span class="apidocSignatureSpan">node-forge.random.</span>getBytesSync
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.registerWorker">
            function <span class="apidocSignatureSpan">node-forge.random.</span>registerWorker
            <span class="apidocSignatureSpan">(worker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.seedFile">
            function <span class="apidocSignatureSpan">node-forge.random.</span>seedFile
            <span class="apidocSignatureSpan">(needed, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.seedFileSync">
            function <span class="apidocSignatureSpan">node-forge.random.</span>seedFileSync
            <span class="apidocSignatureSpan">(needed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.random.</span>generated</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.random.</span>pool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.random.</span>reseeds</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.</span>key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.</span>plugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.</span>pools</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.</span>seed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.</span>time</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.random.plugin">module node-forge.random.plugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.plugin.cipher">
            function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>cipher
            <span class="apidocSignatureSpan">(key, seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.plugin.formatKey">
            function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>formatKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.plugin.formatSeed">
            function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>formatSeed
            <span class="apidocSignatureSpan">(seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.random.plugin.increment">
            function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>increment
            <span class="apidocSignatureSpan">(seed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.random.plugin.</span>md</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.rc2">module node-forge.rc2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rc2.createDecryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.rc2.</span>createDecryptionCipher
            <span class="apidocSignatureSpan">(key, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rc2.createEncryptionCipher">
            function <span class="apidocSignatureSpan">node-forge.rc2.</span>createEncryptionCipher
            <span class="apidocSignatureSpan">(key, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rc2.expandKey">
            function <span class="apidocSignatureSpan">node-forge.rc2.</span>expandKey
            <span class="apidocSignatureSpan">(key, effKeyBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rc2.startDecrypting">
            function <span class="apidocSignatureSpan">node-forge.rc2.</span>startDecrypting
            <span class="apidocSignatureSpan">(key, iv, output)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rc2.startEncrypting">
            function <span class="apidocSignatureSpan">node-forge.rc2.</span>startEncrypting
            <span class="apidocSignatureSpan">(key, iv, output)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.rsa">module node-forge.rsa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.createKeyPairGenerationState">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>createKeyPairGenerationState
            <span class="apidocSignatureSpan">(bits, e, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.decrypt">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>decrypt
            <span class="apidocSignatureSpan">(ed, key, pub, ml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.encrypt">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>encrypt
            <span class="apidocSignatureSpan">(m, key, bt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.generateKeyPair">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>generateKeyPair
            <span class="apidocSignatureSpan">(bits, e, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.setPrivateKey">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>setPrivateKey
            <span class="apidocSignatureSpan">( n, e, d, p, q, dP, dQ, qInv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.setPublicKey">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>setPublicKey
            <span class="apidocSignatureSpan">(n, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.rsa.stepKeyPairGenerationState">
            function <span class="apidocSignatureSpan">node-forge.rsa.</span>stepKeyPairGenerationState
            <span class="apidocSignatureSpan">(state, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.rsa.</span>publicKeyValidator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha1">module node-forge.sha1</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha1.create">
            function <span class="apidocSignatureSpan">node-forge.sha1.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha256">module node-forge.sha256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha256.create">
            function <span class="apidocSignatureSpan">node-forge.sha256.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha384">module node-forge.sha384</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha384.create">
            function <span class="apidocSignatureSpan">node-forge.sha384.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha512">module node-forge.sha512</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha512.create">
            function <span class="apidocSignatureSpan">node-forge.sha512.</span>create
            <span class="apidocSignatureSpan">(algorithm)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.sha512.</span>sha224</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.sha512.</span>sha256</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.sha512.</span>sha384</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha512.sha224">module node-forge.sha512.sha224</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha512.sha224.create">
            function <span class="apidocSignatureSpan">node-forge.sha512.sha224.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.sha512.sha256">module node-forge.sha512.sha256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.sha512.sha256.create">
            function <span class="apidocSignatureSpan">node-forge.sha512.sha256.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.ssh">module node-forge.ssh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.ssh.getPublicKeyFingerprint">
            function <span class="apidocSignatureSpan">node-forge.ssh.</span>getPublicKeyFingerprint
            <span class="apidocSignatureSpan">(key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.ssh.privateKeyToOpenSSH">
            function <span class="apidocSignatureSpan">node-forge.ssh.</span>privateKeyToOpenSSH
            <span class="apidocSignatureSpan">(privateKey, passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.ssh.privateKeyToPutty">
            function <span class="apidocSignatureSpan">node-forge.ssh.</span>privateKeyToPutty
            <span class="apidocSignatureSpan">(privateKey, passphrase, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.ssh.publicKeyToOpenSSH">
            function <span class="apidocSignatureSpan">node-forge.ssh.</span>publicKeyToOpenSSH
            <span class="apidocSignatureSpan">(key, comment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.task">module node-forge.task</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.task.cancel">
            function <span class="apidocSignatureSpan">node-forge.task.</span>cancel
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.task.createCondition">
            function <span class="apidocSignatureSpan">node-forge.task.</span>createCondition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.task.start">
            function <span class="apidocSignatureSpan">node-forge.task.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.tls">module node-forge.tls</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.tls.createConnection">
            function <span class="apidocSignatureSpan">node-forge.tls.</span>createConnection
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.tls.createSessionCache">
            function <span class="apidocSignatureSpan">node-forge.tls.</span>createSessionCache
            <span class="apidocSignatureSpan">(cache, capacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.tls.hmac_sha1">
            function <span class="apidocSignatureSpan">node-forge.tls.</span>hmac_sha1
            <span class="apidocSignatureSpan">(key, seqNum, record)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.tls.prf_tls1">
            function <span class="apidocSignatureSpan">node-forge.tls.</span>prf_tls1
            <span class="apidocSignatureSpan">(secret, label, seed, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.tls.wrapSocket">
            function <span class="apidocSignatureSpan">node-forge.tls.</span>wrapSocket
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">node-forge.tls.</span>MaxFragment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>Alert</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>BulkCipherAlgorithm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>CipherSuites</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>CipherType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>CompressionMethod</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>ConnectionEnd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>ContentType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>HandshakeType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>HeartbeatMessageType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>MACAlgorithm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>PRFAlgorithm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>SupportedVersions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>Version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.tls.</span>Versions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.util">module node-forge.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>ByteBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteStringBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>ByteStringBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>DataBuffer
            <span class="apidocSignatureSpan">(b, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesFromIP">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIP
            <span class="apidocSignatureSpan">(ip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesFromIPv4">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIPv4
            <span class="apidocSignatureSpan">(ip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesFromIPv6">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIPv6
            <span class="apidocSignatureSpan">(ip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesToHex">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToHex
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesToIP">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIP
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesToIPv4">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIPv4
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.bytesToIPv6">
            function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIPv6
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.clearItems">
            function <span class="apidocSignatureSpan">node-forge.util.</span>clearItems
            <span class="apidocSignatureSpan">(api, id, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.createBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>createBuffer
            <span class="apidocSignatureSpan">(input, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.decode64">
            function <span class="apidocSignatureSpan">node-forge.util.</span>decode64
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.decodeUtf8">
            function <span class="apidocSignatureSpan">node-forge.util.</span>decodeUtf8
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.deflate">
            function <span class="apidocSignatureSpan">node-forge.util.</span>deflate
            <span class="apidocSignatureSpan">(api, bytes, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.deletePath">
            function <span class="apidocSignatureSpan">node-forge.util.</span>deletePath
            <span class="apidocSignatureSpan">(object, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.encode64">
            function <span class="apidocSignatureSpan">node-forge.util.</span>encode64
            <span class="apidocSignatureSpan">(input, maxline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.encodeUtf8">
            function <span class="apidocSignatureSpan">node-forge.util.</span>encodeUtf8
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.estimateCores">
            function <span class="apidocSignatureSpan">node-forge.util.</span>estimateCores
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.fillString">
            function <span class="apidocSignatureSpan">node-forge.util.</span>fillString
            <span class="apidocSignatureSpan">(c, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.format">
            function <span class="apidocSignatureSpan">node-forge.util.</span>format
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.formatNumber">
            function <span class="apidocSignatureSpan">node-forge.util.</span>formatNumber
            <span class="apidocSignatureSpan">(number, decimals, dec_point, thousands_sep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.formatSize">
            function <span class="apidocSignatureSpan">node-forge.util.</span>formatSize
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.getItem">
            function <span class="apidocSignatureSpan">node-forge.util.</span>getItem
            <span class="apidocSignatureSpan">(api, id, key, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.getPath">
            function <span class="apidocSignatureSpan">node-forge.util.</span>getPath
            <span class="apidocSignatureSpan">(object, keys, _default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.getQueryVariables">
            function <span class="apidocSignatureSpan">node-forge.util.</span>getQueryVariables
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.hexToBytes">
            function <span class="apidocSignatureSpan">node-forge.util.</span>hexToBytes
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.inflate">
            function <span class="apidocSignatureSpan">node-forge.util.</span>inflate
            <span class="apidocSignatureSpan">(api, bytes, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.int32ToBytes">
            function <span class="apidocSignatureSpan">node-forge.util.</span>int32ToBytes
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.isArray">
            function <span class="apidocSignatureSpan">node-forge.util.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.isArrayBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>isArrayBuffer
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.isArrayBufferView">
            function <span class="apidocSignatureSpan">node-forge.util.</span>isArrayBufferView
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.isEmpty">
            function <span class="apidocSignatureSpan">node-forge.util.</span>isEmpty
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.makeLink">
            function <span class="apidocSignatureSpan">node-forge.util.</span>makeLink
            <span class="apidocSignatureSpan">(path, query, fragment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.makeRequest">
            function <span class="apidocSignatureSpan">node-forge.util.</span>makeRequest
            <span class="apidocSignatureSpan">(reqString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.nextTick">
            function <span class="apidocSignatureSpan">node-forge.util.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.parseFragment">
            function <span class="apidocSignatureSpan">node-forge.util.</span>parseFragment
            <span class="apidocSignatureSpan">(fragment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.parseUrl">
            function <span class="apidocSignatureSpan">node-forge.util.</span>parseUrl
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.removeItem">
            function <span class="apidocSignatureSpan">node-forge.util.</span>removeItem
            <span class="apidocSignatureSpan">(api, id, key, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.setImmediate">
            function <span class="apidocSignatureSpan">node-forge.util.</span>setImmediate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.setItem">
            function <span class="apidocSignatureSpan">node-forge.util.</span>setItem
            <span class="apidocSignatureSpan">(api, id, key, data, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.setPath">
            function <span class="apidocSignatureSpan">node-forge.util.</span>setPath
            <span class="apidocSignatureSpan">(object, keys, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.xorBytes">
            function <span class="apidocSignatureSpan">node-forge.util.</span>xorBytes
            <span class="apidocSignatureSpan">(s1, s2, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.util.</span>binary</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-forge.util.</span>text</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">node-forge.util.</span>isNodejs</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.util.ByteBuffer">module node-forge.util.ByteBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.ByteBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>ByteBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.util.ByteBuffer.prototype">module node-forge.util.ByteBuffer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype._optimizeConstructedString">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>_optimizeConstructedString
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.at">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>at
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.bytes">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>bytes
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.clear">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.compact">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>compact
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.copy">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.fillWithByte">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>fillWithByte
            <span class="apidocSignatureSpan">(b, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getByte">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getByte
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getBytes">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getBytes
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt16Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt24
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt24Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt32Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getSignedInt">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getSignedInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.isEmpty">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.last">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.length">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putBuffer
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putByte">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putByte
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putBytes">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt
            <span class="apidocSignatureSpan">(i, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt16
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt16Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt24
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt24Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt32
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32Le">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt32Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putSignedInt">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putSignedInt
            <span class="apidocSignatureSpan">(i, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putString">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.setAt">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>setAt
            <span class="apidocSignatureSpan">(i, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.toHex">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>toHex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.toString">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.ByteBuffer.prototype.truncate">
            function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>truncate
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.util.DataBuffer">module node-forge.util.DataBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.DataBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.</span>DataBuffer
            <span class="apidocSignatureSpan">(b, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-forge.util.DataBuffer.prototype">module node-forge.util.DataBuffer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.accommodate">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>accommodate
            <span class="apidocSignatureSpan">(amount, growSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.at">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>at
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.bytes">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>bytes
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.clear">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.compact">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>compact
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.copy">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.fillWithByte">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>fillWithByte
            <span class="apidocSignatureSpan">(b, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getByte">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getByte
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getBytes">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getBytes
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt16">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt16Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt16Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt24">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt24
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt24Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt24Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt32">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt32Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt32Le
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.getSignedInt">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getSignedInt
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.isEmpty">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.last">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.length">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putBuffer">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putBuffer
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putByte">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putByte
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putBytes">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putBytes
            <span class="apidocSignatureSpan">(bytes, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt
            <span class="apidocSignatureSpan">(i, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt16">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt16
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt16Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt16Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt24">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt24
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt24Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt24Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt32">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt32
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt32Le">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt32Le
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putSignedInt">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putSignedInt
            <span class="apidocSignatureSpan">(i, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.putString">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.setAt">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>setAt
            <span class="apidocSignatureSpan">(i, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.toHex">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>toHex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.toString">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>toString
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-forge.util.DataBuffer.prototype.truncate">
            function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>truncate
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge" id="apidoc.module.node-forge">module node-forge</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.aes.Algorithm" id="apidoc.element.node-forge.aes.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.</span>aes.Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aes.Algorithm = function (name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.<span class="apidocCodeKeywordSpan">aes.Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher" id="apidoc.element.node-forge.cipher.BlockCipher">
        function <span class="apidocSignatureSpan">node-forge.</span>cipher.BlockCipher
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cipher.BlockCipher = function (options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.<span class="apidocCodeKeywordSpan">cipher.BlockCipher</span>({
    algorithm: api,
    key: key,
    decrypt: false
  });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.des.Algorithm" id="apidoc.element.node-forge.des.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.</span>des.Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">des.Algorithm = function (name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.<span class="apidocCodeKeywordSpan">des.Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** DES implementation **/

var spfunction1 = [0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004
,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404
,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400
,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004
,0x10400,0,0x1010004];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger" id="apidoc.element.node-forge.jsbn.BigInteger">
        function <span class="apidocSignatureSpan">node-forge.</span>jsbn.BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pbkdf2" id="apidoc.element.node-forge.pbkdf2">
        function <span class="apidocSignatureSpan">node-forge.</span>pbkdf2
        <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2 = function ( p, s, c, dkLen, md, callback) {
  if(typeof md === 'function') {
    callback = md;
    md = null;
  }

  // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed
  if(forge.util.isNodejs &amp;&amp; !forge.options.usePureJavaScript &amp;&amp;
    crypto.pbkdf2 &amp;&amp; (md === null || typeof md !== 'object') &amp;&amp;
    (crypto.pbkdf2Sync.length &gt; 4 || (!md || md === 'sha1'))) {
    if(typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }
    p = new Buffer(p, 'binary');
    s = new Buffer(s, 'binary');
    if(!callback) {
      if(crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }
      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }
    if(crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
        if(err) {
          return callback(err);
        }
        callback(null, key.toString('binary'));
      });
    }
    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
      if(err) {
        return callback(err);
      }
      callback(null, key.toString('binary'));
    });
  }

  if(typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }
  if(typeof md === 'string') {
    if(!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }
    md = forge.md[md].create();
  }

  var hLen = md.digestLength;

<span class="apidocCodeCommentSpan">  /* 1. If dkLen &gt; (2^32 - 1) * hLen, output "derived key too long" and
    stop. */
</span>  if(dkLen &gt; (0xFFFFFFFF * hLen)) {
    var err = new Error('Derived key is too long.');
    if(callback) {
      return callback(err);
    }
    throw err;
  }

  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;

  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */
  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1;

  // sync version
  if(!callback) {
    for(var i = 1; i &lt;= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j &lt;= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        // F(p, s, c, i)
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len&lt;0..r-1&gt; */
      dk += (i &lt; len) ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */
    return dk;
  }

  // async version
  var i = 1, j;
  function outer() {
    if(i &gt; len) {
      // done
      return callback(null, dk);
    }

    // PRF(P, S || INT(i)) (first iteration)
    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();

    // PRF(P, u_{c-1}) (other iterations)
    j = 2;
    inner();
  } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// generate a random key and IV
// Note: a key size of 16 bytes will use AES-128, 24 =&gt; AES-192, 32 =&gt; AES-256
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(16);

/* alternatively, generate a password-based 16-byte key
var salt = forge.random.getBytesSync(128);
var key = forge.pkcs5.<span class="apidocCodeKeywordSpan">pbkdf2</span>('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer" id="apidoc.element.node-forge.util.ByteBuffer">
        function <span class="apidocSignatureSpan">node-forge.</span>util.ByteBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    // convert native buffer to forge buffer
    // FIXME: support native buffers internally instead
    var arr = new Uint8Array(b);
    try {
      this.data = String.fromCharCode.apply(null, arr);
    } catch(e) {
      for(var i = 0; i &lt; arr.length; ++i) {
        this.putByte(arr[i]);
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' &amp;&amp; typeof b.data === 'string' &amp;&amp;
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param x the binary-encoded byte string to generate a key from.
   * @param length the number of bytes to generate (the size of the key).
   *
   * @return the key as a binary-encoded string.
   */
  kdf.generate = function(x, length) {
var key = new forge.<span class="apidocCodeKeywordSpan">util.ByteBuffer</span>();

// run counter from counterStart to ceil(length / Hash.len)
var k = Math.ceil(length / digestLength) + counterStart;

var c = new forge.util.ByteBuffer();
for(var i = counterStart; i &lt; k; ++i) {
  // I2OSP(i, 4): convert counter to an octet string of 4 octets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer" id="apidoc.element.node-forge.util.DataBuffer">
        function <span class="apidocSignatureSpan">node-forge.</span>util.DataBuffer
        <span class="apidocSignatureSpan">(b, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBuffer(b, options) {
  // default options
  options = options || {};

  // pointers for read from/write to buffer
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;

  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);
  if(isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if(isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = ('writeOffset' in options ?
      options.writeOffset : this.data.byteLength);
    return;
  }

  // initialize to empty array buffer and add any given bytes using putBytes
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if(b !== null &amp;&amp; b !== undefined) {
    this.putBytes(b);
  }

  if('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.aes" id="apidoc.module.node-forge.aes">module node-forge.aes</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.aes.Algorithm" id="apidoc.element.node-forge.aes.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Algorithm = function (name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.<span class="apidocCodeKeywordSpan">Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes._expandKey" id="apidoc.element.node-forge.aes._expandKey">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>_expandKey
        <span class="apidocSignatureSpan">(key, decrypt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_expandKey = function (key, decrypt) {
  if(!init) {
    initialize();
  }
  return _expandKey(key, decrypt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
key = new Array(4);
key[0] = tmp.getInt32();
key[1] = tmp.getInt32();
key[2] = tmp.getInt32();
key[3] = tmp.getInt32();

// return the expanded key
return forge.aes.<span class="apidocCodeKeywordSpan">_expandKey</span>(key, false);
};
prng_aes.formatSeed = function(seed) {
// convert seed into 32-bit integers
var tmp = forge.util.createBuffer(seed);
seed = new Array(4);
seed[0] = tmp.getInt32();
seed[1] = tmp.getInt32();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes._updateBlock" id="apidoc.element.node-forge.aes._updateBlock">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>_updateBlock
        <span class="apidocSignatureSpan">(w, input, output, decrypt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateBlock(w, input, output, decrypt) {
<span class="apidocCodeCommentSpan">  /*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */
</span>
  // Encrypt: AddRoundKey(state, w[0, Nb-1])
  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if(decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d, a2, b2, c2;
  a = input[0] ^ w[0];
  b = input[decrypt ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt ? 1 : 3] ^ w[3];
  var i = 3;

  /* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */
  for(var round = 1; round &lt; Nr; ++round) {
    /* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 &gt;&gt; 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 &amp; 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (&amp; 255 omitted for brevity):
      c'0,r0 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3]
      c'0,r1 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3]
      c'0,r2 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3]
      c'0,r3 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 &lt; r &lt; 4 and 0 &lt;= c &lt; Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] =&gt; [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  seed[0] = tmp.getInt32();
  seed[1] = tmp.getInt32();
  seed[2] = tmp.getInt32();
  seed[3] = tmp.getInt32();
  return seed;
};
prng_aes.cipher = function(key, seed) {
  forge.aes.<span class="apidocCodeKeywordSpan">_updateBlock</span>(key, seed, _prng_aes_output, false);
  _prng_aes_buffer.putInt32(_prng_aes_output[0]);
  _prng_aes_buffer.putInt32(_prng_aes_output[1]);
  _prng_aes_buffer.putInt32(_prng_aes_output[2]);
  _prng_aes_buffer.putInt32(_prng_aes_output[3]);
  return _prng_aes_buffer.getBytes();
};
prng_aes.increment = function(seed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes.createDecryptionCipher" id="apidoc.element.node-forge.aes.createDecryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>createDecryptionCipher
        <span class="apidocSignatureSpan">(key, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDecryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createDecryptionCipher</span>(key);
cipher.start(iv);
cipher.update(encrypted);
cipher.finish();
// outputs decrypted hex
console.log(cipher.output.toHex());
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes.createEncryptionCipher" id="apidoc.element.node-forge.aes.createEncryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>createEncryptionCipher
        <span class="apidocSignatureSpan">(key, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEncryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// generate a random key and IV
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(8);

// encrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createEncryptionCipher</span>(key);
cipher.start(iv);
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes.startDecrypting" id="apidoc.element.node-forge.aes.startDecrypting">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>startDecrypting
        <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startDecrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.aes.startEncrypting" id="apidoc.element.node-forge.aes.startEncrypting">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>startEncrypting
        <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startEncrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.aes.Algorithm" id="apidoc.module.node-forge.aes.Algorithm">module node-forge.aes.Algorithm</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.aes.Algorithm.Algorithm" id="apidoc.element.node-forge.aes.Algorithm.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.aes.</span>Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Algorithm = function (name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.<span class="apidocCodeKeywordSpan">Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.aes.Algorithm.prototype" id="apidoc.module.node-forge.aes.Algorithm.prototype">module node-forge.aes.Algorithm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.aes.Algorithm.prototype.initialize" id="apidoc.element.node-forge.aes.Algorithm.prototype.initialize">
        function <span class="apidocSignatureSpan">node-forge.aes.Algorithm.prototype.</span>initialize
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (options) {
  if(this._init) {
    return;
  }

  var key = options.key;
  var tmp;

<span class="apidocCodeCommentSpan">  /* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */
</span>
  if(typeof key === 'string' &amp;&amp;
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key string into byte buffer
    key = forge.util.createBuffer(key);
  } else if(forge.util.isArray(key) &amp;&amp;
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key integer array into byte buffer
    tmp = key;
    key = forge.util.createBuffer();
    for(var i = 0; i &lt; tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }

  // convert key byte buffer into 32-bit integer array
  if(!forge.util.isArray(key)) {
    tmp = key;
    key = [];

    // key lengths of 16, 24, 32 bytes allowed
    var len = tmp.length();
    if(len === 16 || len === 24 || len === 32) {
      len = len &gt;&gt;&gt; 2;
      for(var i = 0; i &lt; len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }

  // key must be an array of 32-bit integers by now
  if(!forge.util.isArray(key) ||
    !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error('Invalid key parameter.');
  }

  // encryption operation is always used for these modes
  var mode = this.mode.name;
  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);

  // do key expansion
  this._w = _expandKey(key, options.decrypt &amp;&amp; !encryptOp);
  this._init = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.mode = this.algorithm.mode;
 this.blockSize = this.mode.blockSize;
 this._finish = false;
 this._input = null;
 this.output = null;
 this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
 this._decrypt = options.decrypt;
 this.algorithm.<span class="apidocCodeKeywordSpan">initialize</span>(options);
};

/**
* Starts or restarts the encryption or decryption process, whichever
* was previously configured.
*
* For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.asn1" id="apidoc.module.node-forge.asn1">module node-forge.asn1</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.asn1.copy" id="apidoc.element.node-forge.asn1.copy">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>copy
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (obj, options) {
  var copy;

  if(forge.util.isArray(obj)) {
    copy = [];
    for(var i = 0; i &lt; obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }
    return copy;
  }

  if(typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };
  if(options &amp;&amp; !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   value: value
 };
 if(options &amp;&amp; 'bitStringContents' in options) {
   // TODO: copy byte buffer if it's a buffer not a string
   obj.bitStringContents = options.bitStringContents;
   // TODO: add readonly flag to avoid this overhead
   // save copy to detect changes
   obj.original = asn1.<span class="apidocCodeKeywordSpan">copy</span>(obj);
 }
 return obj;
};

/**
* Copies an asn1 object.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.create" id="apidoc.element.node-forge.asn1.create">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>create
        <span class="apidocSignatureSpan">(tagClass, type, constructed, value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (tagClass, type, constructed, value, options) {
<span class="apidocCodeCommentSpan">  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */
</span>
  // remove undefined values
  if(forge.util.isArray(value)) {
    var tmp = [];
    for(var i = 0; i &lt; value.length; ++i) {
      if(value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };
  if(options &amp;&amp; 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents;
    // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes
    obj.original = asn1.copy(obj);
  }
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.dateToGeneralizedTime" id="apidoc.element.node-forge.asn1.dateToGeneralizedTime">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>dateToGeneralizedTime
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateToGeneralizedTime = function (date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYYYMMDDHHMMSSZ
  var format = [];
  format.push('' + date.getUTCFullYear());
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i &lt; format.length; ++i) {
    if(format[i].length &lt; 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(date &gt;= jan_1_1950 &amp;&amp; date &lt; jan_1_2050) {
    value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
      asn1.dateToUtcTime(date));
  } else {
    value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
      asn1.<span class="apidocCodeKeywordSpan">dateToGeneralizedTime</span>(date));
  }
}

// TODO: expose as common API call
// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.dateToUtcTime" id="apidoc.element.node-forge.asn1.dateToUtcTime">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>dateToUtcTime
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateToUtcTime = function (date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYMMDDhhmmssZ
  var format = [];
  format.push(('' + date.getUTCFullYear()).substr(2));
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i &lt; format.length; ++i) {
    if(format[i].length &lt; 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      date = asn1.generalizedTimeToDate(date);
    }
  }

  if(date &gt;= jan_1_1950 &amp;&amp; date &lt; jan_1_2050) {
    value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
      asn1.<span class="apidocCodeKeywordSpan">dateToUtcTime</span>(date));
  } else {
    value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
      asn1.dateToGeneralizedTime(date));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.derToInteger" id="apidoc.element.node-forge.asn1.derToInteger">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>derToInteger
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">derToInteger = function (bytes) {
  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var n = bytes.length() * 8;
  if(n &gt; 32) {
    throw new Error('Integer too large; max is 32-bits.');
  }
  return bytes.getSignedInt(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(oid in forge.pki.oids) {
      rval += ' (' + forge.pki.oids[oid] + ') ';
    }
  }
}
if(obj.type === asn1.Type.INTEGER) {
  try {
    rval += asn1.<span class="apidocCodeKeywordSpan">derToInteger</span>(obj.value);
  } catch(ex) {
    rval += '0x' + forge.util.bytesToHex(obj.value);
  }
} else if(obj.type === asn1.Type.BITSTRING) {
  // TODO: shift bits as needed to display without padding
  if(obj.value.length &gt; 1) {
    // remove unused bits field
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.derToOid" id="apidoc.element.node-forge.asn1.derToOid">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>derToOid
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">derToOid = function (bytes) {
  var oid;

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  // first byte is 40 * value1 + value2
  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + (b % 40);

  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var value = 0;
  while(bytes.length() &gt; 0) {
    b = bytes.getByte();
    value = value &lt;&lt; 7;
    // not the last byte for the value
    if(b &amp; 0x80) {
      value += b &amp; 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);
      value = 0;
    }
  }

  return oid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// deserialize to an ASN.1 object from a byte buffer filled with DER data
var object = asn1.fromDer(derBuffer);

// convert an OID dot-separated string to a byte buffer
var derOidBuffer = asn1.oidToDer('1.2.840.113549.1.1.5');

// convert a byte buffer with a DER-encoded OID to a dot-separated string
console.log(asn1.<span class="apidocCodeKeywordSpan">derToOid</span>(derOidBuffer));
// output: 1.2.840.113549.1.1.5

// validates that an ASN.1 object matches a particular ASN.1 structure and
// captures data of interest from that structure for easy access
var publicKeyValidator = {
name: 'SubjectPublicKeyInfo',
tagClass: asn1.Class.UNIVERSAL,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.equals" id="apidoc.element.node-forge.asn1.equals">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>equals
        <span class="apidocSignatureSpan">(obj1, obj2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (obj1, obj2, options) {
  if(forge.util.isArray(obj1)) {
    if(!forge.util.isArray(obj2)) {
      return false;
    }
    if(obj1.length !== obj2.length) {
      return false;
    }
    for(var i = 0; i &lt; obj1.length; ++i) {
      if(!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
      return true;
    }
  }

  if(typeof obj1 !== typeof obj2) {
    return false;
  }

  if(typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass &amp;&amp;
    obj1.type === obj2.type &amp;&amp;
    obj1.constructed === obj2.constructed &amp;&amp;
    obj1.composed === obj2.composed &amp;&amp;
    asn1.equals(obj1.value, obj2.value);
  if(options &amp;&amp; options.includeBitStringContents) {
    equal = equal &amp;&amp; (obj1.bitStringContents === obj2.bitStringContents);
  }

  return equal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(!forge.util.isArray(obj2)) {
    return false;
  }
  if(obj1.length !== obj2.length) {
    return false;
  }
  for(var i = 0; i &lt; obj1.length; ++i) {
    if(!asn1.<span class="apidocCodeKeywordSpan">equals</span>(obj1[i], obj2[i])) {
      return false;
    }
    return true;
  }
}

if(typeof obj1 !== typeof obj2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.fromDer" id="apidoc.element.node-forge.asn1.fromDer">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>fromDer
        <span class="apidocSignatureSpan">(bytes, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromDer = function (bytes, options) {
  if(options === undefined) {
    options = {
      strict: true,
      decodeBitStrings: true
    };
  }
  if(typeof options === 'boolean') {
    options = {
      strict: options,
      decodeBitStrings: true
    };
  }
  if(!('strict' in options)) {
    options.strict = true;
  }
  if(!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  }

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  return _fromDer(bytes, bytes.length(), 0, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

__Examples__

```js
// decode p12 from base64
var p12Der = forge.util.decode64(p12b64);
// get p12 as ASN.1 object
var p12Asn1 = forge.asn1.<span class="apidocCodeKeywordSpan">fromDer</span>(p12Der);
// decrypt p12 using the password 'password'
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'password');
// decrypt p12 using non-strict parsing mode (resolves some ASN.1 parse errors)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, 'password');
// decrypt p12 using literally no password (eg: Mac OS X/apple push)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1);
// decrypt p12 using an "empty" password (eg: OpenSSL with no password input)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.generalizedTimeToDate" id="apidoc.element.node-forge.asn1.generalizedTimeToDate">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>generalizedTimeToDate
        <span class="apidocSignatureSpan">(gentime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generalizedTimeToDate = function (gentime) {
<span class="apidocCodeCommentSpan">  /* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
</span>  var date = new Date();

  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;

  if(gentime.charAt(gentime.length - 1) === 'Z') {
    isUTC = true;
  }

  var end = gentime.length - 5, c = gentime.charAt(end);
  if(c === '+' || c === '-') {
    // get hours+minutes offset
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);

    // calculate offset in milliseconds
    offset = hhoffset * 60 + mmoffset;
    offset *= 60000;

    // apply offset
    if(c === '+') {
      offset *= -1;
    }

    isUTC = true;
  }

  // check for second fraction
  if(gentime.charAt(14) === '.') {
    fff = parseFloat(gentime.substr(14), 10) * 1000;
  }

  if(isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);

    // apply offset
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }

  return date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(!isNaN(timestamp)) {
    date = new Date(timestamp);
  } else if(date.length === 13) {
    // YYMMDDHHMMSSZ (13 chars for UTCTime)
    date = asn1.utcTimeToDate(date);
  } else {
    // assume generalized time
    date = asn1.<span class="apidocCodeKeywordSpan">generalizedTimeToDate</span>(date);
  }
}

if(date &gt;= jan_1_1950 &amp;&amp; date &lt; jan_1_2050) {
  value = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
    asn1.dateToUtcTime(date));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.getBerValueLength" id="apidoc.element.node-forge.asn1.getBerValueLength">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>getBerValueLength
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBerValueLength = function (b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is "short form" or "long form" (bit 8 set)
  var length;
  var longForm = b2 &amp; 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 &amp; 0x7F) &lt;&lt; 3);
  }
  return length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// serialize content
var bytes = asn1.toDer(content);

// skip identifier and length per RFC 2315 9.3
// skip identifier (1 byte)
bytes.getByte();
// read and discard length bytes
asn1.<span class="apidocCodeKeywordSpan">getBerValueLength</span>(bytes);
bytes = bytes.getBytes();

// digest content DER value bytes
for(var oid in mds) {
  mds[oid].start().update(bytes);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.integerToDer" id="apidoc.element.node-forge.asn1.integerToDer">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>integerToDer
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">integerToDer = function (x) {
  var rval = forge.util.createBuffer();
  if(x &gt;= -0x80 &amp;&amp; x &lt; 0x80) {
    return rval.putSignedInt(x, 8);
  }
  if(x &gt;= -0x8000 &amp;&amp; x &lt; 0x8000) {
    return rval.putSignedInt(x, 16);
  }
  if(x &gt;= -0x800000 &amp;&amp; x &lt; 0x800000) {
    return rval.putSignedInt(x, 24);
  }
  if(x &gt;= -0x80000000 &amp;&amp; x &lt; 0x80000000) {
    return rval.putSignedInt(x, 32);
  }
  var error = new Error('Integer too large; max is 32-bits.');
  error.integer = x;
  throw error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options.count = options.count || 2048;
options.algorithm = options.algorithm || 'aes128';
options.prfAlgorithm = options.prfAlgorithm || 'sha1';

// generate PBE params
var salt = forge.random.getBytesSync(options.saltSize);
var count = options.count;
var countBytes = asn1.<span class="apidocCodeKeywordSpan">integerToDer</span>(count);
var dkLen;
var encryptionAlgorithm;
var encryptedData;
if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
  // do PBES2
  var ivLen, encOid, cipherFn;
  switch(options.algorithm) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.oidToDer" id="apidoc.element.node-forge.asn1.oidToDer">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>oidToDer
        <span class="apidocSignatureSpan">(oid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oidToDer = function (oid) {
  // split OID into individual values
  var values = oid.split('.');
  var bytes = forge.util.createBuffer();

  // first byte is 40 * value1 + value2
  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var last, valueBytes, value, b;
  for(var i = 2; i &lt; values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    do {
      b = value &amp; 0x7F;
      value = value &gt;&gt;&gt; 7;
      // if value is not last, then turn on 8th bit
      if(!last) {
        b |= 0x80;
      }
      valueBytes.push(b);
      last = false;
    } while(value &gt; 0);

    // add value bytes in reverse (needs to be in big endian)
    for(var n = valueBytes.length - 1; n &gt;= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// create a SubjectPublicKeyInfo
var subjectPublicKeyInfo =
asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
  // AlgorithmIdentifier
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // algorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
      asn1.<span class="apidocCodeKeywordSpan">oidToDer</span>(pki.oids['rsaEncryption']).getBytes()),
    // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
  ]),
  // subjectPublicKey
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
    // RSAPublicKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.prettyPrint" id="apidoc.element.node-forge.asn1.prettyPrint">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>prettyPrint
        <span class="apidocSignatureSpan">(obj, level, indentation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prettyPrint = function (obj, level, indentation) {
  var rval = '';

  // set default level and indentation
  level = level || 0;
  indentation = indentation || 2;

  // start new line for deep levels
  if(level &gt; 0) {
    rval += '\n';
  }

  // create indent
  var indent = '';
  for(var i = 0; i &lt; level * indentation; ++i) {
    indent += ' ';
  }

  // print class:type
  rval += indent + 'Tag: ';
  switch(obj.tagClass) {
  case asn1.Class.UNIVERSAL:
    rval += 'Universal:';
    break;
  case asn1.Class.APPLICATION:
    rval += 'Application:';
    break;
  case asn1.Class.CONTEXT_SPECIFIC:
    rval += 'Context-Specific:';
    break;
  case asn1.Class.PRIVATE:
    rval += 'Private:';
    break;
  }

  if(obj.tagClass === asn1.Class.UNIVERSAL) {
    rval += obj.type;

    // known types
    switch(obj.type) {
    case asn1.Type.NONE:
      rval += ' (None)';
      break;
    case asn1.Type.BOOLEAN:
      rval += ' (Boolean)';
      break;
    case asn1.Type.INTEGER:
      rval += ' (Integer)';
      break;
    case asn1.Type.BITSTRING:
      rval += ' (Bit string)';
      break;
    case asn1.Type.OCTETSTRING:
      rval += ' (Octet string)';
      break;
    case asn1.Type.NULL:
      rval += ' (Null)';
      break;
    case asn1.Type.OID:
      rval += ' (Object Identifier)';
      break;
    case asn1.Type.ODESC:
      rval += ' (Object Descriptor)';
      break;
    case asn1.Type.EXTERNAL:
      rval += ' (External or Instance of)';
      break;
    case asn1.Type.REAL:
      rval += ' (Real)';
      break;
    case asn1.Type.ENUMERATED:
      rval += ' (Enumerated)';
      break;
    case asn1.Type.EMBEDDED:
      rval += ' (Embedded PDV)';
      break;
    case asn1.Type.UTF8:
      rval += ' (UTF8)';
      break;
    case asn1.Type.ROID:
      rval += ' (Relative Object Identifier)';
      break;
    case asn1.Type.SEQUENCE:
      rval += ' (Sequence)';
      break;
    case asn1.Type.SET:
      rval += ' (Set)';
      break;
    case asn1.Type.PRINTABLESTRING:
      rval += ' (Printable String)';
      break;
    case asn1.Type.IA5String:
      rval += ' (IA5String (ASCII))';
      break;
    case asn1.Type.UTCTIME:
      rval += ' (UTC time)';
      break;
    case asn1.Type.GENERALIZEDTIME:
      rval += ' (Generalized time)';
      break;
    case asn1.Type.BMPSTRING:
      rval += ' (BMP String)';
      break;
    }
  } else {
    rval += obj.type;
  }

  rval += '\n';
  rval += indent + 'Constructed: ' + obj.constructed + '\n';

  if(obj.composed) {
    var subvalues = 0;
    var sub = '';
    for(var i = 0; i &lt; obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        subvalues += 1;
        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
        if((i + 1) &lt; obj.value.length) {
          sub += ',';
        }
      }
    }
    rval += indent + 'Sub values: ' + subvalues + sub;
  } else {
    rval += indent + 'Value: ';
    if(obj.type === asn1.Type.OID) {
      var oid = asn1.derToOid(obj.value);
      rval += oid;
      if(forge.pki &amp;&amp; forge.pki.oids) {
        if(oid in forge.pki.oids) {
          rval += ' (' + forge.pki.oids[oid] + ') ';
        }
      }
    }
    if(obj.type === asn1.Type.INTEGER) {
      try {
        rval += asn1.derToInteger(obj.value);
      } catch(ex) {
        rval += '0x' + forge.util.bytesToHex(obj.value);
      }
    } else if(obj.type === asn1.Type.BITSTRING) {
      // TODO: shift bits as needed to display without padding
      if(obj.value.length &gt; 1) {
        // remove unused bits field
        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += '(none)';
      }
      // show unused bit count
      if(obj.value.length &gt; 0) {
        var unused = obj.value.charCodeAt(0);
        if(unused == 1) {
          rval += ' (1 unused bit shown)';
        } else if(unused &gt; 1) {
          rval += ' (' + unused + ' unused bits shown)';
        }
      }
    } else if(obj.type === asn1.Type.OCTETSTRING) {
      if(!_nonLatinRegex.test(obj.value)) {
        rval += '(' + obj.value + ') ';
      }
      rval += '0x' + forge.util ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Improve PhantomJS support.
- Move Bower/bundle support to
[forge-dist](https://github.com/digitalbazaar/forge-dist).
- **BREAKING**: Require minimal digest algorithm dependencies from individual
modules.
- Enforce currently supported bit param values for byte buffer access. May be
**BREAKING** for code that depended on unspecified and/or incorrect behavior.
- Improve `asn1.<span class="apidocCodeKeywordSpan">prettyPrint</span>()` BIT STRING display.

### Added

- webpack bundler support via `npm run build`:
- Builds `.js`, `.min.js`, and basic sourcemaps.
- Basic build: `forge.js`.
- Build with extra utils and networking support: `forge.all.js`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.toDer" id="apidoc.element.node-forge.asn1.toDer">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>toDer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDer = function (obj) {
  var bytes = forge.util.createBuffer();

  // build the first byte
  var b1 = obj.tagClass | obj.type;

  // for storing the ASN.1 value
  var value = forge.util.createBuffer();

  // use BIT STRING contents if available and data not changed
  var useBitStringContents = false;
  if('bitStringContents' in obj) {
    useBitStringContents = true;
    if(obj.original) {
      useBitStringContents = asn1.equals(obj, obj.original);
    }
  }

  if(useBitStringContents) {
    value.putBytes(obj.bitStringContents);
  } else if(obj.composed) {
    // if composed, use each child asn1 object's DER bytes as value
    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
    // from other asn1 objects
    if(obj.constructed) {
      b1 |= 0x20;
    } else {
      // type is a bit string, add unused bits of 0x00
      value.putByte(0x00);
    }

    // add all of the child DER bytes together
    for(var i = 0; i &lt; obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        value.putBuffer(asn1.toDer(obj.value[i]));
      }
    }
  } else {
    // use asn1.value directly
    if(obj.type === asn1.Type.BMPSTRING) {
      for(var i = 0; i &lt; obj.value.length; ++i) {
        value.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      // ensure integer is minimally-encoded
      // TODO: should all leading bytes be stripped vs just one?
      // .. ex '00 00 01' =&gt; '01'?
      if(obj.type === asn1.Type.INTEGER &amp;&amp;
        obj.value.length &gt; 1 &amp;&amp;
        // leading 0x00 for positive integer
        ((obj.value.charCodeAt(0) === 0 &amp;&amp;
        (obj.value.charCodeAt(1) &amp; 0x80) === 0) ||
        // leading 0xFF for negative integer
        (obj.value.charCodeAt(0) === 0xFF &amp;&amp;
        (obj.value.charCodeAt(1) &amp; 0x80) === 0x80))) {
        value.putBytes(obj.value.substr(1));
      } else {
        value.putBytes(obj.value);
      }
    }
  }

  // add tag byte
  bytes.putByte(b1);

  // use "short form" encoding
  if(value.length() &lt;= 127) {
    // one byte describes the length
    // bit 8 = 0 and bits 7-1 = length
    bytes.putByte(value.length() &amp; 0x7F);
  } else {
    // use "long form" encoding
    // 2 to 127 bytes describe the length
    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
    // other bytes: length in base 256, big-endian
    var len = value.length();
    var lenBytes = '';
    do {
      lenBytes += String.fromCharCode(len &amp; 0xFF);
      len = len &gt;&gt;&gt; 8;
    } while(len &gt; 0);

    // set first byte to # bytes used to store the length and turn on
    // bit 8 to indicate long-form length is used
    bytes.putByte(lenBytes.length | 0x80);

    // concatenate length bytes in reverse since they were generated
    // little endian and we need big endian
    for(var i = lenBytes.length - 1; i &gt;= 0; --i) {
      bytes.putByte(lenBytes.charCodeAt(i));
    }
  }

  // concatenate value bytes
  bytes.putBuffer(value);
  return bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// generate a p12 that can be imported by Chrome/Firefox/iOS
// (requires the use of Triple DES instead of AES)
var p12Asn1 = forge.pkcs12.toPkcs12Asn1(
  privateKey, certificateChain, 'password',
  {algorithm: '3des'});

// base64-encode p12
var p12Der = forge.asn1.<span class="apidocCodeKeywordSpan">toDer</span>(p12Asn1).getBytes();
var p12b64 = forge.util.encode64(p12Der);

// create download link for p12
var a = document.createElement('a');
a.download = 'example.p12';
a.setAttribute('href', 'data:application/x-pkcs12;base64,' + p12b64);
a.appendChild(document.createTextNode('Download'));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.utcTimeToDate" id="apidoc.element.node-forge.asn1.utcTimeToDate">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>utcTimeToDate
        <span class="apidocSignatureSpan">(utc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utcTimeToDate = function (utc) {
<span class="apidocCodeCommentSpan">  /* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
</span>  var date = new Date();

  // if YY &gt;= 50 use 19xx, if YY &lt; 50 use 20xx
  var year = parseInt(utc.substr(0, 2), 10);
  year = (year &gt;= 50) ? 1900 + year : 2000 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;

  // not just YYMMDDhhmmZ
  if(utc.length &gt; 11) {
    // get character after minutes
    var c = utc.charAt(10);
    var end = 10;

    // see if seconds are present
    if(c !== '+' &amp;&amp; c !== '-') {
      // get seconds
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  }

  // update date
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);

  if(end) {
    // get +/- after end of time
    c = utc.charAt(end);
    if(c === '+' || c === '-') {
      // get hours+minutes offset
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);

      // calculate offset in milliseconds
      var offset = hhoffset * 60 + mmoffset;
      offset *= 60000;

      // apply offset
      if(c === '+') {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }

  return date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(typeof date === 'string') {
  // try to parse date
  var timestamp = Date.parse(date);
  if(!isNaN(timestamp)) {
    date = new Date(timestamp);
  } else if(date.length === 13) {
    // YYMMDDHHMMSSZ (13 chars for UTCTime)
    date = asn1.<span class="apidocCodeKeywordSpan">utcTimeToDate</span>(date);
  } else {
    // assume generalized time
    date = asn1.generalizedTimeToDate(date);
  }
}

if(date &gt;= jan_1_1950 &amp;&amp; date &lt; jan_1_2050) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.asn1.validate" id="apidoc.element.node-forge.asn1.validate">
        function <span class="apidocSignatureSpan">node-forge.asn1.</span>validate
        <span class="apidocSignatureSpan">(obj, v, capture, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (obj, v, capture, errors) {
  var rval = false;

  // ensure tag class and type are the same if specified
  if((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &amp;&amp;
    (obj.type === v.type || typeof(v.type) === 'undefined')) {
    // ensure constructed flag is the same if specified
    if(obj.constructed === v.constructed ||
      typeof(v.constructed) === 'undefined') {
      rval = true;

      // handle sub values
      if(v.value &amp;&amp; forge.util.isArray(v.value)) {
        var j = 0;
        for(var i = 0; rval &amp;&amp; i &lt; v.value.length; ++i) {
          rval = v.value[i].optional || false;
          if(obj.value[j]) {
            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
            if(rval) {
              ++j;
            } else if(v.value[i].optional) {
              rval = true;
            }
          }
          if(!rval &amp;&amp; errors) {
            errors.push(
              '[' + v.name + '] ' +
              'Tag class "' + v.tagClass + '", type "' +
              v.type + '" expected value length "' +
              v.value.length + '", got "' +
              obj.value.length + '"');
          }
        }
      }

      if(rval &amp;&amp; capture) {
        if(v.capture) {
          capture[v.capture] = obj.value;
        }
        if(v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if(v.captureBitStringContents &amp;&amp; 'bitStringContents' in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if(v.captureBitStringValue &amp;&amp; 'bitStringContents' in obj) {
          var value;
          if(obj.bitStringContents.length &lt; 2) {
            capture[v.captureBitStringValue] = '';
          } else {
            // FIXME: support unused bits with data shifting
            var unused = obj.bitStringContents.charCodeAt(0);
            if(unused !== 0) {
              throw new Error(
                'captureBitStringValue only supported for zero unused bits');
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if(errors) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected constructed "' + v.constructed + '", got "' +
        obj.constructed + '"');
    }
  } else if(errors) {
    if(obj.tagClass !== v.tagClass) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected tag class "' + v.tagClass + '", got "' +
        obj.tagClass + '"');
    }
    if(obj.type !== v.type) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected type "' + v.type + '", got "' + obj.type + '"');
    }
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      captureAsn1: 'rsaPublicKey'
    }]
  }]
};

var capture = {};
var errors = [];
if(!asn1.<span class="apidocCodeKeywordSpan">validate</span>(
  publicKeyValidator, subjectPublicKeyInfo, validator, capture, errors)) {
  throw 'ASN.1 object is not a SubjectPublicKeyInfo.';
}
// capture.subjectPublicKeyInfo contains the full ASN.1 object
// capture.rsaPublicKey contains the full ASN.1 object for the RSA public key
// capture.publicKeyOid only contains the value for the OID
var oid = asn1.derToOid(capture.publicKeyOid);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher" id="apidoc.module.node-forge.cipher">module node-forge.cipher</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher" id="apidoc.element.node-forge.cipher.BlockCipher">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>BlockCipher
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BlockCipher = function (options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.<span class="apidocCodeKeywordSpan">BlockCipher</span>({
    algorithm: api,
    key: key,
    decrypt: false
  });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.createCipher" id="apidoc.element.node-forge.cipher.createCipher">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>createCipher
        <span class="apidocSignatureSpan">(algorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCipher = function (algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var salt = forge.random.getBytesSync(128);
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.<span class="apidocCodeKeywordSpan">createCipher</span>('AES-CBC', key);
cipher.start({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.createDecipher" id="apidoc.element.node-forge.cipher.createDecipher">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>createDecipher
        <span class="apidocSignatureSpan">(algorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDecipher = function (algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
// (other modes include: CFB, OFB, CTR, and GCM)
var decipher = forge.cipher.<span class="apidocCodeKeywordSpan">createDecipher</span>('AES-CBC', key);
decipher.start({iv: iv});
decipher.update(encrypted);
decipher.finish();
// outputs decrypted hex
console.log(decipher.output.toHex());

// encrypt some bytes using GCM mode
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.getAlgorithm" id="apidoc.element.node-forge.cipher.getAlgorithm">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>getAlgorithm
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAlgorithm = function (name) {
  name = name.toUpperCase();
  if(name in forge.cipher.algorithms) {
    return forge.cipher.algorithms[name];
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *          byte buffer.
 *
 * @return the cipher.
 */
forge.cipher.createCipher = function(algorithm, key) {
var api = algorithm;
if(typeof api === 'string') {
  api = forge.cipher.<span class="apidocCodeKeywordSpan">getAlgorithm</span>(api);
  if(api) {
    api = api();
  }
}
if(!api) {
  throw new Error('Unsupported algorithm: ' + algorithm);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.registerAlgorithm" id="apidoc.element.node-forge.cipher.registerAlgorithm">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>registerAlgorithm
        <span class="apidocSignatureSpan">(name, algorithm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerAlgorithm = function (name, algorithm) {
  name = name.toUpperCase();
  forge.cipher.algorithms[name] = algorithm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.Algorithm(name, mode);
  };
  forge.cipher.<span class="apidocCodeKeywordSpan">registerAlgorithm</span>(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
var Nb = 4;       // number of words comprising the state (AES = 4)
var sbox;         // non-linear substitution table used in key expansion
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.BlockCipher" id="apidoc.module.node-forge.cipher.BlockCipher">module node-forge.cipher.BlockCipher</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher.BlockCipher" id="apidoc.element.node-forge.cipher.BlockCipher.BlockCipher">
        function <span class="apidocSignatureSpan">node-forge.cipher.</span>BlockCipher
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BlockCipher = function (options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.<span class="apidocCodeKeywordSpan">BlockCipher</span>({
    algorithm: api,
    key: key,
    decrypt: false
  });
};

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.BlockCipher.prototype" id="apidoc.module.node-forge.cipher.BlockCipher.prototype">module node-forge.cipher.BlockCipher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.finish" id="apidoc.element.node-forge.cipher.BlockCipher.prototype.finish">
        function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>finish
        <span class="apidocSignatureSpan">(pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finish = function (pad) {
  // backwards-compatibility w/deprecated padding API
  // Note: will overwrite padding functions even after another start() call
  if(pad &amp;&amp; (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }

  // build options for padding and afterFinish functions
  var options = {};
  options.decrypt = this._decrypt;

  // get # of bytes that won't fill a block
  options.overflow = this._input.length() % this.blockSize;

  if(!this._decrypt &amp;&amp; this.mode.pad) {
    if(!this.mode.pad(this._input, options)) {
      return false;
    }
  }

  // do final update
  this._finish = true;
  this.update();

  if(this._decrypt &amp;&amp; this.mode.unpad) {
    if(!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if(this.mode.afterFinish) {
    if(!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.<span class="apidocCodeKeywordSpan">finish</span>();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
// (other modes include: CFB, OFB, CTR, and GCM)
var decipher = forge.cipher.createDecipher('AES-CBC', key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.start" id="apidoc.element.node-forge.cipher.BlockCipher.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  options = options || {};
  var opts = {};
  for(var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge.util.createBuffer();
  this.output = options.output || forge.util.createBuffer();
  this.mode.start(opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.BlockCipher.prototype.update" id="apidoc.element.node-forge.cipher.BlockCipher.prototype.update">
        function <span class="apidocSignatureSpan">node-forge.cipher.BlockCipher.prototype.</span>update
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (input) {
  if(input) {
    // input given, so empty it into the input buffer
    this._input.putBuffer(input);
  }

  // do cipher operation until it needs more input and not finished
  while(!this._op.call(this.mode, this._input, this.output, this._finish) &amp;&amp;
    !this._finish) {}

  // free consumed memory from input buffer
  this._input.compact();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
cipher.<span class="apidocCodeKeywordSpan">update</span>(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
// (other modes include: CFB, OFB, CTR, and GCM)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.algorithms" id="apidoc.module.node-forge.cipher.algorithms">module node-forge.cipher.algorithms</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.3DES-CBC" id="apidoc.element.node-forge.cipher.algorithms.3DES-CBC">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CBC
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">3DES-CBC = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.3DES-CFB" id="apidoc.element.node-forge.cipher.algorithms.3DES-CFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">3DES-CFB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.3DES-CTR" id="apidoc.element.node-forge.cipher.algorithms.3DES-CTR">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-CTR
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">3DES-CTR = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.3DES-ECB" id="apidoc.element.node-forge.cipher.algorithms.3DES-ECB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-ECB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">3DES-ECB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.3DES-OFB" id="apidoc.element.node-forge.cipher.algorithms.3DES-OFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>3DES-OFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">3DES-OFB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-CBC" id="apidoc.element.node-forge.cipher.algorithms.AES-CBC">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CBC
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-CBC = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-CFB" id="apidoc.element.node-forge.cipher.algorithms.AES-CFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-CFB = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-CTR" id="apidoc.element.node-forge.cipher.algorithms.AES-CTR">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-CTR
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-CTR = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-ECB" id="apidoc.element.node-forge.cipher.algorithms.AES-ECB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-ECB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-ECB = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-GCM" id="apidoc.element.node-forge.cipher.algorithms.AES-GCM">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-GCM
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-GCM = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.AES-OFB" id="apidoc.element.node-forge.cipher.algorithms.AES-OFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>AES-OFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">AES-OFB = function () {
  return new forge.aes.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.DES-CBC" id="apidoc.element.node-forge.cipher.algorithms.DES-CBC">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CBC
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DES-CBC = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.DES-CFB" id="apidoc.element.node-forge.cipher.algorithms.DES-CFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DES-CFB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.DES-CTR" id="apidoc.element.node-forge.cipher.algorithms.DES-CTR">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-CTR
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DES-CTR = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.DES-ECB" id="apidoc.element.node-forge.cipher.algorithms.DES-ECB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-ECB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DES-ECB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.algorithms.DES-OFB" id="apidoc.element.node-forge.cipher.algorithms.DES-OFB">
        function <span class="apidocSignatureSpan">node-forge.cipher.algorithms.</span>DES-OFB
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DES-OFB = function () {
  return new forge.des.Algorithm(name, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes" id="apidoc.module.node-forge.cipher.modes">module node-forge.cipher.modes</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc" id="apidoc.element.node-forge.cipher.modes.cbc">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>cbc
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cbc = function (options) {
  options = options || {};
  this.name = 'CBC';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cfb" id="apidoc.element.node-forge.cipher.modes.cfb">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>cfb
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cfb = function (options) {
  options = options || {};
  this.name = 'CFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ctr" id="apidoc.element.node-forge.cipher.modes.ctr">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ctr
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ctr = function (options) {
  options = options || {};
  this.name = 'CTR';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb" id="apidoc.element.node-forge.cipher.modes.ecb">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ecb
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ecb = function (options) {
  options = options || {};
  this.name = 'ECB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm" id="apidoc.element.node-forge.cipher.modes.gcm">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>gcm
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gcm = function (options) {
  options = options || {};
  this.name = 'GCM';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;

  // R is actually this value concatenated with 120 more zero bits, but
  // we only XOR against R so the other zeros have no effect -- we just
  // apply this value to the first integer in a block
  this._R = 0xE1000000;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ofb" id="apidoc.element.node-forge.cipher.modes.ofb">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.</span>ofb
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ofb = function (options) {
  options = options || {};
  this.name = 'OFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.cbc.prototype" id="apidoc.module.node-forge.cipher.modes.cbc.prototype">module node-forge.cipher.modes.cbc.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.cbc.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to decrypt
  if(input.length() &lt; this.blockSize &amp;&amp; !(finish &amp;&amp; input.length() &gt; 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i &lt; this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output, save previous ciphered block
  // CBC XOR's IV (or previous block) with ciphertext
  for(var i = 0; i &lt; this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }
  this._prev = this._inBlock.slice(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.cbc.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  if(input.length() &lt; this.blockSize &amp;&amp; !(finish &amp;&amp; input.length() &gt; 0)) {
    return true;
  }

  // get next block
  // CBC XOR's IV (or previous block) with plaintext
  for(var i = 0; i &lt; this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output, save previous block
  for(var i = 0; i &lt; this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
  this._prev = this._outBlock;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.pad" id="apidoc.element.node-forge.cipher.modes.cbc.prototype.pad">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>pad
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad = function (input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var options = {};
options.decrypt = this._decrypt;

// get # of bytes that won't fill a block
options.overflow = this._input.length() % this.blockSize;

if(!this._decrypt &amp;&amp; this.mode.pad) {
  if(!this.mode.<span class="apidocCodeKeywordSpan">pad</span>(this._input, options)) {
    return false;
  }
}

// do final update
this._finish = true;
this.update();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.start" id="apidoc.element.node-forge.cipher.modes.cbc.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  // Note: legacy support for using IV residue (has security flaws)
  // if IV is null, reuse block from previous processing
  if(options.iv === null) {
    // must have a previous block
    if(!this._prev) {
      throw new Error('Invalid IV parameter.');
    }
    this._iv = this._prev.slice(0);
  } else if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } else {
    // save IV as "previous" block
    this._iv = transformIV(options.iv);
    this._prev = this._iv.slice(0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cbc.prototype.unpad" id="apidoc.element.node-forge.cipher.modes.cbc.prototype.unpad">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cbc.prototype.</span>unpad
        <span class="apidocSignatureSpan">(output, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpad = function (output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow &gt; 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count &gt; (this.blockSize &lt;&lt; 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// do final update
this._finish = true;
this.update();

if(this._decrypt &amp;&amp; this.mode.unpad) {
  if(!this.mode.<span class="apidocCodeKeywordSpan">unpad</span>(this.output, options)) {
    return false;
  }
}

if(this.mode.afterFinish) {
  if(!this.mode.afterFinish(this.output, options)) {
    return false;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.cfb.prototype" id="apidoc.module.node-forge.cipher.modes.cfb.prototype">module node-forge.cipher.modes.cfb.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.cfb.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes &gt; 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i &lt; this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }

  if(partialBytes &gt; 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes &gt; 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes &gt; 0 &amp;&amp; !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.cfb.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes &gt; 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i &lt; this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
    this._partialOutput.putInt32(this._partialBlock[i]);
  }

  if(partialBytes &gt; 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes &gt; 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes &gt; 0 &amp;&amp; !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.cfb.prototype.start" id="apidoc.element.node-forge.cipher.modes.cfb.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.cfb.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.ctr.prototype" id="apidoc.module.node-forge.cipher.modes.ctr.prototype">module node-forge.cipher.modes.ctr.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.ctr.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CTR always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output
    for(var i = 0; i &lt; this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes &gt; 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i &lt; this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes &gt; 0) {
      // block still incomplete, restore input buffer
      input.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes &gt; 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes &gt; 0 &amp;&amp; !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // block complete, increment counter (input block)
  inc32(this._inBlock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.ctr.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CTR always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output
    for(var i = 0; i &lt; this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes &gt; 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i &lt; this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes &gt; 0) {
      // block still incomplete, restore input buffer
      input.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes &gt; 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes &gt; 0 &amp;&amp; !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // block complete, increment counter (input block)
  inc32(this._inBlock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ctr.prototype.start" id="apidoc.element.node-forge.cipher.modes.ctr.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ctr.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.ecb.prototype" id="apidoc.module.node-forge.cipher.modes.ecb.prototype">module node-forge.cipher.modes.ecb.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.ecb.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to decrypt
  if(input.length() &lt; this.blockSize &amp;&amp; !(finish &amp;&amp; input.length() &gt; 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i &lt; this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i &lt; this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.ecb.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  if(input.length() &lt; this.blockSize &amp;&amp; !(finish &amp;&amp; input.length() &gt; 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i &lt; this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i &lt; this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.pad" id="apidoc.element.node-forge.cipher.modes.ecb.prototype.pad">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>pad
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pad = function (input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var options = {};
options.decrypt = this._decrypt;

// get # of bytes that won't fill a block
options.overflow = this._input.length() % this.blockSize;

if(!this._decrypt &amp;&amp; this.mode.pad) {
  if(!this.mode.<span class="apidocCodeKeywordSpan">pad</span>(this._input, options)) {
    return false;
  }
}

// do final update
this._finish = true;
this.update();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.start" id="apidoc.element.node-forge.cipher.modes.ecb.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ecb.prototype.unpad" id="apidoc.element.node-forge.cipher.modes.ecb.prototype.unpad">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ecb.prototype.</span>unpad
        <span class="apidocSignatureSpan">(output, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpad = function (output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow &gt; 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count &gt; (this.blockSize &lt;&lt; 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// do final update
this._finish = true;
this.update();

if(this._decrypt &amp;&amp; this.mode.unpad) {
  if(!this.mode.<span class="apidocCodeKeywordSpan">unpad</span>(this.output, options)) {
    return false;
  }
}

if(this.mode.afterFinish) {
  if(!this.mode.afterFinish(this.output, options)) {
    return false;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.gcm.prototype" id="apidoc.module.node-forge.cipher.modes.gcm.prototype">module node-forge.cipher.modes.gcm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.afterFinish" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.afterFinish">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>afterFinish
        <span class="apidocSignatureSpan">(output, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterFinish = function (output, options) {
  var rval = true;

  // handle overflow
  if(options.decrypt &amp;&amp; options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }

  // handle authentication tag
  this.tag = forge.util.createBuffer();

  // concatenate additional data length with cipher length
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));

  // include lengths in hash
  this._s = this.ghash(this._hashSubkey, this._s, lengths);

  // do GCTR(J_0, S)
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for(var i = 0; i &lt; this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  }

  // trim tag to length
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));

  // check authentication tag
  if(options.decrypt &amp;&amp; this.tag.bytes() !== this._tag) {
    rval = false;
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(this._decrypt &amp;&amp; this.mode.unpad) {
    if(!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if(this.mode.afterFinish) {
    if(!this.mode.<span class="apidocCodeKeywordSpan">afterFinish</span>(this.output, options)) {
      return false;
    }
  }

  return true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength &lt; this.blockSize &amp;&amp; !(finish &amp;&amp; inputLength &gt; 0)) {
    return true;
  }

  // encrypt block (GCM always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);

  // update hash block S
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);

  // XOR hash input with output
  for(var i = 0; i &lt; this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  }

  // increment cipher data length
  if(inputLength &lt; this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output
    for(var i = 0; i &lt; this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes &gt; 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i &lt; this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes === 0 || finish) {
      // handle overflow prior to hashing
      if(finish) {
        // get block overflow
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        // truncate for hash function
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }

      // get output block for hashing
      for(var i = 0; i &lt; this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes &gt; 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes &gt; 0 &amp;&amp; !finish) {
      // block still incomplete, restore input buffer, get partial output,
      // and return early
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // update hash block S
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.generateHashTable" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.generateHashTable">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>generateHashTable
        <span class="apidocSignatureSpan">(h, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHashTable = function (h, bits) {
  // TODO: There are further optimizations that would use only the
  // first table M_0 (or some variant) along with a remainder table;
  // this can be explored in the future
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m = new Array(size);
  for(var i = 0; i &lt; size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = (i / perInt) | 0;
    var shft = ((perInt - 1 - (i % perInt)) * bits);
    tmp[idx] = (1 &lt;&lt; (bits - 1)) &lt;&lt; shft;
    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
  }
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);

// generate table M
// use 4-bit tables (32 component decomposition of a 16 byte value)
// 8-bit tables take more space and are known to have security
// vulnerabilities (in native implementations)
this.componentBits = 4;
this._m = this.<span class="apidocCodeKeywordSpan">generateHashTable</span>(this._hashSubkey, this.componentBits);

// Note: support IV length different from 96 bits? (only supporting
// 96 bits is recommended by NIST SP-800-38D)
// generate J_0
var ivLength = iv.length();
if(ivLength === 12) {
  // 96-bit IV
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.generateSubHashTable" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.generateSubHashTable">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>generateSubHashTable
        <span class="apidocSignatureSpan">(mid, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateSubHashTable = function (mid, bits) {
  // compute the table quickly by minimizing the number of
  // POW operations -- they only need to be performed for powers of 2,
  // all other entries can be composed from those powers using XOR
  var size = 1 &lt;&lt; bits;
  var half = size &gt;&gt;&gt; 1;
  var m = new Array(size);
  m[half] = mid.slice(0);
  var i = half &gt;&gt;&gt; 1;
  while(i &gt; 0) {
    // raise m0[2 * i] and store in m0[i]
    this.pow(m[2 * i], m[i] = []);
    i &gt;&gt;= 1;
  }
  i = 2;
  while(i &lt; half) {
    for(var j = 1; j &lt; i; ++j) {
      var m_i = m[i];
      var m_j = m[j];
      m[i + j] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i *= 2;
  }
  m[0] = [0, 0, 0, 0];
<span class="apidocCodeCommentSpan">  /* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */
</span>  for(i = half + 1; i &lt; size; ++i) {
    var c = m[i ^ half];
    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var size = 16 * multiplier;
 var m = new Array(size);
 for(var i = 0; i &lt; size; ++i) {
   var tmp = [0, 0, 0, 0];
   var idx = (i / perInt) | 0;
   var shft = ((perInt - 1 - (i % perInt)) * bits);
   tmp[idx] = (1 &lt;&lt; (bits - 1)) &lt;&lt; shft;
   m[i] = this.<span class="apidocCodeKeywordSpan">generateSubHashTable</span>(this.multiply(tmp, h), bits);
 }
 return m;
};

/**
* Generates a table for multiplying against the hash subkey for one
* particular component (out of all possible component values).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.ghash" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.ghash">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>ghash
        <span class="apidocSignatureSpan">(h, y, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ghash = function (h, y, x) {
  y[0] ^= x[0];
  y[1] ^= x[1];
  y[2] ^= x[2];
  y[3] ^= x[3];
  return this.tableMultiply(y);
  //return this.multiply(y, h);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(ivLength === 12) {
  // 96-bit IV
  this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
} else {
  // IV is NOT 96-bits
  this._j0 = [0, 0, 0, 0];
  while(iv.length() &gt; 0) {
    this._j0 = this.<span class="apidocCodeKeywordSpan">ghash</span>(
      this._hashSubkey, this._j0,
      [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
  }
  this._j0 = this.ghash(
    this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.multiply" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.multiply">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>multiply
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (x, y) {
  var z_i = [0, 0, 0, 0];
  var v_i = y.slice(0);

  // calculate Z_128 (block has 128 bits)
  for(var i = 0; i &lt; 128; ++i) {
    // if x_i is 0, Z_{i+1} = Z_i (unchanged)
    // else Z_{i+1} = Z_i ^ V_i
    // get x_i by finding 32-bit int position, then left shift 1 by remainder
    var x_i = x[(i / 32) | 0] &amp; (1 &lt;&lt; (31 - i % 32));
    if(x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }

    // if LSB(V_i) is 1, V_i = V_i &gt;&gt; 1
    // else V_i = (V_i &gt;&gt; 1) ^ R
    this.pow(v_i, v_i);
  }

  return z_i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
modes.gcm.prototype.ghash = function(h, y, x) {
 y[0] ^= x[0];
 y[1] ^= x[1];
 y[2] ^= x[2];
 y[3] ^= x[3];
 return this.tableMultiply(y);
 //return this.<span class="apidocCodeKeywordSpan">multiply</span>(y, h);
};

/**
* Precomputes a table for multiplying against the hash subkey. This
* mechanism provides a substantial speed increase over multiplication
* performed without a table. The table-based multiplication this table is
* for solves X * H by multiplying each component of X by H and then
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.pow" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.pow">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>pow
        <span class="apidocSignatureSpan">(x, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (x, out) {
  // if LSB(x) is 1, x = x &gt;&gt;&gt; 1
  // else x = (x &gt;&gt;&gt; 1) ^ R
  var lsb = x[3] &amp; 1;

  // always do x &gt;&gt;&gt; 1:
  // starting with the rightmost integer, shift each integer to the right
  // one bit, pulling in the bit from the integer to the left as its top
  // most bit (do this for the last 3 integers)
  for(var i = 3; i &gt; 0; --i) {
    out[i] = (x[i] &gt;&gt;&gt; 1) | ((x[i - 1] &amp; 1) &lt;&lt; 31);
  }
  // shift the first integer normally
  out[0] = x[0] &gt;&gt;&gt; 1;

  // if lsb was not set, then polynomial had a degree of 127 and doesn't
  // need to divided; otherwise, XOR with R to find the remainder; we only
  // need to XOR the first integer since R technically ends w/120 zero bits
  if(lsb) {
    out[0] ^= this._R;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    z_i[1] ^= v_i[1];
    z_i[2] ^= v_i[2];
    z_i[3] ^= v_i[3];
  }

  // if LSB(V_i) is 1, V_i = V_i &gt;&gt; 1
  // else V_i = (V_i &gt;&gt; 1) ^ R
  this.<span class="apidocCodeKeywordSpan">pow</span>(v_i, v_i);
}

return z_i;
};

modes.gcm.prototype.pow = function(x, out) {
// if LSB(x) is 1, x = x &gt;&gt;&gt; 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.start" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // ensure IV is a byte buffer
  var iv = forge.util.createBuffer(options.iv);

  // no ciphered data processed yet
  this._cipherLength = 0;

  // default additional data is none
  var additionalData;
  if('additionalData' in options) {
    additionalData = forge.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge.util.createBuffer();
  }

  // default tag length is 128 bits
  if('tagLength' in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }

  // if tag is given, ensure tag matches tag length
  this._tag = null;
  if(options.decrypt) {
    // save tag to check later
    this._tag = forge.util.createBuffer(options.tag).getBytes();
    if(this._tag.length !== (this._tagLength / 8)) {
      throw new Error('Authentication tag does not match tag length.');
    }
  }

  // create tmp storage for hash calculation
  this._hashBlock = new Array(this._ints);

  // no tag generated yet
  this.tag = null;

  // generate hash subkey
  // (apply block cipher to "zero" block)
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);

  // generate table M
  // use 4-bit tables (32 component decomposition of a 16 byte value)
  // 8-bit tables take more space and are known to have security
  // vulnerabilities (in native implementations)
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);

  // Note: support IV length different from 96 bits? (only supporting
  // 96 bits is recommended by NIST SP-800-38D)
  // generate J_0
  var ivLength = iv.length();
  if(ivLength === 12) {
    // 96-bit IV
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    // IV is NOT 96-bits
    this._j0 = [0, 0, 0, 0];
    while(iv.length() &gt; 0) {
      this._j0 = this.ghash(
        this._hashSubkey, this._j0,
        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }
    this._j0 = this.ghash(
      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
  }

  // generate ICB (initial counter block)
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;

  // consume authentication data
  additionalData = forge.util.createBuffer(additionalData);
  // save additional data length as a BE 64-bit number
  this._aDataLength = from64To32(additionalData.length() * 8);
  // pad additional data to 128 bit (16 byte) block size
  var overflow = additionalData.length() % this.blockSize;
  if(overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while(additionalData.length() &gt; 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.gcm.prototype.tableMultiply" id="apidoc.element.node-forge.cipher.modes.gcm.prototype.tableMultiply">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.gcm.prototype.</span>tableMultiply
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableMultiply = function (x) {
  // assumes 4-bit tables are used
  var z = [0, 0, 0, 0];
  for(var i = 0; i &lt; 32; ++i) {
    var idx = (i / 8) | 0;
    var x_i = (x[idx] &gt;&gt;&gt; ((7 - (i % 8)) * 4)) &amp; 0xF;
    var ah = this._m[i][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }
  return z;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return the hashed value (Ym).
*/
modes.gcm.prototype.ghash = function(h, y, x) {
 y[0] ^= x[0];
 y[1] ^= x[1];
 y[2] ^= x[2];
 y[3] ^= x[3];
 return this.<span class="apidocCodeKeywordSpan">tableMultiply</span>(y);
 //return this.multiply(y, h);
};

/**
* Precomputes a table for multiplying against the hash subkey. This
* mechanism provides a substantial speed increase over multiplication
* performed without a table. The table-based multiplication this table is
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.cipher.modes.ofb.prototype" id="apidoc.module.node-forge.cipher.modes.ofb.prototype">module node-forge.cipher.modes.ofb.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.decrypt" id="apidoc.element.node-forge.cipher.modes.ofb.prototype.decrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(input.length() === 0) {
    return true;
  }

  // encrypt block (OFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output and update next input
    for(var i = 0; i &lt; this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes &gt; 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output
  this._partialOutput.clear();
  for(var i = 0; i &lt; this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }

  if(partialBytes &gt; 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes &gt; 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes &gt; 0 &amp;&amp; !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.encrypt" id="apidoc.element.node-forge.cipher.modes.ofb.prototype.encrypt">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(input, output, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(input.length() === 0) {
    return true;
  }

  // encrypt block (OFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 &amp;&amp; inputLength &gt;= this.blockSize) {
    // XOR input with output and update next input
    for(var i = 0; i &lt; this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes &gt; 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output
  this._partialOutput.clear();
  for(var i = 0; i &lt; this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }

  if(partialBytes &gt; 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i &lt; this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes &gt; 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes &gt; 0 &amp;&amp; !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.cipher.modes.ofb.prototype.start" id="apidoc.element.node-forge.cipher.modes.ofb.prototype.start">
        function <span class="apidocSignatureSpan">node-forge.cipher.modes.ofb.prototype.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.debug" id="apidoc.module.node-forge.debug">module node-forge.debug</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.debug.clear" id="apidoc.element.node-forge.debug.clear">
        function <span class="apidocSignatureSpan">node-forge.debug.</span>clear
        <span class="apidocSignatureSpan">(cat, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (cat, name) {
  if(typeof(cat) === 'undefined') {
    forge.debug.storage = {};
  } else if(cat in forge.debug.storage) {
    if(typeof(name) === 'undefined') {
      delete forge.debug.storage[cat];
    } else {
      delete forge.debug.storage[cat][name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handle partial block
var partialBytes = (this.blockSize - inputLength) % this.blockSize;
if(partialBytes &gt; 0) {
  partialBytes = this.blockSize - partialBytes;
}

// XOR input with output, write input as partial output
this._partialOutput.<span class="apidocCodeKeywordSpan">clear</span>();
for(var i = 0; i &lt; this._ints; ++i) {
  this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
  this._partialOutput.putInt32(this._partialBlock[i]);
}

if(partialBytes &gt; 0) {
  // block still incomplete, restore input buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.debug.get" id="apidoc.element.node-forge.debug.get">
        function <span class="apidocSignatureSpan">node-forge.debug.</span>get
        <span class="apidocSignatureSpan">(cat, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (cat, name) {
  var rval;
  if(typeof(cat) === 'undefined') {
    rval = forge.debug.storage;
  } else if(cat in forge.debug.storage) {
    if(typeof(name) === 'undefined') {
      rval = forge.debug.storage[cat];
    } else {
      rval = forge.debug.storage[cat][name];
    }
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // default to flash storage of cookies
  persistCookies: (typeof(options.persistCookies) === 'undefined') ?
    true : options.persistCookies
};

// add client to debug storage
if(forge.debug) {
  forge.debug.<span class="apidocCodeKeywordSpan">get</span>('forge.http', 'clients').push(client);
}

// load cookies from disk
_loadCookies(client);

/**
 * A default certificate verify function that checks a certificate common
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.debug.set" id="apidoc.element.node-forge.debug.set">
        function <span class="apidocSignatureSpan">node-forge.debug.</span>set
        <span class="apidocSignatureSpan">(cat, name, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (cat, name, data) {
  if(!(cat in forge.debug.storage)) {
    forge.debug.storage[cat] = {};
  }
  forge.debug.storage[cat][name] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Useful to expose data that is otherwise unviewable behind closures.
// NOTE: remember that this can hold references to data and cause leaks!
// format is "forge._debug.&lt;modulename&gt;.&lt;dataname&gt; = data"
// Example:
// (function() {
//   var cat = 'forge.test.Test'; // debugging category
//   var sState = {...}; // local state
//   forge.debug.<span class="apidocCodeKeywordSpan">set</span>(cat, 'sState', sState);
// })();
forge.debug.storage = {};

/**
* Gets debug data. Omit name for all cat data  Omit name and cat for
* all data.
*
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.des" id="apidoc.module.node-forge.des">module node-forge.des</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.des.Algorithm" id="apidoc.element.node-forge.des.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.des.</span>Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Algorithm = function (name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.<span class="apidocCodeKeywordSpan">Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.des.createDecryptionCipher" id="apidoc.element.node-forge.des.createDecryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.des.</span>createDecryptionCipher
        <span class="apidocSignatureSpan">(key, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDecryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createDecryptionCipher</span>(key);
cipher.start(iv);
cipher.update(encrypted);
cipher.finish();
// outputs decrypted hex
console.log(cipher.output.toHex());
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.des.createEncryptionCipher" id="apidoc.element.node-forge.des.createEncryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.des.</span>createEncryptionCipher
        <span class="apidocSignatureSpan">(key, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEncryptionCipher = function (key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// generate a random key and IV
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(8);

// encrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createEncryptionCipher</span>(key);
cipher.start(iv);
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.des.startDecrypting" id="apidoc.element.node-forge.des.startDecrypting">
        function <span class="apidocSignatureSpan">node-forge.des.</span>startDecrypting
        <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startDecrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.des.startEncrypting" id="apidoc.element.node-forge.des.startEncrypting">
        function <span class="apidocSignatureSpan">node-forge.des.</span>startEncrypting
        <span class="apidocSignatureSpan">(key, iv, output, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startEncrypting = function (key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.des.Algorithm" id="apidoc.module.node-forge.des.Algorithm">module node-forge.des.Algorithm</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.des.Algorithm.Algorithm" id="apidoc.element.node-forge.des.Algorithm.Algorithm">
        function <span class="apidocSignatureSpan">node-forge.des.</span>Algorithm
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Algorithm = function (name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.<span class="apidocCodeKeywordSpan">Algorithm</span>(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.des.Algorithm.prototype" id="apidoc.module.node-forge.des.Algorithm.prototype">module node-forge.des.Algorithm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.des.Algorithm.prototype.initialize" id="apidoc.element.node-forge.des.Algorithm.prototype.initialize">
        function <span class="apidocSignatureSpan">node-forge.des.Algorithm.prototype.</span>initialize
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (options) {
  if(this._init) {
    return;
  }

  var key = forge.util.createBuffer(options.key);
  if(this.name.indexOf('3DES') === 0) {
    if(key.length() !== 24) {
      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
    }
  }

  // do key expansion to 16 or 48 subkeys (single or triple DES)
  this._keys = _createKeys(key);
  this._init = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.mode = this.algorithm.mode;
 this.blockSize = this.mode.blockSize;
 this._finish = false;
 this._input = null;
 this.output = null;
 this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
 this._decrypt = options.decrypt;
 this.algorithm.<span class="apidocCodeKeywordSpan">initialize</span>(options);
};

/**
* Starts or restarts the encryption or decryption process, whichever
* was previously configured.
*
* For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.forge" id="apidoc.module.node-forge.forge">module node-forge.forge</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.forge.pbkdf2" id="apidoc.element.node-forge.forge.pbkdf2">
        function <span class="apidocSignatureSpan">node-forge.forge.</span>pbkdf2
        <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2 = function ( p, s, c, dkLen, md, callback) {
  if(typeof md === 'function') {
    callback = md;
    md = null;
  }

  // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed
  if(forge.util.isNodejs &amp;&amp; !forge.options.usePureJavaScript &amp;&amp;
    crypto.pbkdf2 &amp;&amp; (md === null || typeof md !== 'object') &amp;&amp;
    (crypto.pbkdf2Sync.length &gt; 4 || (!md || md === 'sha1'))) {
    if(typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }
    p = new Buffer(p, 'binary');
    s = new Buffer(s, 'binary');
    if(!callback) {
      if(crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }
      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }
    if(crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
        if(err) {
          return callback(err);
        }
        callback(null, key.toString('binary'));
      });
    }
    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
      if(err) {
        return callback(err);
      }
      callback(null, key.toString('binary'));
    });
  }

  if(typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }
  if(typeof md === 'string') {
    if(!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }
    md = forge.md[md].create();
  }

  var hLen = md.digestLength;

<span class="apidocCodeCommentSpan">  /* 1. If dkLen &gt; (2^32 - 1) * hLen, output "derived key too long" and
    stop. */
</span>  if(dkLen &gt; (0xFFFFFFFF * hLen)) {
    var err = new Error('Derived key is too long.');
    if(callback) {
      return callback(err);
    }
    throw err;
  }

  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;

  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */
  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1;

  // sync version
  if(!callback) {
    for(var i = 1; i &lt;= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j &lt;= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        // F(p, s, c, i)
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len&lt;0..r-1&gt; */
      dk += (i &lt; len) ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */
    return dk;
  }

  // async version
  var i = 1, j;
  function outer() {
    if(i &gt; len) {
      // done
      return callback(null, dk);
    }

    // PRF(P, S || INT(i)) (first iteration)
    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();

    // PRF(P, u_{c-1}) (other iterations)
    j = 2;
    inner();
  } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// generate a random key and IV
// Note: a key size of 16 bytes will use AES-128, 24 =&gt; AES-192, 32 =&gt; AES-256
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(16);

/* alternatively, generate a password-based 16-byte key
var salt = forge.random.getBytesSync(128);
var key = forge.pkcs5.<span class="apidocCodeKeywordSpan">pbkdf2</span>('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
...</pre></li>
    </ul>




















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.hmac" id="apidoc.module.node-forge.hmac">module node-forge.hmac</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.hmac.create" id="apidoc.element.node-forge.hmac.create">
        function <span class="apidocSignatureSpan">node-forge.hmac.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  // the hmac key to use
  var _key = null;

  // the message digest to use
  var _md = null;

  // the inner padding
  var _ipadding = null;

  // the outer padding
  var _opadding = null;

  // hmac context
  var ctx = {};

<span class="apidocCodeCommentSpan">  /**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */
</span>  ctx.start = function(md, key) {
    if(md !== null) {
      if(typeof md === 'string') {
        // create builtin message digest
        md = md.toLowerCase();
        if(md in forge.md.algorithms) {
          _md = forge.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        // store message digest
        _md = md;
      }
    }

    if(key === null) {
      // reuse previous key
      key = _key;
    } else {
      if(typeof key === 'string') {
        // convert string into byte buffer
        key = forge.util.createBuffer(key);
      } else if(forge.util.isArray(key)) {
        // convert byte array into byte buffer
        var tmp = key;
        key = forge.util.createBuffer();
        for(var i = 0; i &lt; tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }

      // if key is longer than blocksize, hash it
      var keylen = key.length();
      if(keylen &gt; _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }

      // mix key into inner and outer padding
      // ipadding = [0x36 * blocksize] ^ key
      // opadding = [0x5C * blocksize] ^ key
      _ipadding = forge.util.createBuffer();
      _opadding = forge.util.createBuffer();
      keylen = key.length();
      for(var i = 0; i &lt; keylen; ++i) {
        var tmp = key.at(i);
        _ipadding.putByte(0x36 ^ tmp);
        _opadding.putByte(0x5C ^ tmp);
      }

      // if key is shorter than blocksize, add additional padding
      if(keylen &lt; _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for(var i = 0; i &lt; tmp; ++i) {
          _ipadding.putByte(0x36);
          _opadding.putByte(0x5C);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }

    // digest is done like so: hash(opadding | hash(ipadding | message))

    // prepare to do inner hash
    // hash(ipadding | message)
    _md.start();
    _md.update(_ipadding);
  };

  /**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */
  ctx.update = function(bytes) {
    _md.update(bytes);
  };

  /**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */
  ctx.getMac = function() {
    // digest is done like so: hash(opadding | hash(ipadding | message))
    // here we do the outer hashing
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  // alias for getMac
  ctx.digest = ctx.getMac;

  return ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.http" id="apidoc.module.node-forge.http">module node-forge.http</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.http.createClient" id="apidoc.element.node-forge.http.createClient">
        function <span class="apidocSignatureSpan">node-forge.http.</span>createClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createClient = function (options) {
  // create CA store to share with all TLS connections
  var caStore = null;
  if(options.caCerts) {
    caStore = forge.pki.createCaStore(options.caCerts);
  }

  // get scheme, host, and port from url
  options.url = (options.url ||
    window.location.protocol + '//' + window.location.host);
  var url = http.parseUrl(options.url);
  if(!url) {
    var error = new Error('Invalid url.');
    error.details = {url: options.url};
    throw error;
  }

  // default to 1 connection
  options.connections = options.connections || 1;

  // create client
  var sp = options.socketPool;
  var client = {
    // url
    url: url,
    // socket pool
    socketPool: sp,
    // the policy port to use
    policyPort: options.policyPort,
    // policy url to use
    policyUrl: options.policyUrl,
    // queue of requests to service
    requests: [],
    // all sockets
    sockets: [],
    // idle sockets
    idle: [],
    // whether or not the connections are secure
    secure: (url.scheme === 'https'),
    // cookie jar (key'd off of name and then path, there is only 1 domain
    // and one setting for secure per client so name+path is unique)
    cookies: {},
    // default to flash storage of cookies
    persistCookies: (typeof(options.persistCookies) === 'undefined') ?
      true : options.persistCookies
  };

  // add client to debug storage
  if(forge.debug) {
    forge.debug.get('forge.http', 'clients').push(client);
  }

  // load cookies from disk
  _loadCookies(client);

<span class="apidocCodeCommentSpan">  /**
   * A default certificate verify function that checks a certificate common
   * name against the client's URL host.
   *
   * @param c the TLS connection.
   * @param verified true if cert is verified, otherwise alert number.
   * @param depth the chain depth.
   * @param certs the cert chain.
   *
   * @return true if verified and the common name matches the host, error
   *         otherwise.
   */
</span>  var _defaultCertificateVerify = function(c, verified, depth, certs) {
    if(depth === 0 &amp;&amp; verified === true) {
      // compare common name to url host
      var cn = certs[depth].subject.getField('CN');
      if(cn === null || client.url.host !== cn.value) {
        verified = {
          message: 'Certificate common name does not match url host.'
        };
      }
    }
    return verified;
  };

  // determine if TLS is used
  var tlsOptions = null;
  if(client.secure) {
    tlsOptions = {
      caStore: caStore,
      cipherSuites: options.cipherSuites || null,
      virtualHost: options.virtualHost || url.host,
      verify: options.verify || _defaultCertificateVerify,
      getCertificate: options.getCertificate || null,
      getPrivateKey: options.getPrivateKey || null,
      getSignature: options.getSignature || null,
      prime: options.primeTlsSockets || false
    };

    // if socket pool uses a flash api, then add deflate support to TLS
    if(sp.flashApi !== null) {
      tlsOptions.deflate = function(bytes) {
        // strip 2 byte zlib header and 4 byte trailer
        return forge.util.deflate(sp.flashApi, bytes, true);
      };
      tlsOptions.inflate = function(bytes) {
        return forge.util.inflate(sp.flashApi, bytes, true);
      };
    }
  }

  // create and initialize sockets
  for(var i = 0; i &lt; options.connections; ++i) {
    _initSocket(client, sp.createSocket(), tlsOptions);
  }

  /**
   * Sends a request. A method 'abort' will be set on the request that
   * can be called to attempt to abort the request.
   *
   * @param options:
   *          request: the request to send.
   *          connected: a callback for when the connection is open.
   *          closed: a callback for when the connection is closed.
   *          headerReady: a callback for when the response header arrives.
   *          bodyReady: a callback for when the response body arrives.
   *          error: a callback for if an error occurs.
   */
  client.send = function(options) {
    // add host header if not set
    if(options.request.getField('Host') === null) {
      options.request.setField('Host', client.url.fullHost);
    } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  flashId: options.flashId,
  policyPort: _policyPort,
  policyUrl: _policyUrl,
  msie: options.msie || false
});

// create default http client
_client = http.<span class="apidocCodeKeywordSpan">createClient</span>({
  url: options.url || (
    window.location.protocol + '//' + window.location.host),
  socketPool: _sp,
  policyPort: _policyPort,
  policyUrl: _policyUrl,
  connections: options.connections || _maxConnections,
  caCerts: options.caCerts,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.http.createRequest" id="apidoc.element.node-forge.http.createRequest">
        function <span class="apidocSignatureSpan">node-forge.http.</span>createRequest
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRequest = function (options) {
  options = options || {};
  var request = _createHeader();
  request.version = options.version || 'HTTP/1.1';
  request.method = options.method || null;
  request.path = options.path || null;
  request.body = options.body || null;
  request.bodyDeflated = false;
  request.flashApi = null;

  // add custom headers
  var headers = options.headers || [];
  if(!forge.util.isArray(headers)) {
    headers = [headers];
  }
  for(var i = 0; i &lt; headers.length; ++i) {
    for(var name in headers[i]) {
      request.appendField(name, headers[i][name]);
    }
  }

<span class="apidocCodeCommentSpan">  /**
   * Adds a cookie to the request 'Cookie' header.
   *
   * @param cookie a cookie to add.
   */
</span>  request.addCookie = function(cookie) {
    var value = '';
    var field = request.getField('Cookie');
    if(field !== null) {
      // separate cookies by semi-colons
      value = field + '; ';
    }

    // get current time in utc seconds
    var now = _getUtcTime(new Date());

    // output cookie name and value
    value += cookie.name + '=' + cookie.value;
    request.setField('Cookie', value);
  };

  /**
   * Converts an http request into a string that can be sent as an
   * HTTP request. Does not include any data.
   *
   * @return the string representation of the request.
   */
  request.toString = function() {
    /* Sample request header:
      GET /some/path/?query HTTP/1.1
      Host: www.someurl.com
      Connection: close
      Accept-Encoding: deflate
      Accept: image/gif, text/html
      User-Agent: Mozilla 4.0
     */

    // set default headers
    if(request.getField('User-Agent') === null) {
      request.setField('User-Agent', 'forge.http 1.0');
    }
    if(request.getField('Accept') === null) {
      request.setField('Accept', '*/*');
    }
    if(request.getField('Connection') === null) {
      request.setField('Connection', 'keep-alive');
      request.setField('Keep-Alive', '115');
    }

    // add Accept-Encoding if not specified
    if(request.flashApi !== null &amp;&amp;
      request.getField('Accept-Encoding') === null) {
      request.setField('Accept-Encoding', 'deflate');
    }

    // if the body isn't null, deflate it if its larger than 100 bytes
    if(request.flashApi !== null &amp;&amp; request.body !== null &amp;&amp;
      request.getField('Content-Encoding') === null &amp;&amp;
      !request.bodyDeflated &amp;&amp; request.body.length &gt; 100) {
      // use flash to compress data
      request.body = forge.util.deflate(request.flashApi, request.body);
      request.bodyDeflated = true;
      request.setField('Content-Encoding', 'deflate');
      request.setField('Content-Length', request.body.length);
    } else if(request.body !== null) {
      // set content length for body
      request.setField('Content-Length', request.body.length);
    }

    // build start line
    var rval =
      request.method.toUpperCase() + ' ' + request.path + ' ' +
      request.version + '\r\n';

    // add each header
    for(var name in request.fields) {
      var fields = request.fields[name];
      for(var i = 0; i &lt; fields.length; ++i) {
        rval += name + ': ' + fields[i] + '\r\n';
      }
    }
    // final terminating CRLF
    rval += '\r\n';

    return rval;
  };

  return request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Provides a native [JavaScript][] mini-implementation of an http client that
uses pooled sockets.

__Examples__

```js
// create an HTTP GET request
var request = forge.http.<span class="apidocCodeKeywordSpan">createRequest</span>({method: 'GET', path: url.path});

// send the request somewhere
sendSomehow(request.toString());

// receive response
var buffer = forge.util.createBuffer();
var response = forge.http.createResponse();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.http.createResponse" id="apidoc.element.node-forge.http.createResponse">
        function <span class="apidocSignatureSpan">node-forge.http.</span>createResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createResponse = function () {
  // private vars
  var _first = true;
  var _chunkSize = 0;
  var _chunksFinished = false;

  // create response
  var response = _createHeader();
  response.version = null;
  response.code = 0;
  response.message = null;
  response.body = null;
  response.headerReceived = false;
  response.bodyReceived = false;
  response.flashApi = null;

<span class="apidocCodeCommentSpan">  /**
   * Reads a line that ends in CRLF from a byte buffer.
   *
   * @param b the byte buffer.
   *
   * @return the line or null if none was found.
   */
</span>  var _readCrlf = function(b) {
    var line = null;
    var i = b.data.indexOf('\r\n', b.read);
    if(i != -1) {
      // read line, skip CRLF
      line = b.getBytes(i - b.read);
      b.getBytes(2);
    }
    return line;
  };

  /**
   * Parses a header field and appends it to the response.
   *
   * @param line the header field line.
   */
  var _parseHeader = function(line) {
    var tmp = line.indexOf(':');
    var name = line.substring(0, tmp++);
    response.appendField(
      name, (tmp &lt; line.length) ? line.substring(tmp) : '');
  };

  /**
   * Reads an http response header from a buffer of bytes.
   *
   * @param b the byte buffer to parse the header from.
   *
   * @return true if the whole header was read, false if not.
   */
  response.readHeader = function(b) {
    // read header lines (each ends in CRLF)
    var line = '';
    while(!response.headerReceived &amp;&amp; line !== null) {
      line = _readCrlf(b);
      if(line !== null) {
        // parse first line
        if(_first) {
          _first = false;
          var tmp = line.split(' ');
          if(tmp.length &gt;= 3) {
            response.version = tmp[0];
            response.code = parseInt(tmp[1], 10);
            response.message = tmp.slice(2).join(' ');
          } else {
            // invalid header
            var error = new Error('Invalid http response header.');
            error.details = {'line': line};
            throw error;
          }
        } else if(line.length === 0) {
          // handle final line, end of header
          response.headerReceived = true;
        } else {
          _parseHeader(line);
        }
      }
    }

    return response.headerReceived;
  };

  /**
   * Reads some chunked http response entity-body from the given buffer of
   * bytes.
   *
   * @param b the byte buffer to read from.
   *
   * @return true if the whole body was read, false if not.
   */
  var _readChunkedBody = function(b) {
    /* Chunked transfer-encoding sends data in a series of chunks,
      followed by a set of 0-N http trailers.
      The format is as follows:

      chunk-size (in hex) CRLF
      chunk data (with "chunk-size" many bytes) CRLF
      ... (N many chunks)
      chunk-size (of 0 indicating the last chunk) CRLF
      N many http trailers followed by CRLF
      blank line + CRLF (terminates the trailers)

      If there are no http trailers, then after the chunk-size of 0,
      there is still a single CRLF (indicating the blank line + CRLF
      that terminates the trailers). In other words, you always terminate
      the trailers with blank line + CRLF, regardless of 0-N trailers. */

      /* From RFC-2616, section 3.6.1, here is the pseudo-code for
      implementing chunked transfer-encoding:

      length := 0
      read chunk-size, chunk-extension (if any) and CRLF
      while (chunk-size &gt; 0) {
        read chunk-data and CRLF
        append chunk-data to entity-body
        length := length + chunk-size
        read chunk-size and CRLF
      }
      read entity-header
      while (entity-header not empty) {
        append entity-header to existing header fields
        read entity-header
      }
      Content-Length := length
      Remove "chunked" from Transfer-Encoding
    */

    var line = '';
    while(line !== null &amp;&amp; b.length() &gt; 0) {
      // if in the process of reading a chunk
      if(_chunkSize &gt; 0) {
        // if there are not enough bytes to read chunk and its
        // trailing CRLF,  we must wait for more data to be received
        if(_chunkSize + 2 &gt; b.length()) {
          break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var request = forge.http.createRequest({method: 'GET', path: url.path});

// send the request somewhere
sendSomehow(request.toString());

// receive response
var buffer = forge.util.createBuffer();
var response = forge.http.<span class="apidocCodeKeywordSpan">createResponse</span>();
var someAsyncDataHandler = function(bytes) {
if(!response.bodyReceived) {
  buffer.putBytes(bytes);
  if(!response.headerReceived) {
    if(response.readHeader(buffer)) {
      console.log('HTTP response header: ' + response.toString());
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.http.parseUrl" id="apidoc.element.node-forge.http.parseUrl">
        function <span class="apidocSignatureSpan">node-forge.http.</span>parseUrl
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseUrl = function (str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&amp;^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = (m === null) ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };
  if(url) {
    url.fullHost = url.host;
    if(url.port) {
      if(url.port !== 80 &amp;&amp; url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if(url.port !== 443 &amp;&amp; url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if(url.scheme === 'http') {
      url.port = 80;
    } else if(url.scheme === 'https') {
      url.port = 443;
    }
    url.full = url.scheme + '://' + url.fullHost;
  }
  return url;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// convert a Node.js Buffer into a forge buffer
// make sure you specify the encoding as 'binary'
var nodeBuffer = new Buffer();
var forgeBuffer = forge.util.createBuffer(nodeBuffer.toString('binary'));

// parse a URL
var parsed = forge.util.<span class="apidocCodeKeywordSpan">parseUrl</span>('http://example.com/foo?bar=baz');
// parsed.scheme, parsed.host, parsed.port, parsed.path, parsed.fullHost
```

&lt;a name="log" /&gt;
### Logging

Provides logging to a javascript console using various categories and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.http.withinCookieDomain" id="apidoc.element.node-forge.http.withinCookieDomain">
        function <span class="apidocSignatureSpan">node-forge.http.</span>withinCookieDomain
        <span class="apidocSignatureSpan">(url, cookie)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withinCookieDomain = function (url, cookie) {
  var rval = false;

  // cookie may be null, a cookie object, or a domain string
  var domain = (cookie === null || typeof cookie === 'string') ?
    cookie : cookie.domain;

  // any domain will do
  if(domain === null) {
    rval = true;
  } else if(domain.charAt(0) === '.') {
    // ensure domain starts with a '.'
    // parse URL as necessary
    if(typeof url === 'string') {
      url = http.parseUrl(url);
    }

    // add '.' to front of URL host to match against domain
    var host = '.' + url.host;

    // if the host ends with domain then it falls within it
    var idx = host.lastIndexOf(domain);
    if(idx !== -1 &amp;&amp; (idx + domain.length === host.length)) {
      rval = true;
    }
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var error = new Error('Http client url scheme is incompatible ' +
    'with cookie secure flag.');
  error.url = client.url;
  error.cookie = cookie;
  throw error;
}
// make sure url host is within cookie.domain
if(!http.<span class="apidocCodeKeywordSpan">withinCookieDomain</span>(client.url, cookie)) {
  var error = new Error('Http client url scheme is incompatible ' +
    'with cookie secure flag.');
  error.url = client.url;
  error.cookie = cookie;
  throw error;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.jsbn" id="apidoc.module.node-forge.jsbn">module node-forge.jsbn</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger" id="apidoc.element.node-forge.jsbn.BigInteger">
        function <span class="apidocSignatureSpan">node-forge.jsbn.</span>BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.jsbn.BigInteger" id="apidoc.module.node-forge.jsbn.BigInteger">module node-forge.jsbn.BigInteger</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.BigInteger" id="apidoc.element.node-forge.jsbn.BigInteger.BigInteger">
        function <span class="apidocSignatureSpan">node-forge.jsbn.</span>BigInteger
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigInteger(a, b, c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.jsbn.BigInteger.prototype" id="apidoc.module.node-forge.jsbn.BigInteger.prototype">module node-forge.jsbn.BigInteger.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.abs" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.abs">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAbs() { return (this.s&lt;0)?this.negate():this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
r.t = i;
r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
var x = this.<span class="apidocCodeKeywordSpan">abs</span>(), y = a.abs();
var i = x.t;
r.t = i+y.t;
while(--i &gt;= 0) r.data[i] = 0;
for(i = 0; i &lt; y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);
r.s = 0;
r.clamp();
if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.add" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.add">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>add
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if(ac) c.subTo(a,c);
   d.subTo(b,d);
 }
}
if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
if(d.compareTo(m) &gt;= 0) return d.subtract(m);
if(d.signum() &lt; 0) d.addTo(m,d); else return d;
if(d.signum() &lt; 0) return d.<span class="apidocCodeKeywordSpan">add</span>(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,
151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,
337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
var lplim = (1&lt;&lt;26)/lowprimes[lowprimes.length-1];

//(public) test primality with certainty &gt;= 1-.5^t
function bnIsProbablePrime(t) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.addTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.addTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>addTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpAddTo(a, r) {
var i = 0, c = 0, m = Math.min(a.t,this.t);
while(i &lt; m) {
 c += this.data[i]+a.data[i];
 r.data[i++] = c&amp;this.DM;
 c &gt;&gt;= this.DB;
}
if(a.t &lt; this.t) {
 c += a.s;
 while(i &lt; this.t) {
   c += this.data[i];
   r.data[i++] = c&amp;this.DM;
   c &gt;&gt;= this.DB;
 }
 c += this.s;
} else {
 c += this.s;
 while(i &lt; a.t) {
   c += a.data[i];
   r.data[i++] = c&amp;this.DM;
   c &gt;&gt;= this.DB;
 }
 c += a.s;
}
r.s = (c&lt;0)?-1:0;
if(c &gt; 0) r.data[i++] = c;
else if(c &lt; -1) r.data[i++] = this.DV+c;
r.t = i;
r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(c &gt; 0) r.data[i++] = c;
else if(c &lt; -1) r.data[i++] = this.DV+c;
r.t = i;
r.clamp();
}

//(public) this + a
function bnAdd(a) { var r = nbi(); this.<span class="apidocCodeKeywordSpan">addTo</span>(a,r); return r; }

//(public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

//(public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.am" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.am">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>am
        <span class="apidocSignatureSpan">(i, x, w, j, c, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function am3(i, x, w, j, c, n) {
  var xl = x&amp;0x3fff, xh = x&gt;&gt;14;
  while(--n &gt;= 0) {
    var l = this.data[i]&amp;0x3fff;
    var h = this.data[i++]&gt;&gt;14;
    var m = xh*l+h*xl;
    l = xl*l+((m&amp;0x3fff)&lt;&lt;14)+w.data[j]+c;
    c = (l&gt;&gt;28)+(m&gt;&gt;14)+xh*h;
    w.data[j++] = l&amp;0xfffffff;
  }
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i &gt;= 0) r.data[i] = 0;
  for(i = 0; i &lt; y.t; ++i) r.data[i+x.t] = x.<span class="apidocCodeKeywordSpan">am</span>(0,y.data[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.and" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.and">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>and
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.andNot" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.andNot">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>andNot
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitCount" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.bitCount">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitCount() {
var r = 0, x = this.s&amp;this.DM;
for(var i = 0; i &lt; this.t; ++i) r += cbit(this.data[i]^x);
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitLength" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.bitLength">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnBitLength() {
  if(this.t &lt;= 0) return 0;
  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&amp;this.DM));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else {
  this.fromNumber(a,c);
  if(!this.testBit(a-1))  // force MSB set
    this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
  if(this.isEven()) this.dAddOffset(1,0); // force odd
  while(!this.isProbablePrime(b)) {
    this.dAddOffset(2,0);
    if(this.<span class="apidocCodeKeywordSpan">bitLength</span>() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
  }
}
} else {
// new BigInteger(int,RNG)
var x = new Array(), t = a&amp;7;
x.length = (a&gt;&gt;3)+1;
b.nextBytes(x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.bitwiseTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.bitwiseTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>bitwiseTo
        <span class="apidocSignatureSpan">(a, op, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpBitwiseTo(a, op, r) {
var i, f, m = Math.min(a.t,this.t);
for(i = 0; i &lt; m; ++i) r.data[i] = op(this.data[i],a.data[i]);
if(a.t &lt; this.t) {
 f = a.s&amp;this.DM;
 for(i = m; i &lt; this.t; ++i) r.data[i] = op(this.data[i],f);
 r.t = this.t;
} else {
 f = this.s&amp;this.DM;
 for(i = m; i &lt; a.t; ++i) r.data[i] = op(f,a.data[i]);
 r.t = a.t;
}
r.s = op(this.s,a.s);
r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
 // new BigInteger(int,int,RNG)
 if(a &lt; 2) this.fromInt(1);
 else {
   this.fromNumber(a,c);
   if(!this.testBit(a-1))  // force MSB set
     this.<span class="apidocCodeKeywordSpan">bitwiseTo</span>(BigInteger.ONE.shiftLeft(a-1),op_or,this);
   if(this.isEven()) this.dAddOffset(1,0); // force odd
   while(!this.isProbablePrime(b)) {
     this.dAddOffset(2,0);
     if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
   }
 }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.byteValue" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.byteValue">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>byteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnByteValue() { return (this.t==0)?this.s:(this.data[0]&lt;&lt;24)&gt;&gt;24; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var num = new BigInteger(bits, rng);
 // force MSB set
 var bits1 = bits - 1;
 if(!num.testBit(bits1)) {
   num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
 }
 // align number on 30k+1 boundary
 num.dAddOffset(31 - num.mod(THIRTY).<span class="apidocCodeKeywordSpan">byteValue</span>(), 0);
 return num;
}

/**
* Returns the required number of Miller-Rabin tests to generate a
* prime with an error probability of (1/2)^80.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.changeBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.changeBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>changeBit
        <span class="apidocSignatureSpan">(n, op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChangeBit(n, op) {
var r = BigInteger.ONE.shiftLeft(n);
this.bitwiseTo(r,op,r);
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpChangeBit(n,op) {
var r = BigInteger.ONE.shiftLeft(n);
this.bitwiseTo(r,op,r);
return r;
}

//(public) this | (1&lt;&lt;n)
function bnSetBit(n) { return this.<span class="apidocCodeKeywordSpan">changeBit</span>(n,op_or); }

//(public) this &amp; ~(1&lt;&lt;n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

//(public) this ^ (1&lt;&lt;n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.chunkSize" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.chunkSize">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>chunkSize
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.<span class="apidocCodeKeywordSpan">chunkSize</span>(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
 r = (a+z.intValue()).toString(b).substr(1) + r;
 y.divRemTo(d,y,z);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clamp" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.clamp">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpClamp() {
  var c = this.s&amp;this.DM;
  while(this.t &gt; 0 &amp;&amp; this.data[this.t-1] == c) --this.t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sh += k;
  if(sh &gt;= this.DB) sh -= this.DB;
}
if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
  this.s = -1;
  if(sh &gt; 0) this.data[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
}
this.<span class="apidocCodeKeywordSpan">clamp</span>();
if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
var c = this.s&amp;this.DM;
while(this.t &gt; 0 &amp;&amp; this.data[this.t-1] == c) --this.t;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clearBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.clearBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clearBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClearBit(n) { return this.changeBit(n,op_andnot); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.clone" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.clone">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnClone() { var r = nbi(); this.copyTo(r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}
return z.revert(r);
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s&lt;0)?this.negate():this.<span class="apidocCodeKeywordSpan">clone</span>();
var y = (a.s&lt;0)?a.negate():a.clone();
if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
var i = x.getLowestSetBit(), g = y.getLowestSetBit();
if(g &lt; 0) return x;
if(i &lt; g) g = i;
if(g &gt; 0) {
x.rShiftTo(g,x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.compareTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.compareTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>compareTo
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s&lt;0)?-r:r;
  while(--i &gt;= 0) if((r=this.data[i]-a.data[i]) != 0) return r;
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ys = y.t;
var y0 = y.data[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y.data[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
y.dlShiftTo(j,t);
if(r.<span class="apidocCodeKeywordSpan">compareTo</span>(t) &gt;= 0) {
  r.data[r.t++] = 1;
  r.subTo(t,r);
}
BigInteger.ONE.dlShiftTo(ys,t);
t.subTo(y,y);	// "negative" y so we can replace sub with am later
while(y.t &lt; ys) y.data[y.t++] = 0;
while(--j &gt;= 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.copyTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.copyTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>copyTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpCopyTo(r) {
  for(var i = this.t-1; i &gt;= 0; --i) r.data[i] = this.data[i];
  r.t = this.t;
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
var pm = m.abs();
if(pm.t &lt;= 0) return;
var pt = this.abs();
if(pt.t &lt; pm.t) {
  if(q != null) q.fromInt(0);
  if(r != null) this.<span class="apidocCodeKeywordSpan">copyTo</span>(r);
  return;
}
if(r == null) r = nbi();
var y = nbi(), ts = this.s, ms = m.s;
var nsh = this.DB-nbits(pm.data[pm.t-1]);	// normalize modulus
if(nsh &gt; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }
var ys = y.t;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dAddOffset" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.dAddOffset">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dAddOffset
        <span class="apidocSignatureSpan">(n, w)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDAddOffset(n, w) {
if(n == 0) return;
while(this.t &lt;= w) this.data[this.t++] = 0;
this.data[w] += n;
while(this.data[w] &gt;= this.DV) {
 this.data[w] -= this.DV;
 if(++w &gt;= this.t) this.data[this.t++] = 0;
 ++this.data[w];
}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(x &lt; 0) {
  if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
  continue;
}
w = b*w+x;
if(++j &gt;= cs) {
  this.dMultiply(d);
  this.<span class="apidocCodeKeywordSpan">dAddOffset</span>(w,0);
  j = 0;
  w = 0;
}
}
if(j &gt; 0) {
this.dMultiply(Math.pow(b,j));
this.dAddOffset(w,0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dMultiply" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.dMultiply">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dMultiply
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDMultiply(n) {
this.data[this.t] = this.am(0,n-1,this,0,0,this.t);
++this.t;
this.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var x = intAt(s,i);
if(x &lt; 0) {
  if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
  continue;
}
w = b*w+x;
if(++j &gt;= cs) {
  this.<span class="apidocCodeKeywordSpan">dMultiply</span>(d);
  this.dAddOffset(w,0);
  j = 0;
  w = 0;
}
}
if(j &gt; 0) {
this.dMultiply(Math.pow(b,j));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divRemTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.divRemTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divRemTo
        <span class="apidocSignatureSpan">(m, q, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if(pm.t &lt;= 0) return;
  var pt = this.abs();
  if(pt.t &lt; pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm.data[pm.t-1]);	// normalize modulus
  if(nsh &gt; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y.data[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y.data[ys-2]&gt;&gt;this.F2:0);
  var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) &gt;= 0) {
    r.data[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t &lt; ys) y.data[y.t++] = 0;
  while(--j &gt;= 0) {
    // Estimate quotient digit
    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);
    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) &lt; qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r.data[i] &lt; --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh &gt; 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(nsh &gt; 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().<span class="apidocCodeKeywordSpan">divRemTo</span>(a,null,r);
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divide" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.divide">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divide
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//Barrett modular reduction
function Barrett(m) {
// setup Barrett
this.r2 = nbi();
this.q3 = nbi();
BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
this.mu = this.r2.<span class="apidocCodeKeywordSpan">divide</span>(m);
this.m = m;
}

function barrettConvert(x) {
if(x.s &lt; 0 || x.t &gt; 2*this.m.t) return x.mod(this.m);
else if(x.compareTo(this.m) &lt; 0) return x;
else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.divideAndRemainder" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.divideAndRemainder">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>divideAndRemainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnDivideAndRemainder(a) {
var q = nbi(), r = nbi();
this.divRemTo(a,q,r);
return new Array(q,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.dlShiftTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.dlShiftTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>dlShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDLShiftTo(n, r) {
  var i;
  for(i = this.t-1; i &gt;= 0; --i) r.data[i+n] = this.data[i];
  for(i = n-1; i &gt;= 0; --i) r.data[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(nsh &gt; 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }
var ys = y.t;
var y0 = y.data[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y.data[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
y.<span class="apidocCodeKeywordSpan">dlShiftTo</span>(j,t);
if(r.compareTo(t) &gt;= 0) {
  r.data[r.t++] = 1;
  r.subTo(t,r);
}
BigInteger.ONE.dlShiftTo(ys,t);
t.subTo(y,y);	// "negative" y so we can replace sub with am later
while(y.t &lt; ys) y.data[y.t++] = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.drShiftTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.drShiftTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>drShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpDRShiftTo(n, r) {
  for(var i = n; i &lt; this.t; ++i) r.data[i-n] = this.data[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) &lt; qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r.data[i] &lt; --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.<span class="apidocCodeKeywordSpan">drShiftTo</span>(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh &gt; 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.equals" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.equals">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>equals
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnEquals(a) { return(this.compareTo(a)==0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(!forge.util.isArray(obj2)) {
    return false;
  }
  if(obj1.length !== obj2.length) {
    return false;
  }
  for(var i = 0; i &lt; obj1.length; ++i) {
    if(!asn1.<span class="apidocCodeKeywordSpan">equals</span>(obj1[i], obj2[i])) {
      return false;
    }
    return true;
  }
}

if(typeof obj1 !== typeof obj2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.exp" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.exp">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>exp
        <span class="apidocSignatureSpan">(e, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpExp(e, z) {
  if(e &gt; 0xffffffff || e &lt; 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i &gt;= 0) {
    z.sqrTo(r,r2);
    if((e&amp;(1&lt;&lt;i)) &gt; 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return z.revert(r);
}

// (public) this^e % m, 0 &lt;= e &lt; 2^32
function bnModPowInt(e,m) {
  var z;
  if(e &lt; 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.<span class="apidocCodeKeywordSpan">exp</span>(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.flipBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.flipBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>flipBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnFlipBit(n) { return this.changeBit(n,op_xor); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromInt" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.fromInt">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromInt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromInt(x) {
  this.t = 1;
  this.s = (x&lt;0)?-1:0;
  if(x &gt; 0) this.data[0] = x;
  else if(x &lt; -1) this.data[0] = x+this.DV;
  else this.t = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.s = (x&lt;0)?-1:0;
if(x &gt; 0) this.data[0] = x;
else if(x &lt; -1) this.data[0] = x+this.DV;
else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.<span class="apidocCodeKeywordSpan">fromInt</span>(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 256) k = 8; // byte array
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromNumber" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.fromNumber">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromNumber
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromNumber(a, b, c) {
if("number" == typeof b) {
 // new BigInteger(int,int,RNG)
 if(a &lt; 2) this.fromInt(1);
 else {
   this.fromNumber(a,c);
   if(!this.testBit(a-1))  // force MSB set
     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
   if(this.isEven()) this.dAddOffset(1,0); // force odd
   while(!this.isProbablePrime(b)) {
     this.dAddOffset(2,0);
     if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
   }
 }
} else {
 // new BigInteger(int,RNG)
 var x = new Array(), t = a&amp;7;
 x.length = (a&gt;&gt;3)+1;
 b.nextBytes(x);
 if(t &gt; 0) x[0] &amp;= ((1&lt;&lt;t)-1); else x[0] = 0;
 this.fromString(x,256);
}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&amp;0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.<span class="apidocCodeKeywordSpan">fromNumber</span>(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}
forge.jsbn.BigInteger = BigInteger;

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromRadix" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.fromRadix">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromRadix
        <span class="apidocSignatureSpan">(s, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromRadix(s, b) {
this.fromInt(0);
if(b == null) b = 10;
var cs = this.chunkSize(b);
var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
for(var i = 0; i &lt; s.length; ++i) {
 var x = intAt(s,i);
 if(x &lt; 0) {
   if(s.charAt(i) == "-" &amp;&amp; this.signum() == 0) mi = true;
   continue;
 }
 w = b*w+x;
 if(++j &gt;= cs) {
   this.dMultiply(d);
   this.dAddOffset(w,0);
   j = 0;
   w = 0;
 }
}
if(j &gt; 0) {
 this.dMultiply(Math.pow(b,j));
 this.dAddOffset(w,0);
}
if(mi) BigInteger.ZERO.subTo(this,this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 256) k = 8; // byte array
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else { this.<span class="apidocCodeKeywordSpan">fromRadix</span>(s,b); return; }
this.t = 0;
this.s = 0;
var i = s.length, mi = false, sh = 0;
while(--i &gt;= 0) {
  var x = (k==8)?s[i]&amp;0xff:intAt(s,i);
  if(x &lt; 0) {
    if(s.charAt(i) == "-") mi = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.fromString" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.fromString">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>fromString
        <span class="apidocSignatureSpan">(s, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpFromString(s, b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i &gt;= 0) {
    var x = (k==8)?s[i]&amp;0xff:intAt(s,i);
    if(x &lt; 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this.data[this.t++] = x;
    else if(sh+k &gt; this.DB) {
      this.data[this.t-1] |= (x&amp;((1&lt;&lt;(this.DB-sh))-1))&lt;&lt;sh;
      this.data[this.t++] = (x&gt;&gt;(this.DB-sh));
    } else
      this.data[this.t-1] |= x&lt;&lt;sh;
    sh += k;
    if(sh &gt;= this.DB) sh -= this.DB;
  }
  if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
    this.s = -1;
    if(sh &gt; 0) this.data[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var j_lm = ((canary&amp;0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null &amp;&amp; "string" != typeof a) this.<span class="apidocCodeKeywordSpan">fromString</span>(a,
256);
    else this.fromString(a,b);
}
forge.jsbn.BigInteger = BigInteger;

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.gcd" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.gcd">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>gcd
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGCD(a) {
var x = (this.s&lt;0)?this.negate():this.clone();
var y = (a.s&lt;0)?a.negate():a.clone();
if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
var i = x.getLowestSetBit(), g = y.getLowestSetBit();
if(g &lt; 0) return x;
if(i &lt; g) g = i;
if(g &gt; 0) {
 x.rShiftTo(g,x);
 y.rShiftTo(g,y);
}
while(x.signum() &gt; 0) {
 if((i = x.getLowestSetBit()) &gt; 0) x.rShiftTo(i,x);
 if((i = y.getLowestSetBit()) &gt; 0) y.rShiftTo(i,y);
 if(x.compareTo(y) &gt;= 0) {
   x.subTo(y,x);
   x.rShiftTo(1,x);
 } else {
   y.subTo(x,y);
   y.rShiftTo(1,y);
 }
}
if(g &gt; 0) y.lShiftTo(g,y);
return y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// cryptographic blinding
var r;
do {
  r = new BigInteger(
    forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
    16);
} while(r.compareTo(key.n) &gt;= 0 || !r.<span class="apidocCodeKeywordSpan">gcd</span>(key.n).equals(BigInteger.ONE));
x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);

// calculate xp and xq
var xp = x.mod(key.p).modPow(key.dP, key.p);
var xq = x.mod(key.q).modPow(key.dQ, key.q);

// xp must be larger than xq to avoid signed bit usage
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.getLowestSetBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.getLowestSetBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>getLowestSetBit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnGetLowestSetBit() {
for(var i = 0; i &lt; this.t; ++i)
 if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);
if(this.s &lt; 0) return this.t*this.DB;
return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s&lt;0)?this.negate():this.clone();
var y = (a.s&lt;0)?a.negate():a.clone();
if(x.compareTo(y) &lt; 0) { var t = x; x = y; y = t; }
var i = x.<span class="apidocCodeKeywordSpan">getLowestSetBit</span>(), g = y.getLowestSetBit();
if(g &lt; 0) return x;
if(i &lt; g) g = i;
if(g &gt; 0) {
 x.rShiftTo(g,x);
 y.rShiftTo(g,y);
}
while(x.signum() &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.intValue" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.intValue">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>intValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIntValue() {
if(this.s &lt; 0) {
 if(this.t == 1) return this.data[0]-this.DV;
 else if(this.t == 0) return -1;
} else if(this.t == 1) return this.data[0];
else if(this.t == 0) return 0;
// assumes 16 &lt; DB &lt; 32
return ((this.data[1]&amp;((1&lt;&lt;(32-this.DB))-1))&lt;&lt;this.DB)|this.data[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(b == null) b = 10;
if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
 r = (a+z.<span class="apidocCodeKeywordSpan">intValue</span>()).toString(b).substr(1) + r;
 y.divRemTo(d,y,z);
}
return z.intValue().toString(b) + r;
}

//(protected) convert from radix string
function bnpFromRadix(s,b) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.invDigit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.invDigit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>invDigit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpInvDigit() {
  if(this.t &lt; 1) return 0;
  var x = this.data[0];
  if((x&amp;1) == 0) return 0;
  var y = x&amp;3;		// y == 1/x mod 2^2
  y = (y*(2-(x&amp;0xf)*y))&amp;0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&amp;0xff)*y))&amp;0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&amp;0xffff)*y)&amp;0xffff)))&amp;0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 &lt; DB &lt;= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV &lt; y &lt; DV
  return (y&gt;0)?this.DV-y:-y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // we really want the negative inverse, and -DV &lt; y &lt; DV
  return (y&gt;0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.<span class="apidocCodeKeywordSpan">invDigit</span>();
  this.mpl = this.mp&amp;0x7fff;
  this.mph = this.mp&gt;&gt;15;
  this.um = (1&lt;&lt;(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.isEven" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.isEven">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpIsEven() { return ((this.t&gt;0)?(this.data[0]&amp;1):this.s) == 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return z.revert(r);
}

// (public) this^e % m, 0 &lt;= e &lt; 2^32
function bnModPowInt(e,m) {
  var z;
  if(e &lt; 256 || m.<span class="apidocCodeKeywordSpan">isEven</span>()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.isProbablePrime" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.isProbablePrime">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>isProbablePrime
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnIsProbablePrime(t) {
var i, x = this.abs();
if(x.t == 1 &amp;&amp; x.data[0] &lt;= lowprimes[lowprimes.length-1]) {
 for(i = 0; i &lt; lowprimes.length; ++i)
   if(x.data[0] == lowprimes[i]) return true;
 return false;
}
if(x.isEven()) return false;
i = 1;
while(i &lt; lowprimes.length) {
 var m = lowprimes[i], j = i+1;
 while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
 m = x.modInt(m);
 while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
}
return x.millerRabin(t);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// new BigInteger(int,int,RNG)
if(a &lt; 2) this.fromInt(1);
else {
  this.fromNumber(a,c);
  if(!this.testBit(a-1))  // force MSB set
    this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
  if(this.isEven()) this.dAddOffset(1,0); // force odd
  while(!this.<span class="apidocCodeKeywordSpan">isProbablePrime</span>(b)) {
    this.dAddOffset(2,0);
    if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
  }
}
} else {
// new BigInteger(int,RNG)
var x = new Array(), t = a&amp;7;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.lShiftTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.lShiftTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>lShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpLShiftTo(n, r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1&lt;&lt;cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s&lt;&lt;bs)&amp;this.DM, i;
  for(i = this.t-1; i &gt;= 0; --i) {
    r.data[i+ds+1] = (this.data[i]&gt;&gt;cbs)|c;
    c = (this.data[i]&amp;bm)&lt;&lt;bs;
  }
  for(i = ds-1; i &gt;= 0; --i) r.data[i] = 0;
  r.data[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(q != null) q.fromInt(0);
  if(r != null) this.copyTo(r);
  return;
}
if(r == null) r = nbi();
var y = nbi(), ts = this.s, ms = m.s;
var nsh = this.DB-nbits(pm.data[pm.t-1]);	// normalize modulus
if(nsh &gt; 0) { pm.<span class="apidocCodeKeywordSpan">lShiftTo</span>(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.
copyTo(r); }
var ys = y.t;
var y0 = y.data[ys-1];
if(y0 == 0) return;
var yt = y0*(1&lt;&lt;this.F1)+((ys&gt;1)?y.data[ys-2]&gt;&gt;this.F2:0);
var d1 = this.FV/yt, d2 = (1&lt;&lt;this.F1)/yt, e = 1&lt;&lt;this.F2;
var i = r.t, j = i-ys, t = (q==null)?nbi():q;
y.dlShiftTo(j,t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.max" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.max">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>max
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMax(a) { return(this.compareTo(a)&gt;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// property_name=value
name = name.toLowerCase();
switch(name) {
case 'expires':
  // replace hyphens w/spaces so date will parse
  value = value.replace(/-/g, ' ');
  var secs = Date.parse(value) / 1000;
  cookie.maxAge = Math.<span class="apidocCodeKeywordSpan">max</span>(0, secs - now);
  break;
case 'max-age':
  cookie.maxAge = parseInt(value, 10);
  break;
case 'secure':
  cookie.secure = true;
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.millerRabin" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.millerRabin">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>millerRabin
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k &lt;= 0) return false;
var r = n1.shiftRight(k);
var prng = bnGetPrng();
var a;
for(var i = 0; i &lt; t; ++i) {
 // select witness 'a' at random from between 1 and n1
 do {
   a = new BigInteger(this.bitLength(), prng);
 }
 while(a.compareTo(BigInteger.ONE) &lt;= 0 || a.compareTo(n1) &gt;= 0);
 var y = a.modPow(r,this);
 if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
   var j = 1;
   while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
     y = y.modPowInt(2,this);
     if(y.compareTo(BigInteger.ONE) == 0) return false;
   }
   if(y.compareTo(n1) != 0) return false;
 }
}
return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
i = 1;
while(i &lt; lowprimes.length) {
 var m = lowprimes[i], j = i+1;
 while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
 m = x.modInt(m);
 while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
}
return x.<span class="apidocCodeKeywordSpan">millerRabin</span>(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k &lt;= 0) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.min" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.min">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>min
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMin(a) { return(this.compareTo(a)&lt;0)?this:a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(bs &gt; 0) r.data[this.t-ds-1] |= (this.s&amp;bm)&lt;&lt;cbs;
r.t = this.t-ds;
r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
var i = 0, c = 0, m = Math.<span class="apidocCodeKeywordSpan">min</span>(a.t,this.t);
while(i &lt; m) {
  c += this.data[i]-a.data[i];
  r.data[i++] = c&amp;this.DM;
  c &gt;&gt;= this.DB;
}
if(a.t &lt; this.t) {
  c -= a.s;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.mod" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.mod">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>mod
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.<span class="apidocCodeKeywordSpan">mod</span>(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modInt" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.modInt">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpModInt(n) {
if(n &lt;= 0) return 0;
var d = this.DV%n, r = (this.s&lt;0)?n-1:0;
if(this.t &gt; 0)
 if(d == 0) r = this.data[0]%n;
 else for(var i = this.t-1; i &gt;= 0; --i) r = (d*r+this.data[i])%n;
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 return false;
}
if(x.isEven()) return false;
i = 1;
while(i &lt; lowprimes.length) {
 var m = lowprimes[i], j = i+1;
 while(j &lt; lowprimes.length &amp;&amp; m &lt; lplim) m *= lowprimes[j++];
 m = x.<span class="apidocCodeKeywordSpan">modInt</span>(m);
 while(i &lt; j) if(m%lowprimes[i++] == 0) return false;
}
return x.millerRabin(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modInverse" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.modInverse">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modInverse
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModInverse(m) {
var ac = m.isEven();
if((this.isEven() &amp;&amp; ac) || m.signum() == 0) return BigInteger.ZERO;
var u = m.clone(), v = this.clone();
var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
while(u.signum() != 0) {
 while(u.isEven()) {
   u.rShiftTo(1,u);
   if(ac) {
     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
     a.rShiftTo(1,a);
   } else if(!b.isEven()) b.subTo(m,b);
   b.rShiftTo(1,b);
 }
 while(v.isEven()) {
   v.rShiftTo(1,v);
   if(ac) {
     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
     c.rShiftTo(1,c);
   } else if(!d.isEven()) d.subTo(m,d);
   d.rShiftTo(1,d);
 }
 if(u.compareTo(v) &gt;= 0) {
   u.subTo(v,u);
   if(ac) a.subTo(c,a);
   b.subTo(d,b);
 } else {
   v.subTo(u,v);
   if(ac) c.subTo(a,c);
   d.subTo(b,d);
 }
}
if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
if(d.compareTo(m) &gt;= 0) return d.subtract(m);
if(d.signum() &lt; 0) d.addTo(m,d); else return d;
if(d.signum() &lt; 0) return d.add(m); else return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(!key.dP) {
key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
  }
  if(!key.dQ) {
key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
  }
  if(!key.qInv) {
key.qInv = key.q.<span class="apidocCodeKeywordSpan">modInverse</span>(key.p);
  }

  /* Chinese remainder theorem (CRT) states:

Suppose n1, n2, ..., nk are positive integers which are pairwise
coprime (n1 and n2 have no common factors other than 1). For any
integers x1, x2, ..., xk there exists an integer x solving the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modPow" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.modPow">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modPow
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPow(e, m) {
var i = e.bitLength(), k, r = nbv(1), z;
if(i &lt;= 0) return r;
else if(i &lt; 18) k = 1;
else if(i &lt; 48) k = 3;
else if(i &lt; 144) k = 4;
else if(i &lt; 768) k = 5;
else k = 6;
if(i &lt; 8)
 z = new Classic(m);
else if(m.isEven())
 z = new Barrett(m);
else
 z = new Montgomery(m);

// precomputation
var g = new Array(), n = 3, k1 = k-1, km = (1&lt;&lt;k)-1;
g[1] = z.convert(this);
if(k &gt; 1) {
 var g2 = nbi();
 z.sqrTo(g[1],g2);
 while(n &lt;= km) {
   g[n] = nbi();
   z.mulTo(g2,g[n-2],g[n]);
   n += 2;
 }
}

var j = e.t-1, w, is1 = true, r2 = nbi(), t;
i = nbits(e.data[j])-1;
while(j &gt;= 0) {
 if(i &gt;= k1) w = (e.data[j]&gt;&gt;(i-k1))&amp;km;
 else {
   w = (e.data[j]&amp;((1&lt;&lt;(i+1))-1))&lt;&lt;(k1-i);
   if(j &gt; 0) w |= e.data[j-1]&gt;&gt;(this.DB+i-k1);
 }

 n = k;
 while((w&amp;1) == 0) { w &gt;&gt;= 1; --n; }
 if((i -= n) &lt; 0) { i += this.DB; --j; }
 if(is1) {  // ret == 1, don't bother squaring or multiplying it
   g[w].copyTo(r);
   is1 = false;
 } else {
   while(n &gt; 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
   if(n &gt; 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
   z.mulTo(r2,g[w],r);
 }

 while(j &gt;= 0 &amp;&amp; (e.data[j]&amp;(1&lt;&lt;i)) == 0) {
   z.sqrTo(r,r2); t = r; r = r2; r2 = t;
   if(--i &lt; 0) { i = this.DB-1; --j; }
 }
}
return z.revert(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var a;
for(var i = 0; i &lt; t; ++i) {
// select witness 'a' at random from between 1 and n1
do {
  a = new BigInteger(this.bitLength(), prng);
}
while(a.compareTo(BigInteger.ONE) &lt;= 0 || a.compareTo(n1) &gt;= 0);
var y = a.<span class="apidocCodeKeywordSpan">modPow</span>(r,this);
if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
  var j = 1;
  while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
    y = y.modPowInt(2,this);
    if(y.compareTo(BigInteger.ONE) == 0) return false;
  }
  if(y.compareTo(n1) != 0) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.modPowInt" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.modPowInt">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>modPowInt
        <span class="apidocSignatureSpan">(e, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnModPowInt(e, m) {
  var z;
  if(e &lt; 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   a = new BigInteger(this.bitLength(), prng);
 }
 while(a.compareTo(BigInteger.ONE) &lt;= 0 || a.compareTo(n1) &gt;= 0);
 var y = a.modPow(r,this);
 if(y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
   var j = 1;
   while(j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
     y = y.<span class="apidocCodeKeywordSpan">modPowInt</span>(2,this);
     if(y.compareTo(BigInteger.ONE) == 0) return false;
   }
   if(y.compareTo(n1) != 0) return false;
 }
}
return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiply" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.multiply">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiply
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
modes.gcm.prototype.ghash = function(h, y, x) {
 y[0] ^= x[0];
 y[1] ^= x[1];
 y[2] ^= x[2];
 y[3] ^= x[3];
 return this.tableMultiply(y);
 //return this.<span class="apidocCodeKeywordSpan">multiply</span>(y, h);
};

/**
* Precomputes a table for multiplying against the hash subkey. This
* mechanism provides a substantial speed increase over multiplication
* performed without a table. The table-based multiplication this table is
* for solves X * H by multiplying each component of X by H and then
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyLowerTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyLowerTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyLowerTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyLowerTo(a, n, r) {
var i = Math.min(this.t+a.t,n);
r.s = 0; // assumes a,this &gt;= 0
r.t = i;
while(i &gt; 0) r.data[--i] = 0;
var j;
for(j = r.t-this.t; i &lt; j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);
for(j = Math.min(a.t,n); i &lt; j; ++i) this.am(0,a.data[i],r,i,0,n-i);
r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function barrettRevert(x) { return x; }

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
x.drShiftTo(this.m.t-1,this.r2);
if(x.t &gt; this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
this.m.<span class="apidocCodeKeywordSpan">multiplyLowerTo</span>(this.q3,this.m.t+1,this.r2);
while(x.compareTo(this.r2) &lt; 0) x.dAddOffset(1,this.m.t+1);
x.subTo(this.r2,x);
while(x.compareTo(this.m) &gt;= 0) x.subTo(this.m,x);
}

//r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i &gt;= 0) r.data[i] = 0;
  for(i = 0; i &lt; y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.<span class="apidocCodeKeywordSpan">multiplyTo</span>(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyUpperTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.multiplyUpperTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>multiplyUpperTo
        <span class="apidocSignatureSpan">(a, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpMultiplyUpperTo(a, n, r) {
--n;
var i = r.t = this.t+a.t-n;
r.s = 0; // assumes a,this &gt;= 0
while(--i &gt;= 0) r.data[i] = 0;
for(i = Math.max(n-this.t,0); i &lt; a.t; ++i)
 r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);
r.clamp();
r.drShiftTo(1,r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function barrettRevert(x) { return x; }

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
x.drShiftTo(this.m.t-1,this.r2);
if(x.t &gt; this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
this.mu.<span class="apidocCodeKeywordSpan">multiplyUpperTo</span>(this.r2,this.m.t+1,this.q3);
this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
while(x.compareTo(this.r2) &lt; 0) x.dAddOffset(1,this.m.t+1);
x.subTo(this.r2,x);
while(x.compareTo(this.m) &gt;= 0) x.subTo(this.m,x);
}

//r = x^2 mod m; x != r
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.negate" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.negate">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpClamp() {
var c = this.s&amp;this.DM;
while(this.t &gt; 0 &amp;&amp; this.data[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
if(this.s &lt; 0) return "-"+this.<span class="apidocCodeKeywordSpan">negate</span>().toString(b);
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else return this.toRadix(b);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.not" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.not">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnNot() {
var r = nbi();
for(var i = 0; i &lt; this.t; ++i) r.data[i] = this.DM&amp;~this.data[i];
r.t = this.t;
r.s = ~this.s;
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.or" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.or">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>or
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.pow" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.pow">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>pow
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnPow(e) { return this.exp(e,new NullExp()); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    z_i[1] ^= v_i[1];
    z_i[2] ^= v_i[2];
    z_i[3] ^= v_i[3];
  }

  // if LSB(V_i) is 1, V_i = V_i &gt;&gt; 1
  // else V_i = (V_i &gt;&gt; 1) ^ R
  this.<span class="apidocCodeKeywordSpan">pow</span>(v_i, v_i);
}

return z_i;
};

modes.gcm.prototype.pow = function(x, out) {
// if LSB(x) is 1, x = x &gt;&gt;&gt; 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.rShiftTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.rShiftTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>rShiftTo
        <span class="apidocSignatureSpan">(n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds &gt;= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1&lt;&lt;bs)-1;
  r.data[0] = this.data[ds]&gt;&gt;bs;
  for(var i = ds+1; i &lt; this.t; ++i) {
    r.data[i-ds-1] |= (this.data[i]&amp;bm)&lt;&lt;cbs;
    r.data[i-ds] = this.data[i]&gt;&gt;bs;
  }
  if(bs &gt; 0) r.data[this.t-ds-1] |= (this.s&amp;bm)&lt;&lt;cbs;
  r.t = this.t-ds;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if(q != null) {
  r.drShiftTo(ys,q);
  if(ts != ms) BigInteger.ZERO.subTo(q,q);
}
r.t = ys;
r.clamp();
if(nsh &gt; 0) r.<span class="apidocCodeKeywordSpan">rShiftTo</span>(nsh,r);	// Denormalize remainder
if(ts &lt; 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
var r = nbi();
this.abs().divRemTo(a,null,r);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.remainder" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.remainder">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>remainder
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.setBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.setBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>setBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSetBit(n) { return this.changeBit(n,op_or); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftLeft" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftLeft(n) {
var r = nbi();
if(n &lt; 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
 // new BigInteger(int,int,RNG)
 if(a &lt; 2) this.fromInt(1);
 else {
   this.fromNumber(a,c);
   if(!this.testBit(a-1))  // force MSB set
     this.bitwiseTo(BigInteger.ONE.<span class="apidocCodeKeywordSpan">shiftLeft</span>(a-1),op_or,this);
   if(this.isEven()) this.dAddOffset(1,0); // force odd
   while(!this.isProbablePrime(b)) {
     this.dAddOffset(2,0);
     if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
   }
 }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftRight" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.shiftRight">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShiftRight(n) {
var r = nbi();
if(n &lt; 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k &lt;= 0) return false;
var r = n1.<span class="apidocCodeKeywordSpan">shiftRight</span>(k);
var prng = bnGetPrng();
var a;
for(var i = 0; i &lt; t; ++i) {
// select witness 'a' at random from between 1 and n1
do {
  a = new BigInteger(this.bitLength(), prng);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.shortValue" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.shortValue">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>shortValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnShortValue() { return (this.t==0)?this.s:(this.data[0]&lt;&lt;16)&gt;&gt;16; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.signum" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.signum">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>signum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSigNum() {
if(this.s &lt; 0) return -1;
else if(this.t &lt;= 0 || (this.t == 1 &amp;&amp; this.data[0] &lt;= 0)) return 0;
else return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if(this.t &lt;= 0 || (this.t == 1 &amp;&amp; this.data[0] &lt;= 0)) return 0;
else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.<span class="apidocCodeKeywordSpan">signum</span>() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
r = (a+z.intValue()).toString(b).substr(1) + r;
y.divRemTo(d,y,z);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.squareTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.squareTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>squareTo
        <span class="apidocSignatureSpan">(r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i &gt;= 0) r.data[i] = 0;
  for(i = 0; i &lt; x.t-1; ++i) {
    var c = x.am(i,x.data[i],r,2*i,0,1);
    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) &gt;= x.DV) {
      r.data[i+x.t] -= x.DV;
      r.data[i+x.t+1] = 1;
    }
  }
  if(r.t &gt; 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cConvert(x) {
  if(x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.<span class="apidocCodeKeywordSpan">squareTo</span>(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.subTo" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.subTo">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>subTo
        <span class="apidocSignatureSpan">(a, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpSubTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i &lt; m) {
    c += this.data[i]-a.data[i];
    r.data[i++] = c&amp;this.DM;
    c &gt;&gt;= this.DB;
  }
  if(a.t &lt; this.t) {
    c -= a.s;
    while(i &lt; this.t) {
      c += this.data[i];
      r.data[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while(i &lt; a.t) {
      c -= a.data[i];
      r.data[i++] = c&amp;this.DM;
      c &gt;&gt;= this.DB;
    }
    c -= a.s;
  }
  r.s = (c&lt;0)?-1:0;
  if(c &lt; -1) r.data[i++] = this.DV+c;
  else if(c &gt; 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(sh &gt;= this.DB) sh -= this.DB;
  }
  if(k == 8 &amp;&amp; (s[0]&amp;0x80) != 0) {
    this.s = -1;
    if(sh &gt; 0) this.data[this.t-1] |= ((1&lt;&lt;(this.DB-sh))-1)&lt;&lt;sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.<span class="apidocCodeKeywordSpan">subTo</span>(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&amp;this.DM;
  while(this.t &gt; 0 &amp;&amp; this.data[this.t-1] == c) --this.t;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.subtract" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.subtract">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>subtract
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   v.subTo(u,v);
   if(ac) c.subTo(a,c);
   d.subTo(b,d);
 }
}
if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
if(d.compareTo(m) &gt;= 0) return d.<span class="apidocCodeKeywordSpan">subtract</span>(m);
if(d.signum() &lt; 0) d.addTo(m,d); else return d;
if(d.signum() &lt; 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,
151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,
337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
var lplim = (1&lt;&lt;26)/lowprimes[lowprimes.length-1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.testBit" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.testBit">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>testBit
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnTestBit(n) {
var j = Math.floor(n/this.DB);
if(j &gt;= this.t) return(this.s!=0);
return((this.data[j]&amp;(1&lt;&lt;(n%this.DB)))!=0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//(protected) alternate constructor
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
// new BigInteger(int,int,RNG)
if(a &lt; 2) this.fromInt(1);
else {
  this.fromNumber(a,c);
  if(!this.<span class="apidocCodeKeywordSpan">testBit</span>(a-1))  // force MSB set
    this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
  if(this.isEven()) this.dAddOffset(1,0); // force odd
  while(!this.isProbablePrime(b)) {
    this.dAddOffset(2,0);
    if(this.bitLength() &gt; a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toByteArray" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.toByteArray">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toByteArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToByteArray() {
var i = this.t, r = new Array();
r[0] = this.s;
var p = this.DB-(i*this.DB)%8, d, k = 0;
if(i-- &gt; 0) {
 if(p &lt; this.DB &amp;&amp; (d = this.data[i]&gt;&gt;p) != (this.s&amp;this.DM)&gt;&gt;p)
   r[k++] = d|(this.s&lt;&lt;(this.DB-p));
 while(i &gt;= 0) {
   if(p &lt; 8) {
     d = (this.data[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(8-p);
     d |= this.data[--i]&gt;&gt;(p+=this.DB-8);
   } else {
     d = (this.data[i]&gt;&gt;(p-=8))&amp;0xff;
     if(p &lt;= 0) { p += this.DB; --i; }
   }
   if((d&amp;0x80) != 0) d |= -256;
   if(k == 0 &amp;&amp; (this.s&amp;0x80) != (d&amp;0x80)) ++k;
   if(k &gt; 0 || d != this.s) r[k++] = d;
 }
}
return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toRadix" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.toRadix">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toRadix
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnpToRadix(b) {
if(b == null) b = 10;
if(this.signum() == 0 || b &lt; 2 || b &gt; 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() &gt; 0) {
 r = (a+z.intValue()).toString(b).substr(1) + r;
 y.divRemTo(d,y,z);
}
return z.intValue().toString(b) + r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(this.s &lt; 0) return "-"+this.negate().toString(b);
var k;
if(b == 16) k = 4;
else if(b == 8) k = 3;
else if(b == 2) k = 1;
else if(b == 32) k = 5;
else if(b == 4) k = 2;
else return this.<span class="apidocCodeKeywordSpan">toRadix</span>(b);
var km = (1&lt;&lt;k)-1, d, m = false, r = "", i = this.t;
var p = this.DB-(i*this.DB)%k;
if(i-- &gt; 0) {
  if(p &lt; this.DB &amp;&amp; (d = this.data[i]&gt;&gt;p) &gt; 0) { m = true; r = int2char(d); }
  while(i &gt;= 0) {
    if(p &lt; k) {
      d = (this.data[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(k-p);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.toString" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.toString">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>toString
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnToString(b) {
  if(this.s &lt; 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1&lt;&lt;k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- &gt; 0) {
    if(p &lt; this.DB &amp;&amp; (d = this.data[i]&gt;&gt;p) &gt; 0) { m = true; r = int2char(d); }
    while(i &gt;= 0) {
      if(p &lt; k) {
        d = (this.data[i]&amp;((1&lt;&lt;p)-1))&lt;&lt;(k-p);
        d |= this.data[--i]&gt;&gt;(p+=this.DB-k);
      } else {
        d = (this.data[i]&gt;&gt;(p-=k))&amp;km;
        if(p &lt;= 0) { p += this.DB; --i; }
      }
      if(d &gt; 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

socket.on('connect', function() {
  console.log('[socket] connected');
  client.handshake();
});
socket.on('data', function(data) {
  client.process(data.<span class="apidocCodeKeywordSpan">toString</span>('binary')); // encoding should be 'binary
'
});
socket.on('end', function() {
  console.log('[socket] disconnected');
});

// connect to google.com
socket.connect(443, 'google.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.jsbn.BigInteger.prototype.xor" id="apidoc.element.node-forge.jsbn.BigInteger.prototype.xor">
        function <span class="apidocSignatureSpan">node-forge.jsbn.BigInteger.prototype.</span>xor
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.kem" id="apidoc.module.node-forge.kem">module node-forge.kem</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.kem.kdf1" id="apidoc.element.node-forge.kem.kdf1">
        function <span class="apidocSignatureSpan">node-forge.kem.</span>kdf1
        <span class="apidocSignatureSpan">(md, digestLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kdf1 = function (md, digestLength) {
  _createKDF(this, md, 0, digestLength || md.digestLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// generate an RSA key pair asynchronously (uses web workers if available)
// use workers: -1 to run a fast core estimator to optimize # of workers
forge.rsa.generateKeyPair({bits: 2048, workers: -1}, function(err, keypair) {
  // keypair.privateKey, keypair.publicKey
});

// generate and encapsulate a 16-byte secret key
var kdf1 = new forge.kem.<span class="apidocCodeKeywordSpan">kdf1</span>(forge.md.sha1.create());
var kem = forge.kem.rsa.create(kdf1);
var result = kem.encrypt(keypair.publicKey, 16);
// result has 'encapsulation' and 'key'

// encrypt some bytes
var iv = forge.random.getBytesSync(12);
var someBytes = 'hello world!';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.kem.kdf2" id="apidoc.element.node-forge.kem.kdf2">
        function <span class="apidocSignatureSpan">node-forge.kem.</span>kdf2
        <span class="apidocSignatureSpan">(md, digestLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kdf2 = function (md, digestLength) {
  _createKDF(this, md, 1, digestLength || md.digestLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.kem.rsa" id="apidoc.module.node-forge.kem.rsa">module node-forge.kem.rsa</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.kem.rsa.create" id="apidoc.element.node-forge.kem.rsa.create">
        function <span class="apidocSignatureSpan">node-forge.kem.rsa.</span>create
        <span class="apidocSignatureSpan">(kdf, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (kdf, options) {
  options = options || {};
  var prng = options.prng || forge.random;

  var kem = {};

<span class="apidocCodeCommentSpan">  /**
   * Generates a secret key and its encapsulation.
   *
   * @param publicKey the RSA public key to encrypt with.
   * @param keyLength the length, in bytes, of the secret key to generate.
   *
   * @return an object with:
   *   encapsulation: the ciphertext for generating the secret key, as a
   *     binary-encoded string of bytes.
   *   key: the secret key to use for encrypting a message.
   */
</span>  kem.encrypt = function(publicKey, keyLength) {
    // generate a random r where 1 &gt; r &gt; n
    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
    var r;
    do {
      r = new BigInteger(
        forge.util.bytesToHex(prng.getBytesSync(byteLength)),
        16).mod(publicKey.n);
    } while(r.equals(BigInteger.ZERO));

    // prepend r with zeros
    r = forge.util.hexToBytes(r.toString(16));
    var zeros = byteLength - r.length;
    if(zeros &gt; 0) {
      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
    }

    // encrypt the random
    var encapsulation = publicKey.encrypt(r, 'NONE');

    // generate the secret key
    var key = kdf.generate(r, keyLength);

    return {encapsulation: encapsulation, key: key};
  };

  /**
   * Decrypts an encapsulated secret key.
   *
   * @param privateKey the RSA private key to decrypt with.
   * @param encapsulation the ciphertext for generating the secret key, as
   *          a binary-encoded string of bytes.
   * @param keyLength the length, in bytes, of the secret key to generate.
   *
   * @return the secret key as a binary-encoded string of bytes.
   */
  kem.decrypt = function(privateKey, encapsulation, keyLength) {
    // decrypt the encapsulation and generate the secret key
    var r = privateKey.decrypt(encapsulation, 'NONE');
    return kdf.generate(r, keyLength);
  };

  return kem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.log" id="apidoc.module.node-forge.log">module node-forge.log</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.log.addLogger" id="apidoc.element.node-forge.log.addLogger">
        function <span class="apidocSignatureSpan">node-forge.log.</span>addLogger
        <span class="apidocSignatureSpan">(logger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addLogger = function (logger) {
  sLoggers.push(logger);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var f = function(logger, message) {
    forge.log.prepareStandardFull(message);
    console.log(message.standardFull);
  };
  logger = forge.log.makeLogger(f);
}
forge.log.setLevel(logger, 'debug');
forge.log.<span class="apidocCodeKeywordSpan">addLogger</span>(logger);
sConsoleLogger = logger;
} else {
// define fake console.log to avoid potential script errors on
// browsers that do not have console logging
console = {
  log: function() {}
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.debug" id="apidoc.element.node-forge.log.debug">
        function <span class="apidocSignatureSpan">node-forge.log.</span>debug
        <span class="apidocSignatureSpan">(category, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function (category, message) {
  // convert arguments to real array, remove category and message
  var args = Array.prototype.slice.call(arguments).slice(2);
  // create message object
  // Note: interpolation and standard formatting is done lazily
  var msg = {
    timestamp: new Date(),
    level: level,
    category: category,
    message: message,
    'arguments': args
<span class="apidocCodeCommentSpan">    /*standard*/
</span>    /*full*/
    /*fullMessage*/
  };
  // process this message
  forge.log.logMessage(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  */
 client.clearCookies = function() {
   client.cookies = {};
   _clearCookies(client);
 };

 if(forge.log) {
   forge.log.<span class="apidocCodeKeywordSpan">debug</span>('forge.http', 'created client', options);
 }

 return client;
};

/**
* Trims the whitespace off of the beginning and end of a string.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.error" id="apidoc.element.node-forge.log.error">
        function <span class="apidocSignatureSpan">node-forge.log.</span>error
        <span class="apidocSignatureSpan">(category, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (category, message) {
  // convert arguments to real array, remove category and message
  var args = Array.prototype.slice.call(arguments).slice(2);
  // create message object
  // Note: interpolation and standard formatting is done lazily
  var msg = {
    timestamp: new Date(),
    level: level,
    category: category,
    message: message,
    'arguments': args
<span class="apidocCodeCommentSpan">    /*standard*/
</span>    /*full*/
    /*fullMessage*/
  };
  // process this message
  forge.log.logMessage(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       client.socketPool.flashApi,
       _getStorageId(client), 'cookies');
     client.cookies = cookies || {};
   } catch(ex) {
     // no flash storage available, just silently fail
     // TODO: i assume we want this logged somewhere or
     // should it actually generate an error
     //forge.log.<span class="apidocCodeKeywordSpan">error</span>(cat, ex);
   }
 }
};

/**
* Saves persistent cookies on disk for the given client.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.info" id="apidoc.element.node-forge.log.info">
        function <span class="apidocSignatureSpan">node-forge.log.</span>info
        <span class="apidocSignatureSpan">(category, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function (category, message) {
  // convert arguments to real array, remove category and message
  var args = Array.prototype.slice.call(arguments).slice(2);
  // create message object
  // Note: interpolation and standard formatting is done lazily
  var msg = {
    timestamp: new Date(),
    level: level,
    category: category,
    message: message,
    'arguments': args
<span class="apidocCodeCommentSpan">    /*standard*/
</span>    /*full*/
    /*fullMessage*/
  };
  // process this message
  forge.log.logMessage(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.lock" id="apidoc.element.node-forge.log.lock">
        function <span class="apidocSignatureSpan">node-forge.log.</span>lock
        <span class="apidocSignatureSpan">(logger, lock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (logger, lock) {
  if(typeof lock === 'undefined' || lock) {
    logger.flags |= forge.log.LEVEL_LOCKED;
  } else {
    logger.flags &amp;= ~forge.log.LEVEL_LOCKED;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    forge.log.setLevel(
      sConsoleLogger, query['console.level'].slice(-1)[0]);
  }
  if('console.lock' in query) {
    // set with last value
    var lock = query['console.lock'].slice(-1)[0];
    if(lock == 'true') {
      forge.log.<span class="apidocCodeKeywordSpan">lock</span>(sConsoleLogger);
    }
  }
}

// provide public access to console logger
forge.log.consoleLogger = sConsoleLogger;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.logMessage" id="apidoc.element.node-forge.log.logMessage">
        function <span class="apidocSignatureSpan">node-forge.log.</span>logMessage
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logMessage = function (message) {
  var messageLevelIndex = sLevelInfo[message.level].index;
  for(var i = 0; i &lt; sLoggers.length; ++i) {
    var logger = sLoggers[i];
    if(logger.flags &amp; forge.log.NO_LEVEL_CHECK) {
      logger.f(message);
    } else {
      // get logger level
      var loggerLevelIndex = sLevelInfo[logger.level].index;
      // check level
      if(messageLevelIndex &lt;= loggerLevelIndex) {
        // message critical enough, call logger
        logger.f(logger, message);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         message: message,
         'arguments': args
         /*standard*/
         /*full*/
         /*fullMessage*/
       };
       // process this message
       forge.log.<span class="apidocCodeKeywordSpan">logMessage</span>(msg);
     };
   })(levels[i]);
 }
}

/**
* Creates a new logger with specified custom logging function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.makeLogger" id="apidoc.element.node-forge.log.makeLogger">
        function <span class="apidocSignatureSpan">node-forge.log.</span>makeLogger
        <span class="apidocSignatureSpan">(logFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeLogger = function (logFunction) {
  var logger = {
    flags: 0,
    f: logFunction
  };
  forge.log.setLevel(logger, 'none');
  return logger;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var handler = levelHandlers[message.level];
    // prepend standard message and concat args
    var args = [message.standard];
    args = args.concat(message['arguments'].slice());
    // apply to low-level console function
    handler.apply(console, args);
  };
  logger = forge.log.<span class="apidocCodeKeywordSpan">makeLogger</span>(f);
} else {
  // only appear to have basic console.log
  var f = function(logger, message) {
    forge.log.prepareStandardFull(message);
    console.log(message.standardFull);
  };
  logger = forge.log.makeLogger(f);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.prepareFull" id="apidoc.element.node-forge.log.prepareFull">
        function <span class="apidocSignatureSpan">node-forge.log.</span>prepareFull
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareFull = function (message) {
  if(!('full' in message)) {
    // copy args and insert message at the front
    var args = [message.message];
    args = args.concat([] || message['arguments']);
    // format the message
    message.full = forge.util.format.apply(this, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.prepareStandard" id="apidoc.element.node-forge.log.prepareStandard">
        function <span class="apidocSignatureSpan">node-forge.log.</span>prepareStandard
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareStandard = function (message) {
  if(!('standard' in message)) {
    message.standard =
      sLevelInfo[message.level].name +
      //' ' + +message.timestamp +
      ' [' + message.category + '] ' +
      message.message;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * store result in 'standardFull'.
 *
 * @param message a message log object.
 */
forge.log.prepareStandardFull = function(message) {
if(!('standardFull' in message)) {
  // FIXME implement 'standardFull' logging
  forge.log.<span class="apidocCodeKeywordSpan">prepareStandard</span>(message);
  message.standardFull = message.standard;
}
};

// create log level functions
if(true) {
// levels for which we want functions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.prepareStandardFull" id="apidoc.element.node-forge.log.prepareStandardFull">
        function <span class="apidocSignatureSpan">node-forge.log.</span>prepareStandardFull
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareStandardFull = function (message) {
  if(!('standardFull' in message)) {
    // FIXME implement 'standardFull' logging
    forge.log.prepareStandard(message);
    message.standardFull = message.standard;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // apply to low-level console function
    handler.apply(console, args);
  };
  logger = forge.log.makeLogger(f);
} else {
  // only appear to have basic console.log
  var f = function(logger, message) {
    forge.log.<span class="apidocCodeKeywordSpan">prepareStandardFull</span>(message);
    console.log(message.standardFull);
  };
  logger = forge.log.makeLogger(f);
}
forge.log.setLevel(logger, 'debug');
forge.log.addLogger(logger);
sConsoleLogger = logger;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.setLevel" id="apidoc.element.node-forge.log.setLevel">
        function <span class="apidocSignatureSpan">node-forge.log.</span>setLevel
        <span class="apidocSignatureSpan">(logger, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setLevel = function (logger, level) {
  var rval = false;
  if(logger &amp;&amp; !(logger.flags &amp; forge.log.LEVEL_LOCKED)) {
    for(var i = 0; i &lt; forge.log.levels.length; ++i) {
      var aValidLevel = forge.log.levels[i];
      if(level == aValidLevel) {
        // set level
        logger.level = level;
        rval = true;
        break;
      }
    }
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return a logger object.
*/
forge.log.makeLogger = function(logFunction) {
 var logger = {
   flags: 0,
   f: logFunction
 };
 forge.log.<span class="apidocCodeKeywordSpan">setLevel</span>(logger, 'none');
 return logger;
};

/**
* Sets the current log level on a logger.
*
* @param logger the target logger.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.verbose" id="apidoc.element.node-forge.log.verbose">
        function <span class="apidocSignatureSpan">node-forge.log.</span>verbose
        <span class="apidocSignatureSpan">(category, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verbose = function (category, message) {
  // convert arguments to real array, remove category and message
  var args = Array.prototype.slice.call(arguments).slice(2);
  // create message object
  // Note: interpolation and standard formatting is done lazily
  var msg = {
    timestamp: new Date(),
    level: level,
    category: category,
    message: message,
    'arguments': args
<span class="apidocCodeCommentSpan">    /*standard*/
</span>    /*full*/
    /*fullMessage*/
  };
  // process this message
  forge.log.logMessage(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// verbose level
// 0: off, 1: a little, 2: a whole lot
// Verbose debug logging is surrounded by a level check to avoid the
// performance issues with even calling the logging code regardless if it
// is actually logged.  For performance reasons this should not be set to 2
// for production use.
// ex: if(sVL &gt;= 2) forge.log.<span class="apidocCodeKeywordSpan">verbose</span>(....)
var sVL = 0;

// track tasks for debugging
var sTasks = {};
var sNextTaskId = 0;
// debug access
forge.debug.set(cat, 'tasks', sTasks);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.log.warning" id="apidoc.element.node-forge.log.warning">
        function <span class="apidocSignatureSpan">node-forge.log.</span>warning
        <span class="apidocSignatureSpan">(category, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warning = function (category, message) {
  // convert arguments to real array, remove category and message
  var args = Array.prototype.slice.call(arguments).slice(2);
  // create message object
  // Note: interpolation and standard formatting is done lazily
  var msg = {
    timestamp: new Date(),
    level: level,
    category: category,
    message: message,
    'arguments': args
<span class="apidocCodeCommentSpan">    /*standard*/
</span>    /*full*/
    /*fullMessage*/
  };
  // process this message
  forge.log.logMessage(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.log.consoleLogger" id="apidoc.module.node-forge.log.consoleLogger">module node-forge.log.consoleLogger</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.log.consoleLogger.f" id="apidoc.element.node-forge.log.consoleLogger.f">
        function <span class="apidocSignatureSpan">node-forge.log.consoleLogger.</span>f
        <span class="apidocSignatureSpan">(logger, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">f = function (logger, message) {
  forge.log.prepareStandardFull(message);
  console.log(message.standardFull);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param message message object
 */
forge.log.logMessage = function(message) {
var messageLevelIndex = sLevelInfo[message.level].index;
for(var i = 0; i &lt; sLoggers.length; ++i) {
  var logger = sLoggers[i];
  if(logger.flags &amp; forge.log.NO_LEVEL_CHECK) {
    logger.<span class="apidocCodeKeywordSpan">f</span>(message);
  } else {
    // get logger level
    var loggerLevelIndex = sLevelInfo[logger.level].index;
    // check level
    if(messageLevelIndex &lt;= loggerLevelIndex) {
      // message critical enough, call logger
      logger.f(logger, message);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.md5" id="apidoc.module.node-forge.md5">module node-forge.md5</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.md5.create" id="apidoc.element.node-forge.md5.create">
        function <span class="apidocSignatureSpan">node-forge.md5.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // MD5 state contains four 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(16);

  // message digest object
  var md = {
    algorithm: 'md5',
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

<span class="apidocCodeCommentSpan">  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
</span>  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i &lt; int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) &gt;&gt;&gt; 0, len &gt;&gt;&gt; 0];
    for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) &gt;&gt;&gt; 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] &gt;&gt;&gt; 0;
      len[0] = (len[1] / 0x100000000) &gt;&gt;&gt; 0;
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read &gt; 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate MD5 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.mgf1" id="apidoc.module.node-forge.mgf1">module node-forge.mgf1</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.mgf1.create" id="apidoc.element.node-forge.mgf1.create">
        function <span class="apidocSignatureSpan">node-forge.mgf1.</span>create
        <span class="apidocSignatureSpan">(md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (md) {
  var mgf = {
<span class="apidocCodeCommentSpan">    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
</span>    generate: function(seed, maskLen) {
      /* 2. Let T be the empty octet string. */
      var t = new forge.util.ByteBuffer();

      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */
      var len = Math.ceil(maskLen / md.digestLength);
      for(var i = 0; i &lt; len; i++) {
        /* a. Convert counter to an octet string C of length 4 octets */
        var c = new forge.util.ByteBuffer();
        c.putInt32(i);

        /* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */
        md.start();
        md.update(seed + c.getBytes());
        t.putBuffer(md.digest());
      }

      /* Output the leading maskLen octets of T as the octet string mask. */
      t.truncate(t.length() - maskLen);
      return t.getBytes();
    }
  };

  return mgf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.net" id="apidoc.module.node-forge.net">module node-forge.net</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.net.createSocket" id="apidoc.element.node-forge.net.createSocket">
        function <span class="apidocSignatureSpan">node-forge.net.</span>createSocket
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSocket = function (options) {
  var socket = null;
  if(options.flashId in net.socketPools) {
    // get related socket pool
    var sp = net.socketPools[options.flashId];
    socket = sp.createSocket(options);
  }
  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return forge.util.inflate(sp.flashApi, bytes, true);
    };
  }
}

// create and initialize sockets
for(var i = 0; i &lt; options.connections; ++i) {
  _initSocket(client, sp.<span class="apidocCodeKeywordSpan">createSocket</span>(), tlsOptions);
}

/**
 * Sends a request. A method 'abort' will be set on the request that
 * can be called to attempt to abort the request.
 *
 * @param options:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.net.createSocketPool" id="apidoc.element.node-forge.net.createSocketPool">
        function <span class="apidocSignatureSpan">node-forge.net.</span>createSocketPool
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSocketPool = function (options) {
  // set default
  options.msie = options.msie || false;

  // initialize the flash interface
  var spId = options.flashId;
  var api = document.getElementById(spId);
  api.init({marshallExceptions: !options.msie});

  // create socket pool entry
  var sp = {
    // ID of the socket pool
    id: spId,
    // flash interface
    flashApi: api,
    // map of socket ID to sockets
    sockets: {},
    // default policy port
    policyPort: options.policyPort || 0,
    // default policy URL
    policyUrl: options.policyUrl || null
  };
  net.socketPools[spId] = sp;

  // create event handler, subscribe to flash events
  if(options.msie === true) {
    sp.handler = function(e) {
      if(e.id in sp.sockets) {
        // get handler function
        var f;
        switch(e.type) {
        case 'connect':
          f = 'connected';
          break;
        case 'close':
          f = 'closed';
          break;
        case 'socketData':
          f = 'data';
          break;
        default:
          f = 'error';
          break;
        }
<span class="apidocCodeCommentSpan">        /* IE calls javascript on the thread of the external object
          that triggered the event (in this case flash) ... which will
          either run concurrently with other javascript or pre-empt any
          running javascript in the middle of its execution (BAD!) ...
          calling setTimeout() will schedule the javascript to run on
          the javascript thread and solve this EVIL problem. */
</span>        setTimeout(function() {sp.sockets[e.id][f](e);}, 0);
      }
    };
  } else {
    sp.handler = function(e) {
      if(e.id in sp.sockets) {
        // get handler function
        var f;
        switch(e.type) {
        case 'connect':
          f = 'connected';
          break;
        case 'close':
          f = 'closed';
          break;
        case 'socketData':
          f = 'data';
          break;
        default:
          f = 'error';
          break;
        }
        sp.sockets[e.id][f](e);
      }
    };
  }
  var handler = 'forge.net.socketPools[\'' + spId + '\'].handler';
  api.subscribe('connect', handler);
  api.subscribe('close', handler);
  api.subscribe('socketData', handler);
  api.subscribe('ioError', handler);
  api.subscribe('securityError', handler);

  /**
   * Destroys a socket pool. The socket pool still needs to be cleaned
   * up via net.cleanup().
   */
  sp.destroy = function() {
    delete net.socketPools[options.flashId];
    for(var id in sp.sockets) {
      sp.sockets[id].destroy();
    }
    sp.sockets = {};
    api.cleanup();
  };

  /**
   * Creates a new socket.
   *
   * @param options:
   *          connected: function(event) called when the socket connects.
   *          closed: function(event) called when the socket closes.
   *          data: function(event) called when socket data has arrived,
   *            it can be read from the socket using receive().
   *          error: function(event) called when a socket error occurs.
   */
   sp.createSocket = function(options) {
     // default to empty options
     options = options || {};

     // create flash socket
     var id = api.create();

     // create javascript socket wrapper
     var socket = {
       id: id,
       // set handlers
       connected: options.connected || function(e) {},
       closed: options.closed || function(e) {},
       data: options.data || function(e) {},
       error: options.error || function(e) {}
     };

     /**
      * Destroys this socket.
      */
     socket.destroy = function() {
       api.destroy(id);
       delete sp.sockets[id];
     };

     /**
      * Connects this socket.
      *
      * @param options:
      *          host: the host to connect to.
      *          port: the port to connect to.
      *          policyPort: the policy port to use (if non-default), 0 to
      *            use the flash default.
      *          policyUrl: the policy file URL to use (instead of port).
      */
     socket.connect = function(options) {
       // give precedence to policy URL over policy port
       // if no policy ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// update default policy port and max connections
_policyPort = options.policyPort || _policyPort;
_policyUrl = options.policyUrl || _policyUrl;
_maxConnections = options.connections || _maxConnections;

// create the flash socket pool
_sp = net.<span class="apidocCodeKeywordSpan">createSocketPool</span>({
  flashId: options.flashId,
  policyPort: _policyPort,
  policyUrl: _policyUrl,
  msie: options.msie || false
});

// create default http client
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.net.destroySocketPool" id="apidoc.element.node-forge.net.destroySocketPool">
        function <span class="apidocSignatureSpan">node-forge.net.</span>destroySocketPool
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySocketPool = function (options) {
  if(options.flashId in net.socketPools) {
    var sp = net.socketPools[options.flashId];
    sp.destroy();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pbe" id="apidoc.module.node-forge.pbe">module node-forge.pbe</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pbe.generatePkcs12Key" id="apidoc.element.node-forge.pbe.generatePkcs12Key">
        function <span class="apidocSignatureSpan">node-forge.pbe.</span>generatePkcs12Key
        <span class="apidocSignatureSpan">(password, salt, id, iter, n, md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatePkcs12Key = function (password, salt, id, iter, n, md) {
  var j, l;

  if(typeof md === 'undefined' || md === null) {
    if(!('sha1' in forge.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge.md.sha1.create();
  }

  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge.util.ByteBuffer();

<span class="apidocCodeCommentSpan">  /* Convert password to Unicode byte buffer + trailing 0-byte. */
</span>  var passBuf = new forge.util.ByteBuffer();
  if(password !== null &amp;&amp; password !== undefined) {
    for(l = 0; l &lt; password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }

  /* Length of salt and password in BYTES. */
  var p = passBuf.length();
  var s = salt.length();

  /* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */
  var D = new forge.util.ByteBuffer();
  D.fillWithByte(id, v);

  /* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */
  var Slen = v * Math.ceil(s / v);
  var S = new forge.util.ByteBuffer();
  for(l = 0; l &lt; Slen; l++) {
    S.putByte(salt.at(l % s));
  }

  /* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */
  var Plen = v * Math.ceil(p / v);
  var P = new forge.util.ByteBuffer();
  for(l = 0; l &lt; Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }

  /* 4. Set I=S||P to be the concatenation of S and P. */
  var I = S;
  I.putBuffer(P);

  /* 5. Set c=ceil(n / u). */
  var c = Math.ceil(n / u);

  /* 6. For i=1, 2, ..., c, do the following: */
  for(var i = 1; i &lt;= c; i++) {
    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */
    var buf = new forge.util.ByteBuffer();
    buf.putBytes(D.bytes());
    buf.putBytes(I.bytes());
    for(var round = 0; round &lt; iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }

    /* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */
    var B = new forge.util.ByteBuffer();
    for(l = 0; l &lt; v; l++) {
      B.putByte(buf.at(l % u));
    }

    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */
    var k = Math.ceil(s / v) + Math.ceil(p / v);
    var Inew = new forge.util.ByteBuffer();
    for(j = 0; j &lt; k; j++) {
      var chunk = new forge.util.ByteBuffer(I.getBytes(v));
      var x = 0x1ff;
      for(l = B.length() - 1; l &gt;= 0; l--) {
        x = x &gt;&gt; 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x &amp; 0xff);
      }
      Inew.putBuffer(chunk);
    }
    I = Inew;

    /* Add Ai to A. */
    result.putBuffer(buf);
  }

  result.truncate(result.length() - n);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ])
]);
  } else if(options.algorithm === '3des') {
// Do PKCS12 PBE
dkLen = 24;

var saltBytes = new forge.util.ByteBuffer(salt);
var dk = pki.pbe.<span class="apidocCodeKeywordSpan">generatePkcs12Key</span>(password, saltBytes, 1, count, dkLen);
var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
var cipher = forge.des.createEncryptionCipher(dk);
cipher.start(iv);
cipher.update(asn1.toDer(obj));
cipher.finish();
encryptedData = cipher.output.getBytes();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pbe.getCipher" id="apidoc.element.node-forge.pbe.getCipher">
        function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipher
        <span class="apidocSignatureSpan">(oid, params, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCipher = function (oid, params, password) {
  switch(oid) {
  case pki.oids['pkcs5PBES2']:
    return pki.pbe.getCipherForPBES2(oid, params, password);

  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);

  default:
    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
    error.oid = oid;
    error.supportedOids = [
      'pkcs5PBES2',
      'pbeWithSHAAnd3-KeyTripleDES-CBC',
      'pbewithSHAAnd40BitRC2-CBC'
    ];
    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
  error.errors = errors;
  throw error;
}

// get cipher
var oid = asn1.derToOid(capture.encryptionOid);
var cipher = pki.pbe.<span class="apidocCodeKeywordSpan">getCipher</span>(oid, capture.encryptionParams, password);

// get encrypted data
var encrypted = forge.util.createBuffer(capture.encryptedData);

cipher.update(encrypted);
if(cipher.finish()) {
  rval = asn1.fromDer(cipher.output);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pbe.getCipherForPBES2" id="apidoc.element.node-forge.pbe.getCipherForPBES2">
        function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipherForPBES2
        <span class="apidocSignatureSpan">(oid, params, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCipherForPBES2 = function (oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // check oids
  oid = asn1.derToOid(capture.kdfOid);
  if(oid !== pki.oids['pkcs5PBKDF2']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported key derivation function OID.');
    error.oid = oid;
    error.supportedOids = ['pkcs5PBKDF2'];
    throw error;
  }
  oid = asn1.derToOid(capture.encOid);
  if(oid !== pki.oids['aes128-CBC'] &amp;&amp;
    oid !== pki.oids['aes192-CBC'] &amp;&amp;
    oid !== pki.oids['aes256-CBC'] &amp;&amp;
    oid !== pki.oids['des-EDE3-CBC'] &amp;&amp;
    oid !== pki.oids['desCBC']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported encryption scheme OID.');
    error.oid = oid;
    error.supportedOids = [
      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
    throw error;
  }

  // set PBE params
  var salt = capture.kdfSalt;
  var count = forge.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() &lt;&lt; 3);
  var dkLen;
  var cipherFn;
  switch(pki.oids[oid]) {
  case 'aes128-CBC':
    dkLen = 16;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes192-CBC':
    dkLen = 24;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes256-CBC':
    dkLen = 32;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'des-EDE3-CBC':
    dkLen = 24;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  case 'desCBC':
    dkLen = 8;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);

  // decrypt private key using pbe with chosen PRF and AES/DES
  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);

  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */
pki.pbe.getCipher = function(oid, params, password) {
switch(oid) {
case pki.oids['pkcs5PBES2']:
  return pki.pbe.<span class="apidocCodeKeywordSpan">getCipherForPBES2</span>(oid, params, password);

case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
  return pki.pbe.getCipherForPKCS12PBE(oid, params, password);

default:
  var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pbe.getCipherForPKCS12PBE" id="apidoc.element.node-forge.pbe.getCipherForPKCS12PBE">
        function <span class="apidocSignatureSpan">node-forge.pbe.</span>getCipherForPKCS12PBE
        <span class="apidocSignatureSpan">(oid, params, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCipherForPKCS12PBE = function (oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  var salt = forge.util.createBuffer(capture.salt);
  var count = forge.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() &lt;&lt; 3);

  var dkLen, dIvLen, cipherFn;
  switch(oid) {
    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge.des.startDecrypting;
      break;

    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key, iv) {
        var cipher = forge.rc2.createDecryptionCipher(key, 40);
        cipher.start(iv, null);
        return cipher;
      };
      break;

    default:
      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
      error.oid = oid;
      throw error;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);

  return cipherFn(key, iv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pki.pbe.getCipher = function(oid, params, password) {
switch(oid) {
case pki.oids['pkcs5PBES2']:
  return pki.pbe.getCipherForPBES2(oid, params, password);

case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
  return pki.pbe.<span class="apidocCodeKeywordSpan">getCipherForPKCS12PBE</span>(oid, params, password);

default:
  var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
  error.oid = oid;
  error.supportedOids = [
    'pkcs5PBES2',
    'pbeWithSHAAnd3-KeyTripleDES-CBC',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pbe.opensslDeriveBytes" id="apidoc.element.node-forge.pbe.opensslDeriveBytes">
        function <span class="apidocSignatureSpan">node-forge.pbe.</span>opensslDeriveBytes
        <span class="apidocSignatureSpan">(password, salt, dkLen, md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">opensslDeriveBytes = function (password, salt, dkLen, md) {
  if(typeof md === 'undefined' || md === null) {
    if(!('md5' in forge.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge.md.md5.create();
  }
  if(salt === null) {
    salt = '';
  }
  var digests = [hash(md, password + salt)];
  for(var length = 16, i = 1; length &lt; dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }
  return digests.join('').substr(0, dkLen);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.create()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.<span class="apidocCodeKeywordSpan">opensslDeriveBytes</span>(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
var iv = buffer.getBytes(ivSize);

var cipher = forge.cipher.createCipher('3DES-CBC', key);
cipher.start({iv: iv});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pem" id="apidoc.module.node-forge.pem">module node-forge.pem</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pem.decode" id="apidoc.element.node-forge.pem.decode">
        function <span class="apidocSignatureSpan">node-forge.pem.</span>decode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (str) {
  var rval = [];

  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g
;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while(true) {
    match = rMessage.exec(str);
    if(!match) {
      break;
    }

    var msg = {
      type: match[1],
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    };
    rval.push(msg);

    // no headers
    if(!match[2]) {
      continue;
    }

    // parse headers
    var lines = match[2].split(rCRLF);
    var li = 0;
    while(match &amp;&amp; li &lt; lines.length) {
      // get line, trim any rhs whitespace
      var line = lines[li].replace(/\s+$/, '');

      // RFC2822 unfold any following folded lines
      for(var nl = li + 1; nl &lt; lines.length; ++nl) {
        var next = lines[nl];
        if(!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }

      // parse header
      match = line.match(rHeader);
      if(match) {
        var header = {name: match[1], values: []};
        var values = match[2].split(',');
        for(var vi = 0; vi &lt; values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        }

        // Proc-Type must be the first header
        if(!msg.procType) {
          if(header.name !== 'Proc-Type') {
            throw new Error('Invalid PEM formatted message. The first ' +
              'encapsulated header must be "Proc-Type".');
          } else if(header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
              'header must have two subfields.');
          }
          msg.procType = {version: values[0], type: values[1]};
        } else if(!msg.contentDomain &amp;&amp; header.name === 'Content-Domain') {
          // special-case Content-Domain
          msg.contentDomain = values[0] || '';
        } else if(!msg.dekInfo &amp;&amp; header.name === 'DEK-Info') {
          // special-case DEK-Info
          if(header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
              'header must have at least one subfield.');
          }
          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
        } else {
          msg.headers.push(header);
        }
      }

      ++li;
    }

    if(msg.procType === 'ENCRYPTED' &amp;&amp; !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
        'header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }

  if(rval.length === 0) {
    throw new Error('Invalid PEM formatted message.');
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptedPrivateKeyFromPem = function(pem) {
var msg = forge.pem.<span class="apidocCodeKeywordSpan">decode</span>(pem)[0];

if(msg.type !== 'ENCRYPTED PRIVATE KEY') {
  var error = new Error('Could not convert encrypted private key from PEM; ' +
    'PEM header type is "ENCRYPTED PRIVATE KEY".');
  error.headerType = msg.type;
  throw error;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pem.encode" id="apidoc.element.node-forge.pem.encode">
        function <span class="apidocSignatureSpan">node-forge.pem.</span>encode
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (msg, options) {
  options = options || {};
  var rval = '-----BEGIN ' + msg.type + '-----\r\n';

  // encode special headers
  var header;
  if(msg.procType) {
    header = {
      name: 'Proc-Type',
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header);
  }
  if(msg.contentDomain) {
    header = {name: 'Content-Domain', values: [msg.contentDomain]};
    rval += foldHeader(header);
  }
  if(msg.dekInfo) {
    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};
    if(msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header);
  }

  if(msg.headers) {
    // encode all other headers
    for(var i = 0; i &lt; msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  }

  // terminate header
  if(msg.procType) {
    rval += '\r\n';
  }

  // add body
  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';

  rval += '-----END ' + msg.type + '-----\r\n';
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
pki.encryptedPrivateKeyToPem = function(epki, maxline) {
 // convert to DER, then PEM-encode
 var msg = {
   type: 'ENCRYPTED PRIVATE KEY',
   body: asn1.toDer(epki).getBytes()
 };
 return forge.pem.<span class="apidocCodeKeywordSpan">encode</span>(msg, {maxline: maxline});
};

/**
* Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
* is not performed.
*
* @param pem the EncryptedPrivateKeyInfo in PEM-format.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pkcs1" id="apidoc.module.node-forge.pkcs1">module node-forge.pkcs1</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pkcs1.decode_rsa_oaep" id="apidoc.element.node-forge.pkcs1.decode_rsa_oaep">
        function <span class="apidocSignatureSpan">node-forge.pkcs1.</span>decode_rsa_oaep
        <span class="apidocSignatureSpan">(key, em, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode_rsa_oaep = function (key, em, options) {
  // parse args
  var label;
  var md;
  var mgf1Md;
  // legacy args
  if(typeof options === 'string') {
    label = options;
    md = arguments[3] || undefined;
  } else if(options) {
    label = options.label || undefined;
    md = options.md || undefined;
    if(options.mgf1 &amp;&amp; options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // compute length in bytes
  var keyLength = Math.ceil(key.n.bitLength() / 8);

  if(em.length !== keyLength) {
    var error = new Error('RSAES-OAEP encoded message length is invalid.');
    error.length = em.length;
    error.expectedLength = keyLength;
    throw error;
  }

  // default OAEP to SHA-1 message digest
  if(md === undefined) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  if(keyLength &lt; 2 * md.digestLength + 2) {
    throw new Error('RSAES-OAEP key is too short for the hash function.');
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest().getBytes();

  // split the message into its parts
  var y = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);

  var lHashPrime = db.substring(0, md.digestLength);

  // constant time check that all values match what is expected
  var error = (y !== '\x00');

  // constant time check lHash vs lHashPrime
  for(var i = 0; i &lt; md.digestLength; ++i) {
    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));
  }

  // "constant time" find the 0x1 byte separating the padding (zeros) from the
  // message
  // TODO: It must be possible to do this in a better/smarter way?
  var in_ps = 1;
  var index = md.digestLength;
  for(var j = md.digestLength; j &lt; db.length; j++) {
    var code = db.charCodeAt(j);

    var is_0 = (code &amp; 0x1) ^ 0x1;

    // non-zero if not 0 or 1 in the ps section
    var error_mask = in_ps ? 0xfffe : 0x0000;
    error |= (code &amp; error_mask);

    // latch in_ps to zero after we find 0x1
    in_ps = in_ps &amp; is_0;
    index += in_ps;
  }

  if(error || db.charCodeAt(index) !== 0x1) {
    throw new Error('Invalid RSAES-OAEP padding.');
  }

  return db.substring(index + 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var d = pki.rsa.decrypt(data, key, false, false);

if(scheme === 'RSAES-PKCS1-V1_5') {
  scheme = { decode: _decodePkcs1_v1_5 };
} else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
  scheme = {
    decode: function(d, key) {
      return forge.pkcs1.<span class="apidocCodeKeywordSpan">decode_rsa_oaep</span>(key, d, schemeOptions);
    }
  };
} else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
  scheme = { decode: function(d) { return d; } };
} else {
  throw new Error('Unsupported encryption scheme: "' + scheme + '".');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs1.encode_rsa_oaep" id="apidoc.element.node-forge.pkcs1.encode_rsa_oaep">
        function <span class="apidocSignatureSpan">node-forge.pkcs1.</span>encode_rsa_oaep
        <span class="apidocSignatureSpan">(key, message, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode_rsa_oaep = function (key, message, options) {
  // parse arguments
  var label;
  var seed;
  var md;
  var mgf1Md;
  // legacy args (label, seed, md)
  if(typeof options === 'string') {
    label = options;
    seed = arguments[3] || undefined;
    md = arguments[4] || undefined;
  } else if(options) {
    label = options.label || undefined;
    seed = options.seed || undefined;
    md = options.md || undefined;
    if(options.mgf1 &amp;&amp; options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // default OAEP to SHA-1 message digest
  if(!md) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  // compute length in bytes and check output
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if(message.length &gt; maxLength) {
    var error = new Error('RSAES-OAEP input message length is too long.');
    error.length = message.length;
    error.maxLength = maxLength;
    throw error;
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest();

  var PS = '';
  var PS_length = maxLength - message.length;
  for (var i = 0; i &lt; PS_length; i++) {
    PS += '\x00';
  }

  var DB = lHash.getBytes() + PS + '\x01' + message;

  if(!seed) {
    seed = forge.random.getBytes(md.digestLength);
  } else if(seed.length !== md.digestLength) {
    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +
      'match the digest length.');
    error.seedLength = seed.length;
    error.digestLength = md.digestLength;
    throw error;
  }

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);

  // return encoded message
  return '\x00' + maskedSeed + maskedDB;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    encode: function(m, key, pub) {
      return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
    }
  };
} else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
  scheme = {
    encode: function(m, key) {
      return forge.pkcs1.<span class="apidocCodeKeywordSpan">encode_rsa_oaep</span>(key, m, schemeOptions);
    }
  };
} else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
  scheme = { encode: function(e) { return e; } };
} else if(typeof scheme === 'string') {
  throw new Error('Unsupported encryption scheme: "' + scheme + '".');
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pkcs12" id="apidoc.module.node-forge.pkcs12">module node-forge.pkcs12</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pkcs12.generateKey" id="apidoc.element.node-forge.pkcs12.generateKey">
        function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>generateKey
        <span class="apidocSignatureSpan">(password, salt, id, iter, n, md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateKey = function (password, salt, id, iter, n, md) {
  var j, l;

  if(typeof md === 'undefined' || md === null) {
    if(!('sha1' in forge.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge.md.sha1.create();
  }

  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge.util.ByteBuffer();

<span class="apidocCodeCommentSpan">  /* Convert password to Unicode byte buffer + trailing 0-byte. */
</span>  var passBuf = new forge.util.ByteBuffer();
  if(password !== null &amp;&amp; password !== undefined) {
    for(l = 0; l &lt; password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }

  /* Length of salt and password in BYTES. */
  var p = passBuf.length();
  var s = salt.length();

  /* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */
  var D = new forge.util.ByteBuffer();
  D.fillWithByte(id, v);

  /* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */
  var Slen = v * Math.ceil(s / v);
  var S = new forge.util.ByteBuffer();
  for(l = 0; l &lt; Slen; l++) {
    S.putByte(salt.at(l % s));
  }

  /* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */
  var Plen = v * Math.ceil(p / v);
  var P = new forge.util.ByteBuffer();
  for(l = 0; l &lt; Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }

  /* 4. Set I=S||P to be the concatenation of S and P. */
  var I = S;
  I.putBuffer(P);

  /* 5. Set c=ceil(n / u). */
  var c = Math.ceil(n / u);

  /* 6. For i=1, 2, ..., c, do the following: */
  for(var i = 1; i &lt;= c; i++) {
    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */
    var buf = new forge.util.ByteBuffer();
    buf.putBytes(D.bytes());
    buf.putBytes(I.bytes());
    for(var round = 0; round &lt; iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }

    /* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */
    var B = new forge.util.ByteBuffer();
    for(l = 0; l &lt; v; l++) {
      B.putByte(buf.at(l % u));
    }

    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */
    var k = Math.ceil(s / v) + Math.ceil(p / v);
    var Inew = new forge.util.ByteBuffer();
    for(j = 0; j &lt; k; j++) {
      var chunk = new forge.util.ByteBuffer(I.getBytes(v));
      var x = 0x1ff;
      for(l = B.length() - 1; l &gt;= 0; l--) {
        x = x &gt;&gt; 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x &amp; 0xff);
      }
      Inew.putBuffer(chunk);
    }
    I = Inew;

    /* Add Ai to A. */
    result.putBuffer(buf);
  }

  result.truncate(result.length() - n);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);
}

// verify MAC (iterations default to 1)
var macSalt = new forge.util.ByteBuffer(capture.macSalt);
var macIterations = (('macIterations' in capture) ?
  parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);
var macKey = p12.<span class="apidocCodeKeywordSpan">generateKey</span>(
  password, macSalt, 3, macIterations, macKeyBytes, md);
var mac = forge.hmac.create();
mac.start(md, macKey);
mac.update(data.value);
var macValue = mac.getMac();
if(macValue.getBytes() !== capture.macDigest) {
  throw new Error('PKCS#12 MAC could not be verified. Invalid password?');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs12.pkcs12FromAsn1" id="apidoc.element.node-forge.pkcs12.pkcs12FromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>pkcs12FromAsn1
        <span class="apidocSignatureSpan">(obj, strict, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pkcs12FromAsn1 = function (obj, strict, password) {
  // handle args
  if(typeof strict === 'string') {
    password = strict;
    strict = true;
  } else if(strict === undefined) {
    strict = true;
  }

  // validate PFX and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, pfxValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#12 PFX. ' +
      'ASN.1 object is not an PKCS#12 PFX.');
    error.errors = error;
    throw error;
  }

  var pfx = {
    version: capture.version.charCodeAt(0),
    safeContents: [],

<span class="apidocCodeCommentSpan">    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
</span>    getBags: function(filter) {
      var rval = {};

      var localKeyId;
      if('localKeyId' in filter) {
        localKeyId = filter.localKeyId;
      } else if('localKeyIdHex' in filter) {
        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
      }

      // filter on bagType only
      if(localKeyId === undefined &amp;&amp; !('friendlyName' in filter) &amp;&amp;
        'bagType' in filter) {
        rval[filter.bagType] = _getBagsByAttribute(
          pfx.safeContents, null, null, filter.bagType);
      }

      if(localKeyId !== undefined) {
        rval.localKeyId = _getBagsByAttribute(
          pfx.safeContents, 'localKeyId',
          localKeyId, filter.bagType);
      }
      if('friendlyName' in filter) {
        rval.friendlyName = _getBagsByAttribute(
          pfx.safeContents, 'friendlyName',
          filter.friendlyName, filter.bagType);
      }

      return rval;
    },

    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(friendlyName, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents, 'friendlyName', friendlyName, bagType);
    },

    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(localKeyId, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents, 'localKeyId', localKeyId, bagType);
    }
  };

  if(capture.version.charCodeAt(0) !== 3) {
    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');
    error.version = capture.version.charCodeAt(0);
    throw error;
  }

  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {
    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');
    error.oid = asn1.derToOid(capture.contentType);
    throw error;
  }

  var data = capture.content.value[0];
  if(data.tagClass !== asn1.Class.UNIVERSAL ||
     data.type !== asn1.Type.OCTETSTRING) {
    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');
  }
  data = _decodePkcs7Data(data);

  // check for MAC
  if(capture.mac) {
    var md = null;
    var macKeyBytes = 0;
    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
    switch(macAlgorithm) {
    case pki.oids.sha1:
      md = forge.md.sha1.create();
      macKeyBytes = 20;
      break;
    case pki.oids.sha256:
      md = forge.md.sha256.create();
      macKeyBytes = 32;
      break;
    case pki.oids.sha384:
      md = forge.md.sha384.create();
      macKeyByte ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// decode p12 from base64
var p12Der = forge.util.decode64(p12b64);
// get p12 as ASN.1 object
var p12Asn1 = forge.asn1.fromDer(p12Der);
// decrypt p12 using the password 'password'
var p12 = forge.pkcs12.<span class="apidocCodeKeywordSpan">pkcs12FromAsn1</span>(p12Asn1, 'password');
// decrypt p12 using non-strict parsing mode (resolves some ASN.1 parse errors)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, 'password');
// decrypt p12 using literally no password (eg: Mac OS X/apple push)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1);
// decrypt p12 using an "empty" password (eg: OpenSSL with no password input)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, '');
// p12.safeContents is an array of safe contents, each of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs12.toPkcs12Asn1" id="apidoc.element.node-forge.pkcs12.toPkcs12Asn1">
        function <span class="apidocSignatureSpan">node-forge.pkcs12.</span>toPkcs12Asn1
        <span class="apidocSignatureSpan">(key, cert, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPkcs12Asn1 = function (key, cert, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';
  if(!('useMac' in options)) {
    options.useMac = true;
  }
  if(!('localKeyId' in options)) {
    options.localKeyId = null;
  }
  if(!('generateLocalKeyId' in options)) {
    options.generateLocalKeyId = true;
  }

  var localKeyId = options.localKeyId;
  var bagAttrs;
  if(localKeyId !== null) {
    localKeyId = forge.util.hexToBytes(localKeyId);
  } else if(options.generateLocalKeyId) {
    // use SHA-1 of paired cert, if available
    if(cert) {
      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
      if(typeof pairedCert === 'string') {
        pairedCert = pki.certificateFromPem(pairedCert);
      }
      var sha1 = forge.md.sha1.create();
      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
      localKeyId = sha1.digest().getBytes();
    } else {
      // FIXME: consider using SHA-1 of public key (which can be generated
      // from private key components), see: cert.generateSubjectKeyIdentifier
      // generate random bytes
      localKeyId = forge.random.getBytes(20);
    }
  }

  var attrs = [];
  if(localKeyId !== null) {
    attrs.push(
      // localKeyID
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // attrId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.localKeyId).getBytes()),
        // attrValues
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
            localKeyId)
        ])
      ]));
  }
  if('friendlyName' in options) {
    attrs.push(
      // friendlyName
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // attrId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.friendlyName).getBytes()),
        // attrValues
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,
            options.friendlyName)
        ])
      ]));
  }

  if(attrs.length &gt; 0) {
    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
  }

  // collect contents for AuthenticatedSafe
  var contents = [];

  // create safe bag(s) for certificate chain
  var chain = [];
  if(cert !== null) {
    if(forge.util.isArray(cert)) {
      chain = cert;
    } else {
      chain = [cert];
    }
  }

  var certSafeBags = [];
  for(var i = 0; i &lt; chain.length; ++i) {
    // convert cert from PEM as necessary
    cert = chain[i];
    if(typeof cert === 'string') {
      cert = pki.certificateFromPem(cert);
    }

    // SafeBag
    var certBagAttrs = (i === 0) ? bagAttrs : undefined;
    var certAsn1 = pki.certificateToAsn1(cert);
    var certSafeBag =
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // bagId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.certBag).getBytes()),
        // bagValue
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // CertBag
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // certId
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),
            // certValue (x509Certificate)
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
                asn1.toDer(certAsn1).getBytes())
            ])])]),
        // bagAttributes (OPTIONAL)
        certBagAttrs
      ]);
    certSafeBags.push(certSafeBag);
  }

  if(certSafeBags.length &gt; 0) {
    // SafeContents
    var certSafeContents = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// representation of the key
if(bag.key === null) {
var keyAsn1 = bag.asn1;
// can now convert back to DER/PEM/etc for export
}

// generate a p12 using AES (default)
var p12Asn1 = forge.pkcs12.<span class="apidocCodeKeywordSpan">toPkcs12Asn1</span>(
privateKey, certificateChain, 'password');

// generate a p12 that can be imported by Chrome/Firefox/iOS
// (requires the use of Triple DES instead of AES)
var p12Asn1 = forge.pkcs12.toPkcs12Asn1(
privateKey, certificateChain, 'password',
{algorithm: '3des'});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pkcs5" id="apidoc.module.node-forge.pkcs5">module node-forge.pkcs5</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pkcs5.pbkdf2" id="apidoc.element.node-forge.pkcs5.pbkdf2">
        function <span class="apidocSignatureSpan">node-forge.pkcs5.</span>pbkdf2
        <span class="apidocSignatureSpan">( p, s, c, dkLen, md, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2 = function ( p, s, c, dkLen, md, callback) {
  if(typeof md === 'function') {
    callback = md;
    md = null;
  }

  // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed
  if(forge.util.isNodejs &amp;&amp; !forge.options.usePureJavaScript &amp;&amp;
    crypto.pbkdf2 &amp;&amp; (md === null || typeof md !== 'object') &amp;&amp;
    (crypto.pbkdf2Sync.length &gt; 4 || (!md || md === 'sha1'))) {
    if(typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }
    p = new Buffer(p, 'binary');
    s = new Buffer(s, 'binary');
    if(!callback) {
      if(crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }
      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }
    if(crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
        if(err) {
          return callback(err);
        }
        callback(null, key.toString('binary'));
      });
    }
    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
      if(err) {
        return callback(err);
      }
      callback(null, key.toString('binary'));
    });
  }

  if(typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }
  if(typeof md === 'string') {
    if(!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }
    md = forge.md[md].create();
  }

  var hLen = md.digestLength;

<span class="apidocCodeCommentSpan">  /* 1. If dkLen &gt; (2^32 - 1) * hLen, output "derived key too long" and
    stop. */
</span>  if(dkLen &gt; (0xFFFFFFFF * hLen)) {
    var err = new Error('Derived key is too long.');
    if(callback) {
      return callback(err);
    }
    throw err;
  }

  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;

  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */
  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1;

  // sync version
  if(!callback) {
    for(var i = 1; i &lt;= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j &lt;= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        // F(p, s, c, i)
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len&lt;0..r-1&gt; */
      dk += (i &lt; len) ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */
    return dk;
  }

  // async version
  var i = 1, j;
  function outer() {
    if(i &gt; len) {
      // done
      return callback(null, dk);
    }

    // PRF(P, S || INT(i)) (first iteration)
    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();

    // PRF(P, u_{c-1}) (other iterations)
    j = 2;
    inner();
  } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// generate a random key and IV
// Note: a key size of 16 bytes will use AES-128, 24 =&gt; AES-192, 32 =&gt; AES-256
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(16);

/* alternatively, generate a password-based 16-byte key
var salt = forge.random.getBytesSync(128);
var key = forge.pkcs5.<span class="apidocCodeKeywordSpan">pbkdf2</span>('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pkcs7" id="apidoc.module.node-forge.pkcs7">module node-forge.pkcs7</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.createEncryptedData" id="apidoc.element.node-forge.pkcs7.createEncryptedData">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createEncryptedData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEncryptedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

<span class="apidocCodeCommentSpan">    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
</span>    fromAsn1: function(obj) {
      // Validate EncryptedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },

    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(key) {
      if(key !== undefined) {
        msg.encryptedContent.key = key;
      }
      _decryptContent(msg);
    }
  };
  return msg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  switch(contentType) {
case forge.pki.oids.envelopedData:
  msg = p7.createEnvelopedData();
  break;

case forge.pki.oids.encryptedData:
  msg = p7.<span class="apidocCodeKeywordSpan">createEncryptedData</span>();
  break;

case forge.pki.oids.signedData:
  msg = p7.createSignedData();
  break;

default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.createEnvelopedData" id="apidoc.element.node-forge.pkcs7.createEnvelopedData">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createEnvelopedData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEnvelopedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

<span class="apidocCodeCommentSpan">    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
</span>    fromAsn1: function(obj) {
      // validate EnvelopedData content block and capture data
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },

    toAsn1: function() {
      // ContentInfo
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // ContentType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(msg.type).getBytes()),
        // [0] EnvelopedData
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // Version
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
              asn1.integerToDer(msg.version).getBytes()),
            // RecipientInfos
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,
              _recipientsToAsn1(msg.recipients)),
            // EncryptedContentInfo
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true,
              _encryptedContentToAsn1(msg.encryptedContent))
          ])
        ])
      ]);
    },

    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(cert) {
      var sAttr = cert.issuer.attributes;

      for(var i = 0; i &lt; msg.recipients.length; ++i) {
        var r = msg.recipients[i];
        var rAttr = r.issuer;

        if(r.serialNumber !== cert.serialNumber) {
          continue;
        }

        if(rAttr.length !== sAttr.length) {
          continue;
        }

        var match = true;
        for(var j = 0; j &lt; sAttr.length; ++j) {
          if(rAttr[j].type !== sAttr[j].type ||
            rAttr[j].value !== sAttr[j].value) {
            match = false;
            break;
          }
        }

        if(match) {
          return r;
        }
      }

      return null;
    },

    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(recipient, privKey) {
      if(msg.encryptedContent.key === undefined &amp;&amp; recipient !== undefined &amp;&amp;
        privKey !== undefined) {
        switch(recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
          case forge.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge.util.createBuffer(key);
            break;

          default:
            throw new Error('Unsupported asymmetric cipher, ' +
              'OID ' + recipient.encryptedContent.algorithm);
        }
      }

      _decryptContent(msg);
    },

    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },

    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cip ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// find a recipient by the issuer of a certificate
var recipient = p7.findRecipient(cert);

// decrypt
p7.decrypt(p7.recipients[0], privateKey);

// create a p7 enveloped message
var p7 = forge.pkcs7.<span class="apidocCodeKeywordSpan">createEnvelopedData</span>();

// add a recipient
var cert = forge.pki.certificateFromPem(certPem);
p7.addRecipient(cert);

// set content
p7.content = forge.util.createBuffer('Hello');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.createSignedData" id="apidoc.element.node-forge.pkcs7.createSignedData">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>createSignedData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSignedData = function () {
  var msg = null;
  msg = {
    type: forge.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],

    fromAsn1: function(obj) {
      // validate SignedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];

      var certs = msg.rawCapture.certificates.value;
      for(var i = 0; i &lt; certs.length; ++i) {
        msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
      }

      // TODO: parse crls
    },

    toAsn1: function() {
      // degenerate case with no content
      if(!msg.contentInfo) {
        msg.sign();
      }

      var certs = [];
      for(var i = 0; i &lt; msg.certificates.length; ++i) {
        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
      }

      var crls = [];
      // TODO: implement CRLs

      // [0] SignedData
      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Version
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
            asn1.integerToDer(msg.version).getBytes()),
          // DigestAlgorithmIdentifiers
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.SET, true,
            msg.digestAlgorithmIdentifiers),
          // ContentInfo
          msg.contentInfo
        ])
      ]);
      if(certs.length &gt; 0) {
        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
      }
      if(crls.length &gt; 0) {
        // [1] IMPLICIT CertificateRevocationLists OPTIONAL
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
      }
      // SignerInfos
      signedData.value[0].value.push(
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,
          msg.signerInfos));

      // ContentInfo
      return asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // ContentType
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(msg.type).getBytes()),
          // [0] SignedData
          signedData
        ]);
    },

    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the messa ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
p7.encrypt();

// convert message to PEM
var pem = forge.pkcs7.messageToPem(p7);

// create a degenerate PKCS#7 certificate container
// (CRLs not currently supported, only certificates)
var p7 = forge.pkcs7.<span class="apidocCodeKeywordSpan">createSignedData</span>();
p7.addCertificate(certOrCertPem1);
p7.addCertificate(certOrCertPem2);
var pem = forge.pkcs7.messageToPem(p7);

// create PKCS#7 signed data with authenticatedAttributes
// attributes include: PKCS#9 content-type, message-digest, and signing-time
var p7 = forge.pkcs7.createSignedData();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.messageFromAsn1" id="apidoc.element.node-forge.pkcs7.messageFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageFromAsn1
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">messageFromAsn1 = function (obj) {
  // validate root level ContentInfo and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 message. ' +
      'ASN.1 object is not an PKCS#7 ContentInfo.');
    error.errors = errors;
    throw error;
  }

  var contentType = asn1.derToOid(capture.contentType);
  var msg;

  switch(contentType) {
    case forge.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;

    case forge.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;

    case forge.pki.oids.signedData:
      msg = p7.createSignedData();
      break;

    default:
      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' +
        contentType + ' is not (yet) supported.');
  }

  msg.fromAsn1(capture.content.value[0]);
  return msg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
   throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
 }

 // convert DER to ASN.1 object
 var obj = asn1.fromDer(msg.body);

 return p7.<span class="apidocCodeKeywordSpan">messageFromAsn1</span>(obj);
};

/**
* Converts a PKCS#7 message to PEM format.
*
* @param msg The PKCS#7 message object
* @param maxline The maximum characters per line, defaults to 64.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.messageFromPem" id="apidoc.element.node-forge.pkcs7.messageFromPem">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageFromPem
        <span class="apidocSignatureSpan">(pem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">messageFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PKCS7') {
    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' +
      'header type is not "PKCS#7".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return p7.messageFromAsn1(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Provides cryptographically protected messages from [PKCS#7][].

__Examples__

```js
// convert a message from PEM
var p7 = forge.pkcs7.<span class="apidocCodeKeywordSpan">messageFromPem</span>(pem);
// look at p7.recipients

// find a recipient by the issuer of a certificate
var recipient = p7.findRecipient(cert);

// decrypt
p7.decrypt(p7.recipients[0], privateKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pkcs7.messageToPem" id="apidoc.element.node-forge.pkcs7.messageToPem">
        function <span class="apidocSignatureSpan">node-forge.pkcs7.</span>messageToPem
        <span class="apidocSignatureSpan">(msg, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">messageToPem = function (msg, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var pemObj = {
    type: 'PKCS7',
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge.pem.encode(pemObj, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// set content
p7.content = forge.util.createBuffer('Hello');

// encrypt
p7.encrypt();

// convert message to PEM
var pem = forge.pkcs7.<span class="apidocCodeKeywordSpan">messageToPem</span>(p7);

// create a degenerate PKCS#7 certificate container
// (CRLs not currently supported, only certificates)
var p7 = forge.pkcs7.createSignedData();
p7.addCertificate(certOrCertPem1);
p7.addCertificate(certOrCertPem2);
var pem = forge.pkcs7.messageToPem(p7);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pki" id="apidoc.module.node-forge.pki">module node-forge.pki</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pki.CRIAttributesAsArray" id="apidoc.element.node-forge.pki.CRIAttributesAsArray">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>CRIAttributesAsArray
        <span class="apidocSignatureSpan">(attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CRIAttributesAsArray = function (attributes) {
  var rval = [];

  // each value in 'attributes' in is a SEQUENCE with an OID and a SET
  for(var si = 0; si &lt; attributes.length; ++si) {
    // get the attribute sequence
    var seq = attributes[si];

    // each value in the SEQUENCE containing first a type (an OID) and
    // second a set of values (defined by the OID)
    var type = asn1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for(var vi = 0; vi &lt; values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      // parse extensions
      if(obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for(var ei = 0; ei &lt; obj.value.length; ++ei) {
          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 csr.getAttribute = function(sn) {
   return _getAttribute(csr, sn);
 };
 csr.addAttribute = function(attr) {
   _fillMissingFields([attr]);
   csr.attributes.push(attr);
 };
 csr.attributes = pki.<span class="apidocCodeKeywordSpan">CRIAttributesAsArray</span>(
   capture.certificationRequestInfoAttributes || []);

 return csr;
};

/**
* Creates an empty certification request (a CSR or certificate signing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.RDNAttributesAsArray" id="apidoc.element.node-forge.pki.RDNAttributesAsArray">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>RDNAttributesAsArray
        <span class="apidocSignatureSpan">(rdn, md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RDNAttributesAsArray = function (rdn, md) {
  var rval = [];

  // each value in 'rdn' in is a SET of RelativeDistinguishedName
  var set, attr, obj;
  for(var si = 0; si &lt; rdn.value.length; ++si) {
    // get the RelativeDistinguishedName set
    set = rdn.value[si];

    // each value in the SET is an AttributeTypeAndValue sequence
    // containing first a type (an OID) and second a value (defined by
    // the OID)
    for(var i = 0; i &lt; set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if(md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'ASN.1 object is not an PKCS#7 RecipientInfo.');
  error.errors = errors;
  throw error;
}

return {
  version: capture.version.charCodeAt(0),
  issuer: forge.pki.<span class="apidocCodeKeywordSpan">RDNAttributesAsArray</span>(capture.issuer),
  serialNumber: forge.util.createBuffer(capture.serial).toHex(),
  encryptedContent: {
    algorithm: asn1.derToOid(capture.encAlgorithm),
    parameter: capture.encParameter.value,
    content: capture.encKey
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateExtensionFromAsn1" id="apidoc.element.node-forge.pki.certificateExtensionFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionFromAsn1
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateExtensionFromAsn1 = function (ext) {
  // an extension has:
  // [0] extnID      OBJECT IDENTIFIER
  // [1] critical    BOOLEAN DEFAULT FALSE
  // [2] extnValue   OCTET STRING
  var e = {};
  e.id = asn1.derToOid(ext.value[0].value);
  e.critical = false;
  if(ext.value[1].type === asn1.Type.BOOLEAN) {
    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  // if the oid is known, get its name
  if(e.id in oids) {
    e.name = oids[e.id];

    // handle key usage
    if(e.name === 'keyUsage') {
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      var b3 = 0x00;
      if(ev.value.length &gt; 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length &gt; 2 ? ev.value.charCodeAt(2) : 0;
      }
      // set flags
      e.digitalSignature = (b2 &amp; 0x80) === 0x80;
      e.nonRepudiation = (b2 &amp; 0x40) === 0x40;
      e.keyEncipherment = (b2 &amp; 0x20) === 0x20;
      e.dataEncipherment = (b2 &amp; 0x10) === 0x10;
      e.keyAgreement = (b2 &amp; 0x08) === 0x08;
      e.keyCertSign = (b2 &amp; 0x04) === 0x04;
      e.cRLSign = (b2 &amp; 0x02) === 0x02;
      e.encipherOnly = (b2 &amp; 0x01) === 0x01;
      e.decipherOnly = (b3 &amp; 0x80) === 0x80;
    } else if(e.name === 'basicConstraints') {
      // handle basic constraints
      // get value as SEQUENCE
      var ev = asn1.fromDer(e.value);
      // get cA BOOLEAN flag (defaults to false)
      if(ev.value.length &gt; 0 &amp;&amp; ev.value[0].type === asn1.Type.BOOLEAN) {
        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
      } else {
        e.cA = false;
      }
      // get path length constraint
      var value = null;
      if(ev.value.length &gt; 0 &amp;&amp; ev.value[0].type === asn1.Type.INTEGER) {
        value = ev.value[0].value;
      } else if(ev.value.length &gt; 1) {
        value = ev.value[1].value;
      }
      if(value !== null) {
        e.pathLenConstraint = asn1.derToInteger(value);
      }
    } else if(e.name === 'extKeyUsage') {
      // handle extKeyUsage
      // value is a SEQUENCE of OIDs
      var ev = asn1.fromDer(e.value);
      for(var vi = 0; vi &lt; ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        if(oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if(e.name === 'nsCertType') {
      // handle nsCertType
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      if(ev.value.length &gt; 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
      }
      // set flags
      e.client = (b2 &amp; 0x80) === 0x80;
      e.server = (b2 &amp; 0x40) === 0x40;
      e.email = (b2 &amp; 0x20) === 0x20;
      e.objsign = (b2 &amp; 0x10) === 0x10;
      e.reserved = (b2 &amp; 0x08) === 0x08;
      e.sslCA = (b2 &amp; 0x04) === 0x04;
      e.emailCA = (b2 &amp; 0x02) === 0x02;
      e.objCA = (b2 &amp; 0x01) === 0x01;
    } else if(
      e.name === 'subjectAltName' ||
      e.name === 'issuerAltName') {
      // handle subjectAltName/issuerAltName
      e.altNames = [];

      // ev is a SYNTAX SEQUENCE
      var gn;
      var ev = asn1.fromDer(e.value);
      for(var n = 0; n &lt; ev.value.length; ++n) {
        // get GeneralName
        gn = ev.value[n];

        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);

        // Note: Support for types 1,2,6,7,8
        switch(gn.type) {
        // rfc822Name
        case 1:
        // dNSName
        case 2:
        // uniformResourceIdentifier (URI)
        case 6:
          break;
        // IPAddress
        case 7:
          // convert to IPv4/IPv6 string representation
          altName.ip = forge.util.bytesToIP(gn.value);
          break;
        // registeredID
        case 8:
          altName.o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        obj.shortName = _shortNames[obj.name];
      }
    }
    // parse extensions
    if(obj.type === oids.extensionRequest) {
      obj.extensions = [];
      for(var ei = 0; ei &lt; obj.value.length; ++ei) {
        obj.extensions.push(pki.<span class="apidocCodeKeywordSpan">certificateExtensionFromAsn1</span>(obj.value[ei]));
      }
    }
    rval.push(obj);
  }
}

return rval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateExtensionToAsn1" id="apidoc.element.node-forge.pki.certificateExtensionToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionToAsn1
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateExtensionToAsn1 = function (ext) {
  // create a sequence for each extension
  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // extnID (OID)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false,
    asn1.oidToDer(ext.id).getBytes()));

  // critical defaults to false
  if(ext.critical) {
    // critical BOOLEAN DEFAULT FALSE
    extseq.value.push(asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
      String.fromCharCode(0xFF)));
  }

  var value = ext.value;
  if(typeof ext.value !== 'string') {
    // value is asn.1
    value = asn1.toDer(value).getBytes();
  }

  // extnValue (OCTET STRING)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));

  return extseq;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert extensions to value
if(attr.type === oids.extensionRequest) {
  attr.valueConstructed = true;
  attr.valueTagClass = asn1.Type.SEQUENCE;
  if(!attr.value &amp;&amp; attr.extensions) {
    attr.value = [];
    for(var ei = 0; ei &lt; attr.extensions.length; ++ei) {
      attr.value.push(pki.<span class="apidocCodeKeywordSpan">certificateExtensionToAsn1</span>(
        _fillMissingExtensionFields(attr.extensions[ei])));
    }
  }
}

if(typeof attr.value === 'undefined') {
  var error = new Error('Attribute value not specified.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateExtensionsFromAsn1" id="apidoc.element.node-forge.pki.certificateExtensionsFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionsFromAsn1
        <span class="apidocSignatureSpan">(exts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateExtensionsFromAsn1 = function (exts) {
  var rval = [];
  for(var i = 0; i &lt; exts.value.length; ++i) {
    // get extension sequence
    var extseq = exts.value[i];
    for(var ei = 0; ei &lt; extseq.value.length; ++ei) {
      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(capture.certSubjectUniqueId) {
  cert.subject.uniqueId = capture.certSubjectUniqueId;
}
cert.subject.hash = smd.digest().toHex();

// handle extensions
if(capture.certExtensions) {
  cert.extensions = pki.<span class="apidocCodeKeywordSpan">certificateExtensionsFromAsn1</span>(capture.certExtensions);
} else {
  cert.extensions = [];
}

// convert RSA public key from ASN.1
cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateExtensionsToAsn1" id="apidoc.element.node-forge.pki.certificateExtensionsToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateExtensionsToAsn1
        <span class="apidocSignatureSpan">(exts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateExtensionsToAsn1 = function (exts) {
  // create top-level extension container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);

  // create extension sequence (stores a sequence for each extension)
  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  rval.value.push(seq);

  for(var i = 0; i &lt; exts.length; ++i) {
    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       )
     ])
   );
 }

 if(cert.extensions.length &gt; 0) {
   // extensions (optional)
   tbs.value.push(pki.<span class="apidocCodeKeywordSpan">certificateExtensionsToAsn1</span>(cert.extensions));
 }

 return tbs;
};

/**
* Gets the ASN.1 CertificationRequestInfo part of a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateFromAsn1" id="apidoc.element.node-forge.pki.certificateFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateFromAsn1
        <span class="apidocSignatureSpan">(obj, computeHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateFromAsn1 = function (obj, computeHash) {
  // validate certificate and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
    var error = new Error('Cannot read X.509 certificate. ' +
      'ASN.1 object is not an X509v3 Certificate.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certificate
  var cert = pki.createCertificate();
  cert.version = capture.certVersion ?
    capture.certVersion.charCodeAt(0) : 0;
  var serial = forge.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid, capture.certSignatureParams, true);
  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams, false);
  cert.signature = capture.certSignature;

  var validity = [];
  if(capture.certValidity1UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if(capture.certValidity2GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime));
  }
  if(capture.certValidity3UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if(capture.certValidity4GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime));
  }
  if(validity.length &gt; 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; more ' +
      'than two times were provided in the certificate.');
  }
  if(validity.length &lt; 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; they ' +
      'were not provided as either UTCTime or GeneralizedTime.');
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];

  // keep TBSCertificate to preserve signature when exporting
  cert.tbsCertificate = capture.tbsCertificate;

  if(computeHash) {
    // check signature OID for supported signature types
    cert.md = null;
    if(cert.signatureOid in oids) {
      var oid = oids[cert.signatureOid];
      switch(oid) {
      case 'sha1WithRSAEncryption':
        cert.md = forge.md.sha1.create();
        break;
      case 'md5WithRSAEncryption':
        cert.md = forge.md.md5.create();
        break;
      case 'sha256WithRSAEncryption':
        cert.md = forge.md.sha256.create();
        break;
      case 'sha512WithRSAEncryption':
        cert.md = forge.md.sha512.create();
        break;
      case 'RSASSA-PSS':
        cert.md = forge.md.sha256.create();
        break;
      }
    }
    if(cert.md === null) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown signature OID.');
      error.signatureOid = cert.signatureOid;
      throw error;
    }

    // produce DER formatted TBSCertificate and digest it
    var bytes = asn1.toDer(cert.tbsCertificate);
    cert.md.update(bytes.getBytes());
  }

  // handle issuer, build issuer message digest
  var imd = forge.md.sha1.create();
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
  if(capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a Forge certificate to PEM
var pem = pki.certificateToPem(cert);

// convert a Forge certificate from PEM
var cert = pki.certificateFromPem(pem);

// convert an ASN.1 X.509x3 object to a Forge certificate
var cert = pki.<span class="apidocCodeKeywordSpan">certificateFromAsn1</span>(obj);

// convert a Forge certificate to an ASN.1 X.509v3 object
var asn1Cert = pki.certificateToAsn1(cert);
```

&lt;a name="pkcs5" /&gt;
### PKCS#5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateFromPem" id="apidoc.element.node-forge.pki.certificateFromPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateFromPem
        <span class="apidocSignatureSpan">(pem, computeHash, strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateFromPem = function (pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE' &amp;&amp;
    msg.type !== 'X509 CERTIFICATE' &amp;&amp;
    msg.type !== 'TRUSTED CERTIFICATE') {
    var error = new Error('Could not convert certificate from PEM; PEM header type ' +
      'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certificate from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificateFromAsn1(obj, computeHash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// self-sign certificate
cert.sign(keys.privateKey);

// convert a Forge certificate to PEM
var pem = pki.certificateToPem(cert);

// convert a Forge certificate from PEM
var cert = pki.<span class="apidocCodeKeywordSpan">certificateFromPem</span>(pem);

// convert an ASN.1 X.509x3 object to a Forge certificate
var cert = pki.certificateFromAsn1(obj);

// convert a Forge certificate to an ASN.1 X.509v3 object
var asn1Cert = pki.certificateToAsn1(cert);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateToAsn1" id="apidoc.element.node-forge.pki.certificateToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateToAsn1
        <span class="apidocSignatureSpan">(cert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateToAsn1 = function (cert) {
  // prefer cached TBSCertificate over generating one
  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + cert.signature)
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a Forge certificate from PEM
var cert = pki.certificateFromPem(pem);

// convert an ASN.1 X.509x3 object to a Forge certificate
var cert = pki.certificateFromAsn1(obj);

// convert a Forge certificate to an ASN.1 X.509v3 object
var asn1Cert = pki.<span class="apidocCodeKeywordSpan">certificateToAsn1</span>(cert);
```

&lt;a name="pkcs5" /&gt;
### PKCS#5

Provides the password-based key-derivation function from [PKCS#5][].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificateToPem" id="apidoc.element.node-forge.pki.certificateToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificateToPem
        <span class="apidocSignatureSpan">(cert, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificateToPem = function (cert, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE',
    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}]);
cert.setExtensions(extensions);
*/
// self-sign certificate
cert.sign(keys.privateKey);

// convert a Forge certificate to PEM
var pem = pki.<span class="apidocCodeKeywordSpan">certificateToPem</span>(cert);

// convert a Forge certificate from PEM
var cert = pki.certificateFromPem(pem);

// convert an ASN.1 X.509x3 object to a Forge certificate
var cert = pki.certificateFromAsn1(obj);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificationRequestFromAsn1" id="apidoc.element.node-forge.pki.certificationRequestFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestFromAsn1
        <span class="apidocSignatureSpan">(obj, computeHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificationRequestFromAsn1 = function (obj, computeHash) {
  // validate certification request and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#10 certificate request. ' +
      'ASN.1 object is not a PKCS#10 CertificationRequest.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certification request
  var csr = pki.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid, capture.csrSignatureParams, true);
  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
  csr.signature = capture.csrSignature;

  // keep CertificationRequestInfo to preserve signature when exporting
  csr.certificationRequestInfo = capture.certificationRequestInfo;

  if(computeHash) {
    // check signature OID for supported signature types
    csr.md = null;
    if(csr.signatureOid in oids) {
      var oid = oids[csr.signatureOid];
      switch(oid) {
      case 'sha1WithRSAEncryption':
        csr.md = forge.md.sha1.create();
        break;
      case 'md5WithRSAEncryption':
        csr.md = forge.md.md5.create();
        break;
      case 'sha256WithRSAEncryption':
        csr.md = forge.md.sha256.create();
        break;
      case 'sha512WithRSAEncryption':
        csr.md = forge.md.sha512.create();
        break;
      case 'RSASSA-PSS':
        csr.md = forge.md.sha256.create();
        break;
      }
    }
    if(csr.md === null) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown signature OID.');
      error.signatureOid = csr.signatureOid;
      throw error;
    }

    // produce DER formatted CertificationRequestInfo and digest it
    var bytes = asn1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes.getBytes());
  }

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject, smd);
  csr.subject.hash = smd.digest().toHex();

  // convert RSA public key from ASN.1
  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  // convert attributes from ASN.1
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []);

  return csr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   throw new Error('Could not convert certification request from PEM; ' +
     'PEM is encrypted.');
 }

 // convert DER to ASN.1 object
 var obj = asn1.fromDer(msg.body, strict);

 return pki.<span class="apidocCodeKeywordSpan">certificationRequestFromAsn1</span>(obj, computeHash);
};

/**
* Converts a PKCS#10 certification request (CSR) to PEM format.
*
* @param csr the certification request.
* @param maxline the maximum characters per line, defaults to 64.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificationRequestFromPem" id="apidoc.element.node-forge.pki.certificationRequestFromPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestFromPem
        <span class="apidocSignatureSpan">(pem, computeHash, strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificationRequestFromPem = function (pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE REQUEST') {
    var error = new Error('Could not convert certification request from PEM; ' +
      'PEM header type is not "CERTIFICATE REQUEST".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certification request from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificationRequestFromAsn1(obj, computeHash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// verify certification request
var verified = csr.verify();

// convert certification request to PEM-format
var pem = forge.pki.certificationRequestToPem(csr);

// convert a Forge certification request from PEM-format
var csr = forge.pki.<span class="apidocCodeKeywordSpan">certificationRequestFromPem</span>(pem);

// get an attribute
csr.getAttribute({name: 'challengePassword'});

// get extensions array
csr.getAttribute({name: 'extensionRequest'}).extensions;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificationRequestToAsn1" id="apidoc.element.node-forge.pki.certificationRequestToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestToAsn1
        <span class="apidocSignatureSpan">(csr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificationRequestToAsn1 = function (csr) {
  // prefer cached CertificationRequestInfo over generating one
  var cri = csr.certificationRequestInfo ||
    pki.getCertificationRequestInfo(csr);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(csr.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + csr.signature)
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @return the PEM-formatted certification request.
*/
pki.certificationRequestToPem = function(csr, maxline) {
 // convert to ASN.1, then DER, then PEM-encode
 var msg = {
   type: 'CERTIFICATE REQUEST',
   body: asn1.toDer(pki.<span class="apidocCodeKeywordSpan">certificationRequestToAsn1</span>(csr)).getBytes()
 };
 return forge.pem.encode(msg, {maxline: maxline});
};

/**
* Creates an empty X.509v3 RSA certificate.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.certificationRequestToPem" id="apidoc.element.node-forge.pki.certificationRequestToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>certificationRequestToPem
        <span class="apidocSignatureSpan">(csr, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">certificationRequestToPem = function (csr, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE REQUEST',
    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// sign certification request
csr.sign(keys.privateKey);

// verify certification request
var verified = csr.verify();

// convert certification request to PEM-format
var pem = forge.pki.<span class="apidocCodeKeywordSpan">certificationRequestToPem</span>(csr);

// convert a Forge certification request from PEM-format
var csr = forge.pki.certificationRequestFromPem(pem);

// get an attribute
csr.getAttribute({name: 'challengePassword'});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.createCaStore" id="apidoc.element.node-forge.pki.createCaStore">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>createCaStore
        <span class="apidocSignatureSpan">(certs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCaStore = function (certs) {
  // create CA store
  var caStore = {
    // stored certificates
    certs: {}
  };

<span class="apidocCodeCommentSpan">  /**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */
</span>  caStore.getIssuer = function(cert) {
    var rval = getBySubject(cert.issuer);

    // see if there are multiple matches
    /*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/

    return rval;
  };

  /**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */
  caStore.addCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if(!caStore.hasCertificate(cert)) {  // avoid duplicate certificates in store
      if(cert.subject.hash in caStore.certs) {
        // subject hash already exists, append to array
        var tmp = caStore.certs[cert.subject.hash];
        if(!forge.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert);
        caStore.certs[cert.subject.hash] = tmp;
      } else {
        caStore.certs[cert.subject.hash] = cert;
      }
    }
  };

  /**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */
  caStore.hasCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    var match = getBySubject(cert.subject);
    if(!match) {
      return false;
    }
    if(!forge.util.isArray(match)) {
      match = [match];
    }
    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i &lt; match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        return true;
      }
    }
    return false;
  };

  /**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */
  caStore.listAllCertificates = function() {
    var certList = [];

    for(var hash in caStore.certs) {
      if(caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if(!forge.util.isArray(value)) {
          certList.push(value);
        } else {
          for(var i = 0; i &lt; value.length; ++i) {
            certList.push(value[i]);
          }
        }
      }
    }

    return certList;
  };

  /**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */
  caStore.removeCertificate = function(cert) {
    var result;

    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }
    ensureSubjectHasHash(cert.subject);
    if(!caStore.hasCertificate(cert)) {
      return null;
    }

    var match = getBySubject(cert.subject);

    if(!forge.util.isArray(match)) {
      result = caStore.certs[cert.subject.hash];
      delete caStore.certs[cert.subject.hash];
      return result;
    }

    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBy ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pki.getPublicKeyFingerprint(key, {
  md: forge.md.md5.create(),
  encoding: 'hex',
  delimiter: ':'
});

// creates a CA store
var caStore = pki.<span class="apidocCodeKeywordSpan">createCaStore</span>([/* PEM-encoded cert */, ...]);

// add a certificate to the CA store
caStore.addCertificate(certObjectOrPemString);

// gets the issuer (its certificate) for the given certificate
var issuerCert = caStore.getIssuer(subjectCert);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.createCertificate" id="apidoc.element.node-forge.pki.createCertificate">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>createCertificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCertificate = function () {
  var cert = {};
  cert.version = 0x02;
  cert.serialNumber = '00';
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();

  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;

  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;

  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;

<span class="apidocCodeCommentSpan">  /**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
</span>  cert.setSubject = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };

  /**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setIssuer = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };

  /**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */
  cert.setExtensions = function(exts) {
    for(var i = 0; i &lt; exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], {cert: cert});
    }
    // set new extensions
    cert.extensions = exts;
  };

  /**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */
  cert.getExtension = function(options) {
    if(typeof options === 'string') {
      options = {name: options};
    }

    var rval = null;
    var ext;
    for(var i = 0; rval === null &amp;&amp; i &lt; cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if(options.id &amp;&amp; ext.id === options.id) {
        rval = ext;
      } else if(options.name &amp;&amp; ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };

  /**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  cert.sign = function(key, md) {
    // TODO: get signature OID from private key
    cert.md = md || forge.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = cert.md.algorithm;
      throw error;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;

    // get TBSCertificate, convert to DER
    cert.tbsCertificate = pki.getTBSCertificate(cert);
    var bytes = asn1.toDer(cert.tbsCertificate);

    // digest and sign
    cert.md.update(bytes.getBytes());
    cert.signature = key.sign(cert.md);
  };

  /**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */
  cert.v ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
cert.sign(privateKey, forge.md.sha256.create());

// verifies an issued certificate using the certificates public key
var verified = issuer.verify(issued);

// generate a keypair and create an X.509v3 certificate
var keys = pki.rsa.generateKeyPair(2048);
var cert = pki.<span class="apidocCodeKeywordSpan">createCertificate</span>();
cert.publicKey = keys.publicKey;
// alternatively set public key from a csr
//cert.publicKey = csr.publicKey;
cert.serialNumber = '01';
cert.validity.notBefore = new Date();
cert.validity.notAfter = new Date();
cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.createCertificationRequest" id="apidoc.element.node-forge.pki.createCertificationRequest">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>createCertificationRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCertificationRequest = function () {
  var csr = {};
  csr.version = 0x00;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;

  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;

  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;

<span class="apidocCodeCommentSpan">  /**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */
</span>  csr.setSubject = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };

  /**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */
  csr.setAttributes = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };

  /**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  csr.sign = function(key, md) {
    // TODO: get signature OID from private key
    csr.md = md || forge.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = csr.md.algorithm;
      throw error;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;

    // get CertificationRequestInfo, convert to DER
    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
    var bytes = asn1.toDer(csr.certificationRequestInfo);

    // digest and sign
    csr.md.update(bytes.getBytes());
    csr.signature = key.sign(csr.md);
  };

  /**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in &lt;the-csr-pem-file&gt; -verify -noout -text
   *
   * @return true if verified, false if not.
   */
  csr.verify = function() {
    var rval = false;

    var md = csr.md;
    if(md === null) {
      // check signature OID for supported signature types
      if(csr.signatureOid in oids) {
        // TODO: create DRY `OID to md` function
        var oid = oids[csr.signatureOid];
        switch(oid) {
        case 'sha1WithRSAEncryption':
          md = forge.md.sha1.create();
          break;
        case 'md5WithRSAEncryption':
          md = forge.md.md5.create();
          break;
        case 'sha256WithRSAEncryption':
          md = forge.md.sha256.create();
          break;
        case 'sha512WithRSAEncryption':
          md = forge.md.sha512.create();
          break;
        case 'RSASSA-PSS':
          md = forge.md.sha256.create();
          break;
        }
      }
      if(md === null) {
        var error = new Error('Could not compute certification request digest. ' +
          'Unknown signature OID.');
        error.signatureOid = csr.signatureOid;
        throw error;
      }

      // produce DER formatted CertificationRequestInfo and digest it
      var cri = csr.certificationRequestInfo ||
        pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(cri);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      var scheme;

      switch(csr.signatureOid) {
      case oids.sha1WithRSAEncryption:
        /* use PKCS#1 v1.5 padding scheme */
        break;
      case oids['RSASSA-PSS']:
        var hash, mgf;

        /* initialize mgf */
        hash = oids[csr.signatur ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__Examples__

```js
// generate a key pair
var keys = forge.pki.rsa.generateKeyPair(1024);

// create a certification request (CSR)
var csr = forge.pki.<span class="apidocCodeKeywordSpan">createCertificationRequest</span>();
csr.publicKey = keys.publicKey;
csr.setSubject([{
name: 'commonName',
value: 'example.org'
}, {
name: 'countryName',
value: 'US'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.decryptPrivateKeyInfo" id="apidoc.element.node-forge.pki.decryptPrivateKeyInfo">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>decryptPrivateKeyInfo
        <span class="apidocSignatureSpan">(obj, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptPrivateKeyInfo = function (obj, password) {
  var rval = null;

  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read encrypted private key. ' +
      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // get cipher
  var oid = asn1.derToOid(capture.encryptionOid);
  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);

  // get encrypted data
  var encrypted = forge.util.createBuffer(capture.encryptedData);

  cipher.update(encrypted);
  if(cipher.finish()) {
    rval = asn1.fromDer(cipher.output);
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// encrypts a PrivateKeyInfo and outputs an EncryptedPrivateKeyInfo
var encryptedPrivateKeyInfo = pki.encryptPrivateKeyInfo(
  privateKeyInfo, 'password', {
    algorithm: 'aes256', // 'aes128', 'aes192', 'aes256', '3des'
  });

// decrypts an ASN.1 EncryptedPrivateKeyInfo
var privateKeyInfo = pki.<span class="apidocCodeKeywordSpan">decryptPrivateKeyInfo</span>(
  encryptedPrivateKeyInfo, 'password');

// converts an EncryptedPrivateKeyInfo to PEM
var pem = pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo);

// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format
var encryptedPrivateKeyInfo = pki.encryptedPrivateKeyFromPem(pem);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.decryptRsaPrivateKey" id="apidoc.element.node-forge.pki.decryptRsaPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>decryptRsaPrivateKey
        <span class="apidocSignatureSpan">(pem, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptRsaPrivateKey = function (pem, password) {
  var rval = null;

  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &amp;&amp;
    msg.type !== 'PRIVATE KEY' &amp;&amp;
    msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM header type ' +
      'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error.headerType = error;
    throw error;
  }

  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    var dkLen;
    var cipherFn;
    switch(msg.dekInfo.algorithm) {
    case 'DES-CBC':
      dkLen = 8;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'DES-EDE3-CBC':
      dkLen = 24;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'AES-128-CBC':
      dkLen = 16;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-192-CBC':
      dkLen = 24;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-256-CBC':
      dkLen = 32;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'RC2-40-CBC':
      dkLen = 5;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 40);
      };
      break;
    case 'RC2-64-CBC':
      dkLen = 8;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 64);
      };
      break;
    case 'RC2-128-CBC':
      dkLen = 16;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 128);
      };
      break;
    default:
      var error = new Error('Could not decrypt private key; unsupported ' +
        'encryption algorithm "' + msg.dekInfo.algorithm + '".');
      error.algorithm = msg.dekInfo.algorithm;
      throw error;
    }

    // use OpenSSL legacy key derivation
    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge.util.createBuffer(msg.body));
    if(cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }

  if(msg.type === 'ENCRYPTED PRIVATE KEY') {
    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
  } else {
    // decryption already performed above
    rval = asn1.fromDer(rval);
  }

  if(rval !== null) {
    rval = pki.privateKeyFromAsn1(rval);
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pem = pki.encryptRsaPrivateKey(privateKey, 'password');

// encrypts a Forge private key and outputs it in PEM format using OpenSSL's
// proprietary legacy format + encapsulated PEM headers (DEK-Info)
var pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});

// decrypts a PEM-formatted, encrypted private key
var privateKey = pki.<span class="apidocCodeKeywordSpan">decryptRsaPrivateKey</span>(pem, 'password');

// sets an RSA public key from a private key
var publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
```

&lt;a name="pkcs10" /&gt;
### PKCS#10
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.distinguishedNameToAsn1" id="apidoc.element.node-forge.pki.distinguishedNameToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>distinguishedNameToAsn1
        <span class="apidocSignatureSpan">(dn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinguishedNameToAsn1 = function (dn) {
  return _dnToAsn1(dn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
// Version
asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
  asn1.integerToDer(obj.version).getBytes()),
// IssuerAndSerialNumber
asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
  // Name
  forge.pki.<span class="apidocCodeKeywordSpan">distinguishedNameToAsn1</span>({attributes: obj.issuer}),
  // Serial
  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
    forge.util.hexToBytes(obj.serialNumber))
]),
// KeyEncryptionAlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
  // Algorithm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.encryptPrivateKeyInfo" id="apidoc.element.node-forge.pki.encryptPrivateKeyInfo">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptPrivateKeyInfo
        <span class="apidocSignatureSpan">(obj, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptPrivateKeyInfo = function (obj, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || 'aes128';
  options.prfAlgorithm = options.prfAlgorithm || 'sha1';

  // generate PBE params
  var salt = forge.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
    // do PBES2
    var ivLen, encOid, cipherFn;
    switch(options.algorithm) {
    case 'aes128':
      dkLen = 16;
      ivLen = 16;
      encOid = oids['aes128-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes192':
      dkLen = 24;
      ivLen = 16;
      encOid = oids['aes192-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes256':
      dkLen = 32;
      ivLen = 16;
      encOid = oids['aes256-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'des':
      dkLen = 8;
      ivLen = 8;
      encOid = oids['desCBC'];
      cipherFn = forge.des.createEncryptionCipher;
      break;
    default:
      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
      error.algorithm = options.algorithm;
      throw error;
    }

    // get PRF message digest
    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);

    // encrypt private key using pbe SHA-1 and AES/DES
    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    // get PBKDF2-params
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // keyDerivationFunc
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),
          // PBKDF2-params
          params
        ]),
        // encryptionScheme
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(encOid).getBytes()),
          // iv
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
        ])
      ])
    ]);
  } else if(options.algorithm === '3des') {
    // Do PKCS12 PBE
    dkLen = 24;

    var saltBytes = new forge.util.ByteBuffer(salt);
    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),
      // pkcs-12PbeParams
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
        // iteration count
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
          countBytes.getBytes())
      ])
    ]);
  } else {
    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
    error.algorithm = op ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
var privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);

// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM
var pem = pki.privateKeyInfoToPem(privateKeyInfo);

// encrypts a PrivateKeyInfo and outputs an EncryptedPrivateKeyInfo
var encryptedPrivateKeyInfo = pki.<span class="apidocCodeKeywordSpan">encryptPrivateKeyInfo</span>(
privateKeyInfo, 'password', {
  algorithm: 'aes256', // 'aes128', 'aes192', 'aes256', '3des'
});

// decrypts an ASN.1 EncryptedPrivateKeyInfo
var privateKeyInfo = pki.decryptPrivateKeyInfo(
encryptedPrivateKeyInfo, 'password');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.encryptRsaPrivateKey" id="apidoc.element.node-forge.pki.encryptRsaPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptRsaPrivateKey
        <span class="apidocSignatureSpan">(rsaKey, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptRsaPrivateKey = function (rsaKey, password, options) {
  // standard PKCS#8
  options = options || {};
  if(!options.legacy) {
    // encrypt PrivateKeyInfo
    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
    rval = pki.encryptPrivateKeyInfo(rval, password, options);
    return pki.encryptedPrivateKeyToPem(rval);
  }

  // legacy non-PKCS#8
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch(options.algorithm) {
  case 'aes128':
    algorithm = 'AES-128-CBC';
    dkLen = 16;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes192':
    algorithm = 'AES-192-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes256':
    algorithm = 'AES-256-CBC';
    dkLen = 32;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case '3des':
    algorithm = 'DES-EDE3-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  case 'des':
    algorithm = 'DES-CBC';
    dkLen = 8;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  default:
    var error = new Error('Could not encrypt RSA private key; unsupported ' +
      'encryption algorithm "' + options.algorithm + '".');
    error.algorithm = options.algorithm;
    throw error;
  }

  // encrypt private key using OpenSSL legacy key derivation
  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
  cipher.finish();

  var msg = {
    type: 'RSA PRIVATE KEY',
    procType: {
      version: '4',
      type: 'ENCRYPTED'
    },
    dekInfo: {
      algorithm: algorithm,
      parameters: forge.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge.pem.encode(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// converts an EncryptedPrivateKeyInfo to PEM
var pem = pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo);

// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format
var encryptedPrivateKeyInfo = pki.encryptedPrivateKeyFromPem(pem);

// wraps and encrypts a Forge private key and outputs it in PEM format
var pem = pki.<span class="apidocCodeKeywordSpan">encryptRsaPrivateKey</span>(privateKey, 'password');

// encrypts a Forge private key and outputs it in PEM format using OpenSSL's
// proprietary legacy format + encapsulated PEM headers (DEK-Info)
var pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});

// decrypts a PEM-formatted, encrypted private key
var privateKey = pki.decryptRsaPrivateKey(pem, 'password');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.encryptedPrivateKeyFromPem" id="apidoc.element.node-forge.pki.encryptedPrivateKeyFromPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptedPrivateKeyFromPem
        <span class="apidocSignatureSpan">(pem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptedPrivateKeyFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {
    var error = new Error('Could not convert encrypted private key from PEM; ' +
      'PEM header type is "ENCRYPTED PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert encrypted private key from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  return asn1.fromDer(msg.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var privateKeyInfo = pki.decryptPrivateKeyInfo(
  encryptedPrivateKeyInfo, 'password');

// converts an EncryptedPrivateKeyInfo to PEM
var pem = pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo);

// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format
var encryptedPrivateKeyInfo = pki.<span class="apidocCodeKeywordSpan">encryptedPrivateKeyFromPem</span>(pem);

// wraps and encrypts a Forge private key and outputs it in PEM format
var pem = pki.encryptRsaPrivateKey(privateKey, 'password');

// encrypts a Forge private key and outputs it in PEM format using OpenSSL's
// proprietary legacy format + encapsulated PEM headers (DEK-Info)
var pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.encryptedPrivateKeyToPem" id="apidoc.element.node-forge.pki.encryptedPrivateKeyToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>encryptedPrivateKeyToPem
        <span class="apidocSignatureSpan">(epki, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encryptedPrivateKeyToPem = function (epki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'ENCRYPTED PRIVATE KEY',
    body: asn1.toDer(epki).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

// decrypts an ASN.1 EncryptedPrivateKeyInfo
var privateKeyInfo = pki.decryptPrivateKeyInfo(
  encryptedPrivateKeyInfo, 'password');

// converts an EncryptedPrivateKeyInfo to PEM
var pem = pki.<span class="apidocCodeKeywordSpan">encryptedPrivateKeyToPem</span>(encryptedPrivateKeyInfo);

// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format
var encryptedPrivateKeyInfo = pki.encryptedPrivateKeyFromPem(pem);

// wraps and encrypts a Forge private key and outputs it in PEM format
var pem = pki.encryptRsaPrivateKey(privateKey, 'password');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.getCertificationRequestInfo" id="apidoc.element.node-forge.pki.getCertificationRequestInfo">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>getCertificationRequestInfo
        <span class="apidocSignatureSpan">(csr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCertificationRequestInfo = function (csr) {
  // CertificationRequestInfo
  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(csr.version).getBytes()),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);

  return cri;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      'Unknown message digest algorithm OID.');
    error.algorithm = csr.md.algorithm;
    throw error;
  }
  csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;

  // get CertificationRequestInfo, convert to DER
  csr.certificationRequestInfo = pki.<span class="apidocCodeKeywordSpan">getCertificationRequestInfo</span>(csr);
  var bytes = asn1.toDer(csr.certificationRequestInfo);

  // digest and sign
  csr.md.update(bytes.getBytes());
  csr.signature = key.sign(csr.md);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.getPublicKeyFingerprint" id="apidoc.element.node-forge.pki.getPublicKeyFingerprint">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>getPublicKeyFingerprint
        <span class="apidocSignatureSpan">(key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicKeyFingerprint = function (key, options) {
  options = options || {};
  var md = options.md || forge.md.sha1.create();
  var type = options.type || 'RSAPublicKey';

  var bytes;
  switch(type) {
  case 'RSAPublicKey':
    bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
    break;
  case 'SubjectPublicKeyInfo':
    bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
    break;
  default:
    throw new Error('Unknown fingerprint type "' + options.type + '".');
  }

  // hash public key bytes
  md.start();
  md.update(bytes);
  var digest = md.digest();
  if(options.encoding === 'hex') {
    var hex = digest.toHex();
    if(options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if(options.encoding === 'binary') {
    return digest.getBytes();
  } else if(options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// encodes a public RSA key as an OpenSSH file
forge.ssh.publicKeyToOpenSSH(key, comment);

// encodes a private RSA key as an OpenSSH file
forge.ssh.privateKeyToOpenSSH(privateKey, passphrase);

// gets the SSH public key fingerprint in a byte buffer
forge.ssh.<span class="apidocCodeKeywordSpan">getPublicKeyFingerprint</span>(key);

// gets a hex-encoded, colon-delimited SSH public key fingerprint
forge.ssh.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});
```

&lt;a name="xhr" /&gt;
### XHR
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.getTBSCertificate" id="apidoc.element.node-forge.pki.getTBSCertificate">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>getTBSCertificate
        <span class="apidocSignatureSpan">(cert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTBSCertificate = function (cert) {
  // TBSCertificate
  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(cert.version).getBytes())
    ]),
    // serialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      forge.util.hexToBytes(cert.serialNumber)),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid, cert.siginfo.parameters)
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // notBefore
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
        asn1.dateToUtcTime(cert.validity.notBefore)),
      // notAfter
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
        asn1.dateToUtcTime(cert.validity.notAfter))
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(cert.publicKey)
  ]);

  if(cert.issuer.uniqueId) {
    // issuerUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.issuer.uniqueId
        )
      ])
    );
  }
  if(cert.subject.uniqueId) {
    // subjectUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.subject.uniqueId
        )
      ])
    );
  }

  if(cert.extensions.length &gt; 0) {
    // extensions (optional)
    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
  }

  return tbs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      'Unknown message digest algorithm OID.');
    error.algorithm = cert.md.algorithm;
    throw error;
  }
  cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;

  // get TBSCertificate, convert to DER
  cert.tbsCertificate = pki.<span class="apidocCodeKeywordSpan">getTBSCertificate</span>(cert);
  var bytes = asn1.toDer(cert.tbsCertificate);

  // digest and sign
  cert.md.update(bytes.getBytes());
  cert.signature = key.sign(cert.md);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.pemToDer" id="apidoc.element.node-forge.pki.pemToDer">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>pemToDer
        <span class="apidocSignatureSpan">(pem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pemToDer = function (pem) {
  var msg = forge.pem.decode(pem)[0];
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert PEM to DER; PEM is encrypted.');
  }
  return forge.util.createBuffer(msg.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyFromAsn1" id="apidoc.element.node-forge.pki.privateKeyFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyFromAsn1
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyFromAsn1 = function (obj) {
  // get PrivateKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {
    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
  }

  // get RSAPrivateKey
  capture = {};
  errors = [];
  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read private key. ' +
      'ASN.1 object does not contain an RSAPrivateKey.');
    error.errors = errors;
    throw error;
  }

  // Note: Version is currently ignored.
  // capture.privateKeyVersion
  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n, e, d, p, q, dP, dQ, qInv;
  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();

  // set private key
  return pki.setRsaPrivateKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16),
    new BigInteger(d, 16),
    new BigInteger(p, 16),
    new BigInteger(q, 16),
    new BigInteger(dP, 16),
    new BigInteger(dQ, 16),
    new BigInteger(qInv, 16));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a PEM-formatted private key to a Forge private key
var privateKey = pki.privateKeyFromPem(pem);

// convert a Forge private key to PEM-format
var pem = pki.privateKeyToPem(privateKey);

// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key
var privateKey = pki.<span class="apidocCodeKeywordSpan">privateKeyFromAsn1</span>(rsaPrivateKey);

// convert a Forge private key to an ASN.1 RSAPrivateKey
var rsaPrivateKey = pki.privateKeyToAsn1(privateKey);

// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
var privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyFromPem" id="apidoc.element.node-forge.pki.privateKeyFromPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyFromPem
        <span class="apidocSignatureSpan">(pem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PRIVATE KEY' &amp;&amp; msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM ' +
      'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert private key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.privateKeyFromAsn1(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

__Examples__

```js
var pki = forge.pki;

// convert a PEM-formatted private key to a Forge private key
var privateKey = pki.<span class="apidocCodeKeywordSpan">privateKeyFromPem</span>(pem);

// convert a Forge private key to PEM-format
var pem = pki.privateKeyToPem(privateKey);

// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key
var privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyInfoToPem" id="apidoc.element.node-forge.pki.privateKeyInfoToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyInfoToPem
        <span class="apidocSignatureSpan">(pki, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyInfoToPem = function (pki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'PRIVATE KEY',
    body: asn1.toDer(pki).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a Forge private key to an ASN.1 RSAPrivateKey
var rsaPrivateKey = pki.privateKeyToAsn1(privateKey);

// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
var privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);

// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM
var pem = pki.<span class="apidocCodeKeywordSpan">privateKeyInfoToPem</span>(privateKeyInfo);

// encrypts a PrivateKeyInfo and outputs an EncryptedPrivateKeyInfo
var encryptedPrivateKeyInfo = pki.encryptPrivateKeyInfo(
privateKeyInfo, 'password', {
  algorithm: 'aes256', // 'aes128', 'aes192', 'aes256', '3des'
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyToAsn1" id="apidoc.element.node-forge.pki.privateKeyToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToAsn1
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyToAsn1 = function (key) {
  // RSAPrivateKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e)),
    // privateExponent (d)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.d)),
    // privateKeyPrime1 (p)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.p)),
    // privateKeyPrime2 (q)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.q)),
    // privateKeyExponent1 (dP)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dP)),
    // privateKeyExponent2 (dQ)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dQ)),
    // coefficient (qInv)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.qInv))
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a Forge private key to PEM-format
var pem = pki.privateKeyToPem(privateKey);

// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key
var privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);

// convert a Forge private key to an ASN.1 RSAPrivateKey
var rsaPrivateKey = pki.<span class="apidocCodeKeywordSpan">privateKeyToAsn1</span>(privateKey);

// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
var privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);

// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM
var pem = pki.privateKeyInfoToPem(privateKeyInfo);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyToPem" id="apidoc.element.node-forge.pki.privateKeyToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToPem
        <span class="apidocSignatureSpan">(key, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyToPem = function (key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PRIVATE KEY',
    body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var pki = forge.pki;

// convert a PEM-formatted private key to a Forge private key
var privateKey = pki.privateKeyFromPem(pem);

// convert a Forge private key to PEM-format
var pem = pki.<span class="apidocCodeKeywordSpan">privateKeyToPem</span>(privateKey);

// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key
var privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);

// convert a Forge private key to an ASN.1 RSAPrivateKey
var rsaPrivateKey = pki.privateKeyToAsn1(privateKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.privateKeyToRSAPrivateKey" id="apidoc.element.node-forge.pki.privateKeyToRSAPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>privateKeyToRSAPrivateKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyToRSAPrivateKey = function (key) {
  // RSAPrivateKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e)),
    // privateExponent (d)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.d)),
    // privateKeyPrime1 (p)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.p)),
    // privateKeyPrime2 (q)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.q)),
    // privateKeyExponent1 (dP)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dP)),
    // privateKeyExponent2 (dQ)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dQ)),
    // coefficient (qInv)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.qInv))
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyFromAsn1" id="apidoc.element.node-forge.pki.publicKeyFromAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyFromAsn1
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyFromAsn1 = function (obj) {
  // get SubjectPublicKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {
    // get oid
    var oid = asn1.derToOid(capture.publicKeyOid);
    if(oid !== pki.oids.rsaEncryption) {
      var error = new Error('Cannot read public key. Unknown OID.');
      error.oid = oid;
      throw error;
    }
    obj = capture.rsaPublicKey;
  }

  // get RSA params
  errors = [];
  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
    var error = new Error('Cannot read public key. ' +
      'ASN.1 object does not contain an RSAPublicKey.');
    error.errors = errors;
    throw error;
  }

  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();

  // set public key
  return pki.setRsaPublicKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a PEM-formatted public key to a Forge public key
var publicKey = pki.publicKeyFromPem(pem);

// convert a Forge public key to PEM-format
var pem = pki.publicKeyToPem(publicKey);

// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key
var publicKey = pki.<span class="apidocCodeKeywordSpan">publicKeyFromAsn1</span>(subjectPublicKeyInfo);

// convert a Forge public key to an ASN.1 SubjectPublicKeyInfo
var subjectPublicKeyInfo = pki.publicKeyToAsn1(publicKey);

// gets a SHA-1 RSAPublicKey fingerprint a byte buffer
pki.getPublicKeyFingerprint(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyFromPem" id="apidoc.element.node-forge.pki.publicKeyFromPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyFromPem
        <span class="apidocSignatureSpan">(pem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyFromPem = function (pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PUBLIC KEY' &amp;&amp; msg.type !== 'RSA PUBLIC KEY') {
    var error = new Error('Could not convert public key from PEM; PEM header ' +
      'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType &amp;&amp; msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert public key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.publicKeyFromAsn1(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

__Examples__

```js
var pki = forge.pki;

// convert a PEM-formatted public key to a Forge public key
var publicKey = pki.<span class="apidocCodeKeywordSpan">publicKeyFromPem</span>(pem);

// convert a Forge public key to PEM-format
var pem = pki.publicKeyToPem(publicKey);

// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key
var publicKey = pki.publicKeyFromAsn1(subjectPublicKeyInfo);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyToAsn1" id="apidoc.element.node-forge.pki.publicKeyToAsn1">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToAsn1
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToAsn1 = function (key) {
  // SubjectPublicKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // subjectPublicKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
      pki.publicKeyToRSAPublicKey(key)
    ])
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert a Forge public key to PEM-format
var pem = pki.publicKeyToPem(publicKey);

// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key
var publicKey = pki.publicKeyFromAsn1(subjectPublicKeyInfo);

// convert a Forge public key to an ASN.1 SubjectPublicKeyInfo
var subjectPublicKeyInfo = pki.<span class="apidocCodeKeywordSpan">publicKeyToAsn1</span>(publicKey);

// gets a SHA-1 RSAPublicKey fingerprint a byte buffer
pki.getPublicKeyFingerprint(key);

// gets a SHA-1 SubjectPublicKeyInfo fingerprint a byte buffer
pki.getPublicKeyFingerprint(key, {type: 'SubjectPublicKeyInfo'});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyToPem" id="apidoc.element.node-forge.pki.publicKeyToPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToPem
        <span class="apidocSignatureSpan">(key, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToPem = function (key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var pki = forge.pki;

// convert a PEM-formatted public key to a Forge public key
var publicKey = pki.publicKeyFromPem(pem);

// convert a Forge public key to PEM-format
var pem = pki.<span class="apidocCodeKeywordSpan">publicKeyToPem</span>(publicKey);

// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key
var publicKey = pki.publicKeyFromAsn1(subjectPublicKeyInfo);

// convert a Forge public key to an ASN.1 SubjectPublicKeyInfo
var subjectPublicKeyInfo = pki.publicKeyToAsn1(publicKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyToRSAPublicKey" id="apidoc.element.node-forge.pki.publicKeyToRSAPublicKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToRSAPublicKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToRSAPublicKey = function (key) {
  // RSAPublicKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e))
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
       asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
     // parameters (null)
     asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
   ]),
   // subjectPublicKey
   asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
     pki.<span class="apidocCodeKeywordSpan">publicKeyToRSAPublicKey</span>(key)
   ])
 ]);
};

/**
* Converts a public key to an ASN.1 RSAPublicKey.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyToRSAPublicKeyPem" id="apidoc.element.node-forge.pki.publicKeyToRSAPublicKeyPem">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToRSAPublicKeyPem
        <span class="apidocSignatureSpan">(key, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToRSAPublicKeyPem = function (key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.publicKeyToSubjectPublicKeyInfo" id="apidoc.element.node-forge.pki.publicKeyToSubjectPublicKeyInfo">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>publicKeyToSubjectPublicKeyInfo
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToSubjectPublicKeyInfo = function (key) {
  // SubjectPublicKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // subjectPublicKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
      pki.publicKeyToRSAPublicKey(key)
    ])
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.setRsaPrivateKey" id="apidoc.element.node-forge.pki.setRsaPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>setRsaPrivateKey
        <span class="apidocSignatureSpan">( n, e, d, p, q, dP, dQ, qInv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRsaPrivateKey = function ( n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n: n,
    e: e,
    d: d,
    p: p,
    q: q,
    dP: dP,
    dQ: dQ,
    qInv: qInv
  };

<span class="apidocCodeCommentSpan">  /**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */
</span>  key.decrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    // do rsa decryption w/o any decoding
    var d = pki.rsa.decrypt(data, key, false, false);

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        decode: function(d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = { decode: function(d) { return d; } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // decode according to scheme
    return scheme.decode(d, key, false);
  };

  /**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */
  key.sign = function(md, scheme) {
    /* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */

    // private key operation
    var bt = false;

    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    }

    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 0x01;
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = { encode: function() { return md; } };
      bt = 0x01;
    }

    // encode and then encrypt
    var d = scheme.encode(md, key.n.bitLength());
    return pki.rsa.encrypt(d, key, bt);
  };

  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();

// set private key
return pki.<span class="apidocCodeKeywordSpan">setRsaPrivateKey</span>(
  new BigInteger(n, 16),
  new BigInteger(e, 16),
  new BigInteger(d, 16),
  new BigInteger(p, 16),
  new BigInteger(q, 16),
  new BigInteger(dP, 16),
  new BigInteger(dQ, 16),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.setRsaPublicKey" id="apidoc.element.node-forge.pki.setRsaPublicKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>setRsaPublicKey
        <span class="apidocSignatureSpan">(n, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRsaPublicKey = function (n, e) {
  var key = {
    n: n,
    e: e
  };

<span class="apidocCodeCommentSpan">  /**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */
</span>  key.encrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        encode: function(m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
        }
      };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        encode: function(m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = { encode: function(e) { return e; } };
    } else if(typeof scheme === 'string') {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // do scheme-based encoding then rsa encryption
    var e = scheme.encode(data, key, true);
    return pki.rsa.encrypt(e, key, true);
  };

  /**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */
   key.verify = function(digest, signature, scheme) {
     if(typeof scheme === 'string') {
       scheme = scheme.toUpperCase();
     } else if(scheme === undefined) {
       scheme = 'RSASSA-PKCS1-V1_5';
     }

     if(scheme === 'RSASSA-PKCS1-V1_5') {
       scheme = {
         verify: function(digest, d) {
           // remove padding
           d = _decodePkcs1_v1_5(d, key, true);
           // d is ASN.1 BER-encoded DigestInfo
           var obj = asn1.fromDer(d);
           // compare the given digest to the decrypted one
           return digest === obj.value[1].value;
         }
       };
     } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
       scheme = {
         verify: function(digest, d) {
           // remove padding
           d = _decodePkcs1_v1_5(d, key, true);
           return digest === d;
         }
       };
     }

     // do rsa decryption w/o any decoding, then verify -- which does decoding
     var d = pki.rsa.decrypt(signature, key, true, false);
     return scheme.verify(digest, d, key.n.bitL ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// proprietary legacy format + encapsulated PEM headers (DEK-Info)
var pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});

// decrypts a PEM-formatted, encrypted private key
var privateKey = pki.decryptRsaPrivateKey(pem, 'password');

// sets an RSA public key from a private key
var publicKey = pki.<span class="apidocCodeKeywordSpan">setRsaPublicKey</span>(privateKey.n, privateKey.e);
```

&lt;a name="pkcs10" /&gt;
### PKCS#10

Provides certification requests or certificate signing requests (CSR) from
[PKCS#10][].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.verifyCertificateChain" id="apidoc.element.node-forge.pki.verifyCertificateChain">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>verifyCertificateChain
        <span class="apidocSignatureSpan">(caStore, chain, verify)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyCertificateChain = function (caStore, chain, verify) {
  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whet ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// add a certificate to the CA store
caStore.addCertificate(certObjectOrPemString);

// gets the issuer (its certificate) for the given certificate
var issuerCert = caStore.getIssuer(subjectCert);

// verifies a certificate chain against a CA store
pki.<span class="apidocCodeKeywordSpan">verifyCertificateChain</span>(caStore, chain, customVerifyCallback);

// signs a certificate using the given private key
cert.sign(privateKey);

// signs a certificate using SHA-256 instead of SHA-1
cert.sign(privateKey, forge.md.sha256.create());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.pki.wrapRsaPrivateKey" id="apidoc.element.node-forge.pki.wrapRsaPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.pki.</span>wrapRsaPrivateKey
        <span class="apidocSignatureSpan">(rsaKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapRsaPrivateKey = function (rsaKey) {
  // PrivateKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // privateKeyAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // PrivateKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
      asn1.toDer(rsaKey).getBytes())
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key
var privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);

// convert a Forge private key to an ASN.1 RSAPrivateKey
var rsaPrivateKey = pki.privateKeyToAsn1(privateKey);

// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
var privateKeyInfo = pki.<span class="apidocCodeKeywordSpan">wrapRsaPrivateKey</span>(rsaPrivateKey);

// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM
var pem = pki.privateKeyInfoToPem(privateKeyInfo);

// encrypts a PrivateKeyInfo and outputs an EncryptedPrivateKeyInfo
var encryptedPrivateKeyInfo = pki.encryptPrivateKeyInfo(
privateKeyInfo, 'password', {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.prime" id="apidoc.module.node-forge.prime">module node-forge.prime</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.prime.generateProbablePrime" id="apidoc.element.node-forge.prime.generateProbablePrime">
        function <span class="apidocSignatureSpan">node-forge.prime.</span>generateProbablePrime
        <span class="apidocSignatureSpan">(bits, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateProbablePrime = function (bits, options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};

  // default to PRIMEINC algorithm
  var algorithm = options.algorithm || 'PRIMEINC';
  if(typeof algorithm === 'string') {
    algorithm = {name: algorithm};
  }
  algorithm.options = algorithm.options || {};

  // create prng with api that matches BigInteger secure random
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i &lt; x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  if(algorithm.name === 'PRIMEINC') {
    return primeincFindPrime(bits, rng, algorithm.options, callback);
  }

  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Provides an API for generating large, random, probable primes.

__Examples__

```js
// generate a random prime on the main JS thread
var bits = 1024;
forge.prime.<span class="apidocCodeKeywordSpan">generateProbablePrime</span>(bits, function(err, num) {
  console.log('random prime', num.toString(16));
});

// generate a random prime using Web Workers (if available, otherwise
// falls back to the main thread)
var bits = 1024;
var options = {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.prng" id="apidoc.module.node-forge.prng">module node-forge.prng</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.prng.create" id="apidoc.element.node-forge.prng.create">
        function <span class="apidocSignatureSpan">node-forge.prng.</span>create
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (plugin) {
  var ctx = {
    plugin: plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0
  };

  // create 32 entropy pools (each is a message digest)
  var md = plugin.md;
  var pools = new Array(32);
  for(var i = 0; i &lt; 32; ++i) {
    pools[i] = md.create();
  }
  ctx.pools = pools;

  // entropy pools are written to cyclically, starting at index 0
  ctx.pool = 0;

<span class="apidocCodeCommentSpan">  /**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */
</span>  ctx.generate = function(count, callback) {
    // do synchronously
    if(!callback) {
      return ctx.generateSync(count);
    }

    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge.util.createBuffer();

    // reset key for every request
    ctx.key = null;

    generate();

    function generate(err) {
      if(err) {
        return callback(err);
      }

      // sufficient bytes generated
      if(b.length() &gt;= count) {
        return callback(null, b.getBytes(count));
      }

      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated &gt; 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        // prevent stack overflow
        return forge.util.nextTick(function() {
          _reseed(generate);
        });
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));

      forge.util.setImmediate(generate);
    }
  };

  /**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */
  ctx.generateSync = function(count) {
    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;

    // reset key for every request
    ctx.key = null;

    var b = forge.util.createBuffer();
    while(b.length() &lt; count) {
      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated &gt; 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        _reseedSync();
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }

    return b.getBytes(count);
  };

  /**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */
  function _reseed(callback) {
    if(ctx.pools[0].messageLength &gt;= 32) {
      _seed();
      return callback();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) &lt;&lt; 5;
    ctx.seedFile(needed, function(err, bytes) {
      if(err) {
        return callback(err);
      }
      ctx.collect(bytes);
      _seed();
      callback();
    });
  }

  /**
   * Private function that synchronously reseeds a generator.
   */
  function _reseedSync() {
    if(ctx.pools[0].messageLength &gt;= 32) {
      return _seed();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) &lt;&lt; 5; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.pss" id="apidoc.module.node-forge.pss">module node-forge.pss</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.pss.create" id="apidoc.element.node-forge.pss.create">
        function <span class="apidocSignatureSpan">node-forge.pss.</span>create
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (options) {
  // backwards compatibility w/legacy args: hash, mgf, sLen
  if(arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }

  var hash = options.md;
  var mgf = options.mgf;
  var hLen = hash.digestLength;

  var salt_ = options.salt || null;
  if(typeof salt_ === 'string') {
    // assume binary-encoded string
    salt_ = forge.util.createBuffer(salt_);
  }

  var sLen;
  if('saltLength' in options) {
    sLen = options.saltLength;
  } else if(salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error('Salt length not specified or specific salt not given.');
  }

  if(salt_ !== null &amp;&amp; salt_.length() !== sLen) {
    throw new Error('Given salt length does not match length of given salt.');
  }

  var prng = options.prng || forge.random;

  var pssobj = {};

<span class="apidocCodeCommentSpan">  /**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */
</span>  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* 2. Let mHash = Hash(M), an octet string of length hLen. */
    var mHash = md.digest().getBytes();

    /* 3. If emLen &lt; hLen + sLen + 2, output "encoding error" and stop. */
    if(emLen &lt; hLen + sLen + 2) {
      throw new Error('Message is too long to encrypt.');
    }

    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */
    var salt;
    if(salt_ === null) {
      salt = prng.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }

    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 6. Let H = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h = hash.digest().getBytes();

    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */
    var ps = new forge.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);

    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */
    ps.putByte(0x01);
    ps.putBytes(salt);
    var db = ps.getBytes();

    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);

    /* 10. Let maskedDB = DB \xor dbMask. */
    var maskedDB = '';
    for(i = 0; i &lt; maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */
    var mask = (0xFF00 &gt;&gt; (8 * emLen - emBits)) &amp; 0xFF;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) &amp; ~mask) +
      maskedDB.substr(1);

    /* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */
    return maskedDB + h + String.fromCharCode(0xbc);
  };

  /**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.random" id="apidoc.module.node-forge.random">module node-forge.random</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.random.collect" id="apidoc.element.node-forge.random.collect">
        function <span class="apidocSignatureSpan">node-forge.random.</span>collect
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collect = function (bytes) {
  // iterate over pools distributing entropy cyclically
  var count = bytes.length;
  for(var i = 0; i &lt; count; ++i) {
    ctx.pools[ctx.pool].update(bytes.substr(i, 1));
    ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// get some random bytes asynchronously
forge.random.getBytes(32, function(err, bytes) {
  console.log(forge.util.bytesToHex(bytes));
});

// collect some entropy if you'd like
forge.random.<span class="apidocCodeKeywordSpan">collect</span>(someRandomBytes);
jQuery().mousemove(function(e) {
  forge.random.collectInt(e.clientX, 16);
  forge.random.collectInt(e.clientY, 16);
});

// specify a seed file for use with the synchronous API if you'd like
forge.random.seedFileSync = function(needed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.collectInt" id="apidoc.element.node-forge.random.collectInt">
        function <span class="apidocSignatureSpan">node-forge.random.</span>collectInt
        <span class="apidocSignatureSpan">(i, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectInt = function (i, n) {
  var bytes = '';
  for(var x = 0; x &lt; n; x += 8) {
    bytes += String.fromCharCode((i &gt;&gt; x) &amp; 0xFF);
  }
  ctx.collect(bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
forge.random.getBytes(32, function(err, bytes) {
console.log(forge.util.bytesToHex(bytes));
});

// collect some entropy if you'd like
forge.random.collect(someRandomBytes);
jQuery().mousemove(function(e) {
forge.random.<span class="apidocCodeKeywordSpan">collectInt</span>(e.clientX, 16);
forge.random.collectInt(e.clientY, 16);
});

// specify a seed file for use with the synchronous API if you'd like
forge.random.seedFileSync = function(needed) {
// get 'needed' number of random bytes from somewhere
return fetchedRandomBytes;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.createInstance" id="apidoc.element.node-forge.random.createInstance">
        function <span class="apidocSignatureSpan">node-forge.random.</span>createInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spawnPrng() {
  var ctx = forge.prng.create(prng_aes);

<span class="apidocCodeCommentSpan">  /**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */
</span>  ctx.getBytes = function(count, callback) {
    return ctx.generate(count, callback);
  };

  /**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */
  ctx.getBytesSync = function(count) {
    return ctx.generate(count);
  };

  return ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// register the main thread to send entropy or a Web Worker to receive
// entropy on demand from the main thread
forge.random.registerWorker(self);

// generate a new instance of a PRNG with no collected entropy
var myPrng = forge.random.<span class="apidocCodeKeywordSpan">createInstance</span>();
```

&lt;a name="task" /&gt;
### Tasks

Provides queuing and synchronizing tasks in a web application.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.generate" id="apidoc.element.node-forge.random.generate">
        function <span class="apidocSignatureSpan">node-forge.random.</span>generate
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (count, callback) {
  // do synchronously
  if(!callback) {
    return ctx.generateSync(count);
  }

  // simple generator using counter-based CBC
  var cipher = ctx.plugin.cipher;
  var increment = ctx.plugin.increment;
  var formatKey = ctx.plugin.formatKey;
  var formatSeed = ctx.plugin.formatSeed;
  var b = forge.util.createBuffer();

  // reset key for every request
  ctx.key = null;

  generate();

  function generate(err) {
    if(err) {
      return callback(err);
    }

    // sufficient bytes generated
    if(b.length() &gt;= count) {
      return callback(null, b.getBytes(count));
    }

    // if amount of data generated is greater than 1 MiB, trigger reseed
    if(ctx.generated &gt; 0xfffff) {
      ctx.key = null;
    }

    if(ctx.key === null) {
      // prevent stack overflow
      return forge.util.nextTick(function() {
        _reseed(generate);
      });
    }

    // generate the random bytes
    var bytes = cipher(ctx.key, ctx.seed);
    ctx.generated += bytes.length;
    b.putBytes(bytes);

    // generate bytes for a new key and seed
    ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
    ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));

    forge.util.setImmediate(generate);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
  }

  // encrypt the random
  var encapsulation = publicKey.encrypt(r, 'NONE');

  // generate the secret key
  var key = kdf.<span class="apidocCodeKeywordSpan">generate</span>(r, keyLength);

  return {encapsulation: encapsulation, key: key};
};

/**
 * Decrypts an encapsulated secret key.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.generateSync" id="apidoc.element.node-forge.random.generateSync">
        function <span class="apidocSignatureSpan">node-forge.random.</span>generateSync
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateSync = function (count) {
  // simple generator using counter-based CBC
  var cipher = ctx.plugin.cipher;
  var increment = ctx.plugin.increment;
  var formatKey = ctx.plugin.formatKey;
  var formatSeed = ctx.plugin.formatSeed;

  // reset key for every request
  ctx.key = null;

  var b = forge.util.createBuffer();
  while(b.length() &lt; count) {
    // if amount of data generated is greater than 1 MiB, trigger reseed
    if(ctx.generated &gt; 0xfffff) {
      ctx.key = null;
    }

    if(ctx.key === null) {
      _reseedSync();
    }

    // generate the random bytes
    var bytes = cipher(ctx.key, ctx.seed);
    ctx.generated += bytes.length;
    b.putBytes(bytes);

    // generate bytes for a new key and seed
    ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
    ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
  }

  return b.getBytes(count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */
  ctx.generate = function(count, callback) {
// do synchronously
if(!callback) {
  return ctx.<span class="apidocCodeKeywordSpan">generateSync</span>(count);
}

// simple generator using counter-based CBC
var cipher = ctx.plugin.cipher;
var increment = ctx.plugin.increment;
var formatKey = ctx.plugin.formatKey;
var formatSeed = ctx.plugin.formatSeed;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.getBytes" id="apidoc.element.node-forge.random.getBytes">
        function <span class="apidocSignatureSpan">node-forge.random.</span>getBytes
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function (count, callback) {
  return ctx.generate(count, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/* the private key for the client-side cert if provided */
getPrivateKey: function(connection, cert) {
  return myClientPrivateKey;
},
tlsDataReady: function(connection) {
  // TLS data (encrypted) is ready to be sent to the server
  sendToServerSomehow(connection.tlsData.<span class="apidocCodeKeywordSpan">getBytes</span>());
  // if you were communicating with the server below, you'd do:
  // server.process(connection.tlsData.getBytes());
},
dataReady: function(connection) {
  // clear data from the server is ready
  console.log('the server sent: ' +
    forge.util.decodeUtf8(connection.data.getBytes()));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.getBytesSync" id="apidoc.element.node-forge.random.getBytesSync">
        function <span class="apidocSignatureSpan">node-forge.random.</span>getBytesSync
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytesSync = function (count) {
  return ctx.generate(count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[DES][] is used. Use a [3DES][] algorithm to enforce Triple-DES.

__Examples__

```js
// generate a random key and IV
// Note: a key size of 16 bytes will use AES-128, 24 =&gt; AES-192, 32 =&gt; AES-256
var key = forge.random.<span class="apidocCodeKeywordSpan">getBytesSync</span>(16);
var iv = forge.random.getBytesSync(16);

/* alternatively, generate a password-based 16-byte key
var salt = forge.random.getBytesSync(128);
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.registerWorker" id="apidoc.element.node-forge.random.registerWorker">
        function <span class="apidocSignatureSpan">node-forge.random.</span>registerWorker
        <span class="apidocSignatureSpan">(worker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerWorker = function (worker) {
  // worker receives random bytes
  if(worker === self) {
    ctx.seedFile = function(needed, callback) {
      function listener(e) {
        var data = e.data;
        if(data.forge &amp;&amp; data.forge.prng) {
          self.removeEventListener('message', listener);
          callback(data.forge.prng.err, data.forge.prng.bytes);
        }
      }
      self.addEventListener('message', listener);
      self.postMessage({forge: {prng: {needed: needed}}});
    };
  } else {
    // main thread sends random bytes upon request
    var listener = function(e) {
      var data = e.data;
      if(data.forge &amp;&amp; data.forge.prng) {
        ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
          worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});
        });
      }
    };
    // TODO: do we need to remove the event listener when the worker dies?
    worker.addEventListener('message', listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
forge.random.seedFile = function(needed, callback) {
  // get the 'needed' number of random bytes from somewhere
  callback(null, fetchedRandomBytes);
});

// register the main thread to send entropy or a Web Worker to receive
// entropy on demand from the main thread
forge.random.<span class="apidocCodeKeywordSpan">registerWorker</span>(self);

// generate a new instance of a PRNG with no collected entropy
var myPrng = forge.random.createInstance();
```

&lt;a name="task" /&gt;
### Tasks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.seedFile" id="apidoc.element.node-forge.random.seedFile">
        function <span class="apidocSignatureSpan">node-forge.random.</span>seedFile
        <span class="apidocSignatureSpan">(needed, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seedFile = function (needed, callback) {
  _crypto.randomBytes(needed, function(err, bytes) {
    if(err) {
      return callback(err);
    }
    callback(null, bytes.toString());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function _reseed(callback) {
if(ctx.pools[0].messageLength &gt;= 32) {
  _seed();
  return callback();
}
// not enough seed data...
var needed = (32 - ctx.pools[0].messageLength) &lt;&lt; 5;
ctx.<span class="apidocCodeKeywordSpan">seedFile</span>(needed, function(err, bytes) {
  if(err) {
    return callback(err);
  }
  ctx.collect(bytes);
  _seed();
  callback();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.seedFileSync" id="apidoc.element.node-forge.random.seedFileSync">
        function <span class="apidocSignatureSpan">node-forge.random.</span>seedFileSync
        <span class="apidocSignatureSpan">(needed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seedFileSync = function (needed) {
  return _crypto.randomBytes(needed).toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function _reseedSync() {
  if(ctx.pools[0].messageLength &gt;= 32) {
    return _seed();
  }
  // not enough seed data...
  var needed = (32 - ctx.pools[0].messageLength) &lt;&lt; 5;
  ctx.collect(ctx.<span class="apidocCodeKeywordSpan">seedFileSync</span>(needed));
  _seed();
}

/**
 * Private function that seeds a generator once enough bytes are available.
 */
function _seed() {
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.random.plugin" id="apidoc.module.node-forge.random.plugin">module node-forge.random.plugin</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.random.plugin.cipher" id="apidoc.element.node-forge.random.plugin.cipher">
        function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>cipher
        <span class="apidocSignatureSpan">(key, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cipher = function (key, seed) {
  forge.aes._updateBlock(key, seed, _prng_aes_output, false);
  _prng_aes_buffer.putInt32(_prng_aes_output[0]);
  _prng_aes_buffer.putInt32(_prng_aes_output[1]);
  _prng_aes_buffer.putInt32(_prng_aes_output[2]);
  _prng_aes_buffer.putInt32(_prng_aes_output[3]);
  return _prng_aes_buffer.getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.plugin.formatKey" id="apidoc.element.node-forge.random.plugin.formatKey">
        function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>formatKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatKey = function (key) {
  // convert the key into 32-bit integers
  var tmp = forge.util.createBuffer(key);
  key = new Array(4);
  key[0] = tmp.getInt32();
  key[1] = tmp.getInt32();
  key[2] = tmp.getInt32();
  key[3] = tmp.getInt32();

  // return the expanded key
  return forge.aes._expandKey(key, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get digest for key bytes and iterate again for seed bytes
  var keyBytes = md.digest().getBytes();
  md.start();
  md.update(keyBytes);
  var seedBytes = md.digest().getBytes();

  // update
  ctx.key = ctx.plugin.<span class="apidocCodeKeywordSpan">formatKey</span>(keyBytes);
  ctx.seed = ctx.plugin.formatSeed(seedBytes);
  ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;
  ctx.generated = 0;
}

/**
 * The built-in default seedFile. This seedFile is used when entropy
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.plugin.formatSeed" id="apidoc.element.node-forge.random.plugin.formatSeed">
        function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>formatSeed
        <span class="apidocSignatureSpan">(seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatSeed = function (seed) {
  // convert seed into 32-bit integers
  var tmp = forge.util.createBuffer(seed);
  seed = new Array(4);
  seed[0] = tmp.getInt32();
  seed[1] = tmp.getInt32();
  seed[2] = tmp.getInt32();
  seed[3] = tmp.getInt32();
  return seed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var keyBytes = md.digest().getBytes();
  md.start();
  md.update(keyBytes);
  var seedBytes = md.digest().getBytes();

  // update
  ctx.key = ctx.plugin.formatKey(keyBytes);
  ctx.seed = ctx.plugin.<span class="apidocCodeKeywordSpan">formatSeed</span>(seedBytes);
  ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;
  ctx.generated = 0;
}

/**
 * The built-in default seedFile. This seedFile is used when entropy
 * is needed immediately.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.random.plugin.increment" id="apidoc.element.node-forge.random.plugin.increment">
        function <span class="apidocSignatureSpan">node-forge.random.plugin.</span>increment
        <span class="apidocSignatureSpan">(seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">increment = function (seed) {
  // FIXME: do we care about carry or signed issues?
  ++seed[3];
  return seed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.rc2" id="apidoc.module.node-forge.rc2">module node-forge.rc2</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.rc2.createDecryptionCipher" id="apidoc.element.node-forge.rc2.createDecryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.rc2.</span>createDecryptionCipher
        <span class="apidocSignatureSpan">(key, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDecryptionCipher = function (key, bits) {
  return createCipher(key, bits, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createDecryptionCipher</span>(key);
cipher.start(iv);
cipher.update(encrypted);
cipher.finish();
// outputs decrypted hex
console.log(cipher.output.toHex());
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rc2.createEncryptionCipher" id="apidoc.element.node-forge.rc2.createEncryptionCipher">
        function <span class="apidocSignatureSpan">node-forge.rc2.</span>createEncryptionCipher
        <span class="apidocSignatureSpan">(key, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEncryptionCipher = function (key, bits) {
  return createCipher(key, bits, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// generate a random key and IV
var key = forge.random.getBytesSync(16);
var iv = forge.random.getBytesSync(8);

// encrypt some bytes
var cipher = forge.rc2.<span class="apidocCodeKeywordSpan">createEncryptionCipher</span>(key);
cipher.start(iv);
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rc2.expandKey" id="apidoc.element.node-forge.rc2.expandKey">
        function <span class="apidocSignatureSpan">node-forge.rc2.</span>expandKey
        <span class="apidocSignatureSpan">(key, effKeyBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandKey = function (key, effKeyBits) {
  if(typeof key === 'string') {
    key = forge.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;

<span class="apidocCodeCommentSpan">  /* introduce variables that match the names used in RFC #2268 */
</span>  var L = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 0xff &gt;&gt; (T1 &amp; 0x07);
  var i;

  for(i = T; i &lt; 128; i++) {
    L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) &amp; 0xff]);
  }

  L.setAt(128 - T8, piTable[L.at(128 - T8) &amp; TM]);

  for(i = 127 - T8; i &gt;= 0; i--) {
    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
  }

  return L;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var createCipher = function(key, bits, encrypt) {
var _finish = false, _input = null, _output = null, _iv = null;
var mixRound, mashRound;
var i, j, K = [];

/* Expand key and fill into K[] Array */
key = forge.rc2.<span class="apidocCodeKeywordSpan">expandKey</span>(key, bits);
for(i = 0; i &lt; 64; i++) {
  K.push(key.getInt16Le());
}

if(encrypt) {
  /**
   * Perform one mixing round "in place".
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rc2.startDecrypting" id="apidoc.element.node-forge.rc2.startDecrypting">
        function <span class="apidocSignatureSpan">node-forge.rc2.</span>startDecrypting
        <span class="apidocSignatureSpan">(key, iv, output)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startDecrypting = function (key, iv, output) {
  var cipher = forge.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rc2.startEncrypting" id="apidoc.element.node-forge.rc2.startEncrypting">
        function <span class="apidocSignatureSpan">node-forge.rc2.</span>startEncrypting
        <span class="apidocSignatureSpan">(key, iv, output)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startEncrypting = function (key, iv, output) {
  var cipher = forge.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.rsa" id="apidoc.module.node-forge.rsa">module node-forge.rsa</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.rsa.createKeyPairGenerationState" id="apidoc.element.node-forge.rsa.createKeyPairGenerationState">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>createKeyPairGenerationState
        <span class="apidocSignatureSpan">(bits, e, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createKeyPairGenerationState = function (bits, e, options) {
  // TODO: migrate step-based prime generation code to forge.prime

  // set default bits
  if(typeof(bits) === 'string') {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;

  // create prng with api that matches BigInteger secure random
  options = options || {};
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i &lt; x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  var algorithm = options.algorithm || 'PRIMEINC';

  // create PRIMEINC algorithm state
  var rval;
  if(algorithm === 'PRIMEINC') {
    rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits &gt;&gt; 1,
      pBits: bits - (bits &gt;&gt; 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error('Invalid key generation algorithm: ' + algorithm);
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// native APIs if available.
rsa.generateKeyPair({bits: 2048, workers: 2}, function(err, keypair) {
// keypair.privateKey, keypair.publicKey
});

// generate an RSA key pair in steps that attempt to run for a specified period
// of time on the main JS thread
var state = rsa.<span class="apidocCodeKeywordSpan">createKeyPairGenerationState</span>(2048, 0x10001);
var step = function() {
// run for 100 ms
if(!rsa.stepKeyPairGenerationState(state, 100)) {
  setTimeout(step, 1);
}
else {
  // done, turn off progress indicator, use state.keys
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.decrypt" id="apidoc.element.node-forge.rsa.decrypt">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>decrypt
        <span class="apidocSignatureSpan">(ed, key, pub, ml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (ed, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  // error if the length of the encrypted data ED is not k
  if(ed.length !== k) {
    var error = new Error('Encrypted message length is invalid.');
    error.length = ed.length;
    error.expected = k;
    throw error;
  }

  // convert encrypted data into a big integer
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);

  // y must be less than the modulus or it wasn't the result of
  // a previous mod operation (encryption) using that modulus
  if(y.compareTo(key.n) &gt;= 0) {
    throw new Error('Encrypted message is invalid.');
  }

  // do RSA decryption
  var x = _modPow(y, key, pub);

  // create the encryption block, if x is shorter in bytes than k, then
  // prepend zero bytes to fill up eb
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var xhex = x.toString(16);
  var eb = forge.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while(zeros &gt; 0) {
    eb.putByte(0x00);
    --zeros;
  }
  eb.putBytes(forge.util.hexToBytes(xhex));

  if(ml !== false) {
    // legacy, default to PKCS#1 v1.5 padding
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }

  // return message
  return eb.getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.encrypt(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.<span class="apidocCodeKeywordSpan">decrypt</span>(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');

// decrypt data with a private key using RSAES PKCS#1 v1.5
var decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.encrypt" id="apidoc.element.node-forge.rsa.encrypt">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>encrypt
        <span class="apidocSignatureSpan">(m, key, bt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (m, key, bt) {
  var pub = bt;
  var eb;

  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  if(bt !== false &amp;&amp; bt !== true) {
    // legacy, default to PKCS#1 v1.5 padding
    pub = (bt === 0x02);
    eb = _encodePkcs1_v1_5(m, key, bt);
  } else {
    eb = forge.util.createBuffer();
    eb.putBytes(m);
  }

  // load encryption block as big integer 'x'
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var x = new BigInteger(eb.toHex(), 16);

  // do RSA encryption
  var y = _modPow(x, key, pub);

  // convert y into the encrypted data byte string, if y is shorter in
  // bytes than k, then prepend zero bytes to fill up ed
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var yhex = y.toString(16);
  var ed = forge.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while(zeros &gt; 0) {
    ed.putByte(0x00);
    --zeros;
  }
  ed.putBytes(forge.util.hexToBytes(yhex));
  return ed.getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // optionally pass 'prng' with a custom PRNG implementation
});
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
publicKey.verify(md.digest().getBytes(), signature, pss);

// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)
var encrypted = publicKey.<span class="apidocCodeKeywordSpan">encrypt</span>(bytes);

// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)
var decrypted = privateKey.decrypt(encrypted);

// encrypt data with a public key using RSAES PKCS#1 v1.5
var encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.generateKeyPair" id="apidoc.element.node-forge.rsa.generateKeyPair">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>generateKeyPair
        <span class="apidocSignatureSpan">(bits, e, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateKeyPair = function (bits, e, options, callback) {
  // (bits), (options), (callback)
  if(arguments.length === 1) {
    if(typeof bits === 'object') {
      options = bits;
      bits = undefined;
    } else if(typeof bits === 'function') {
      callback = bits;
      bits = undefined;
    }
  } else if(arguments.length === 2) {
    // (bits, e), (bits, options), (bits, callback), (options, callback)
    if(typeof bits === 'number') {
      if(typeof e === 'function') {
        callback = e;
        e = undefined;
      } else if(typeof e !== 'number') {
        options = e;
        e = undefined;
      }
    } else {
      options = bits;
      callback = e;
      bits = undefined;
      e = undefined;
    }
  } else if(arguments.length === 3) {
    // (bits, e, options), (bits, e, callback), (bits, options, callback)
    if(typeof e === 'number') {
      if(typeof options === 'function') {
        callback = options;
        options = undefined;
      }
    } else {
      callback = options;
      options = e;
      e = undefined;
    }
  }
  options = options || {};
  if(bits === undefined) {
    bits = options.bits || 2048;
  }
  if(e === undefined) {
    e = options.e || 0x10001;
  }

  // if native code is permitted and a callback is given, use native
  // key generation code if available and if parameters are acceptable
  if(!forge.options.usePureJavaScript &amp;&amp; callback &amp;&amp;
    bits &gt;= 256 &amp;&amp; bits &lt;= 16384 &amp;&amp; (e === 0x10001 || e === 3)) {
    if(_detectSubtleCrypto('generateKey') &amp;&amp; _detectSubtleCrypto('exportKey')) {
      // use standard native generateKey
      return window.crypto.subtle.generateKey({
        name: 'RSASSA-PKCS1-v1_5',
        modulusLength: bits,
        publicExponent: _intToUint8Array(e),
        hash: {name: 'SHA-256'}
      }, true /* key can be exported*/, ['sign', 'verify'])
      .then(function(pair) {
        return window.crypto.subtle.exportKey('pkcs8', pair.privateKey);
      // avoiding catch(function(err) {...}) to support IE &lt;= 8
      }).then(undefined, function(err) {
        callback(err);
      }).then(function(pkcs8) {
        if(pkcs8) {
          var privateKey = pki.privateKeyFromAsn1(
            asn1.fromDer(forge.util.createBuffer(pkcs8)));
          callback(null, {
            privateKey: privateKey,
            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
          });
        }
      });
    }
    if(_detectSubtleMsCrypto('generateKey') &amp;&amp;
      _detectSubtleMsCrypto('exportKey')) {
      var genOp = window.msCrypto.subtle.generateKey({
        name: 'RSASSA-PKCS1-v1_5',
        modulusLength: bits,
        publicExponent: _intToUint8Array(e),
        hash: {name: 'SHA-256'}
      }, true /* key can be exported*/, ['sign', 'verify']);
      genOp.oncomplete = function(e) {
        var pair = e.target.result;
        var exportOp = window.msCrypto.subtle.exportKey(
          'pkcs8', pair.privateKey);
        exportOp.oncomplete = function(e) {
          var pkcs8 = e.target.result;
          var privateKey = pki.privateKeyFromAsn1(
            asn1.fromDer(forge.util.createBuffer(pkcs8)));
          callback(null, {
            privateKey: privateKey,
            publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
          });
        };
        exportOp.onerror = function(err) {
          callback(err);
        };
      };
      genOp.onerror = function(err) {
        callback(err);
      };
      return;
    }
  }

  // use JavaScript implementation
  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
  if(!callback) {
    pki.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var rsa = forge.pki.rsa;

// generate an RSA key pair synchronously
// *NOT RECOMMENDED* -- can be significantly slower than async and will not
// use native APIs if available.
var keypair = rsa.<span class="apidocCodeKeywordSpan">generateKeyPair</span>({bits: 2048, e: 0x10001});

// generate an RSA key pair asynchronously (uses web workers if available)
// use workers: -1 to run a fast core estimator to optimize # of workers
// *RECOMMENDED* - can be significantly faster than sync -- and will use
// native APIs if available.
rsa.generateKeyPair({bits: 2048, workers: 2}, function(err, keypair) {
// keypair.privateKey, keypair.publicKey
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.setPrivateKey" id="apidoc.element.node-forge.rsa.setPrivateKey">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>setPrivateKey
        <span class="apidocSignatureSpan">( n, e, d, p, q, dP, dQ, qInv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPrivateKey = function ( n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n: n,
    e: e,
    d: d,
    p: p,
    q: q,
    dP: dP,
    dQ: dQ,
    qInv: qInv
  };

<span class="apidocCodeCommentSpan">  /**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */
</span>  key.decrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    // do rsa decryption w/o any decoding
    var d = pki.rsa.decrypt(data, key, false, false);

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        decode: function(d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = { decode: function(d) { return d; } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // decode according to scheme
    return scheme.decode(d, key, false);
  };

  /**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */
  key.sign = function(md, scheme) {
    /* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */

    // private key operation
    var bt = false;

    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    }

    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 0x01;
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = { encode: function() { return md; } };
      bt = 0x01;
    }

    // encode and then encrypt
    var d = scheme.encode(md, key.n.bitLength());
    return pki.rsa.encrypt(d, key, bt);
  };

  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state.q = null;
    state.state = 0;
  }
} else if(state.state === 5) {
  // set keys
  var d = state.e.modInverse(state.phi);
  state.keys = {
    privateKey: pki.rsa.<span class="apidocCodeKeywordSpan">setPrivateKey</span>(
      state.n, state.e, d, state.p, state.q,
      d.mod(state.p1), d.mod(state.q1),
      state.q.modInverse(state.p)),
    publicKey: pki.rsa.setPublicKey(state.n, state.e)
  };
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.setPublicKey" id="apidoc.element.node-forge.rsa.setPublicKey">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>setPublicKey
        <span class="apidocSignatureSpan">(n, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPublicKey = function (n, e) {
  var key = {
    n: n,
    e: e
  };

<span class="apidocCodeCommentSpan">  /**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */
</span>  key.encrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        encode: function(m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
        }
      };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        encode: function(m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = { encode: function(e) { return e; } };
    } else if(typeof scheme === 'string') {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // do scheme-based encoding then rsa encryption
    var e = scheme.encode(data, key, true);
    return pki.rsa.encrypt(e, key, true);
  };

  /**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */
   key.verify = function(digest, signature, scheme) {
     if(typeof scheme === 'string') {
       scheme = scheme.toUpperCase();
     } else if(scheme === undefined) {
       scheme = 'RSASSA-PKCS1-V1_5';
     }

     if(scheme === 'RSASSA-PKCS1-V1_5') {
       scheme = {
         verify: function(digest, d) {
           // remove padding
           d = _decodePkcs1_v1_5(d, key, true);
           // d is ASN.1 BER-encoded DigestInfo
           var obj = asn1.fromDer(d);
           // compare the given digest to the decrypted one
           return digest === obj.value[1].value;
         }
       };
     } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
       scheme = {
         verify: function(digest, d) {
           // remove padding
           d = _decodePkcs1_v1_5(d, key, true);
           return digest === d;
         }
       };
     }

     // do rsa decryption w/o any decoding, then verify -- which does decoding
     var d = pki.rsa.decrypt(signature, key, true, false);
     return scheme.verify(digest, d, key.n.bitL ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // set keys
  var d = state.e.modInverse(state.phi);
  state.keys = {
    privateKey: pki.rsa.setPrivateKey(
      state.n, state.e, d, state.p, state.q,
      d.mod(state.p1), d.mod(state.q1),
      state.q.modInverse(state.p)),
    publicKey: pki.rsa.<span class="apidocCodeKeywordSpan">setPublicKey</span>(state.n, state.e)
  };
}

// update timing
t2 = +new Date();
total += t2 - t1;
t1 = t2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.rsa.stepKeyPairGenerationState" id="apidoc.element.node-forge.rsa.stepKeyPairGenerationState">
        function <span class="apidocSignatureSpan">node-forge.rsa.</span>stepKeyPairGenerationState
        <span class="apidocSignatureSpan">(state, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stepKeyPairGenerationState = function (state, n) {
  // set default algorithm if not set
  if(!('algorithm' in state)) {
    state.algorithm = 'PRIMEINC';
  }

  // TODO: migrate step-based prime generation code to forge.prime
  // TODO: abstract as PRIMEINC algorithm

  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
  // with some minor optimizations and designed to run in steps

  // local state vars
  var THIRTY = new BigInteger(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or = function(x, y) { return x|y; };

  // keep stepping until time limit is reached or done
  var t1 = +new Date();
  var t2;
  var total = 0;
  while(state.keys === null &amp;&amp; (n &lt;= 0 || total &lt; n)) {
    // generate p or q
    if(state.state === 0) {
<span class="apidocCodeCommentSpan">      /* Note: All primes are of the form:

        30k+i, for i &lt; 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */
</span>      var bits = (state.p === null) ? state.pBits : state.qBits;
      var bits1 = bits - 1;

      // get a random number
      if(state.pqState === 0) {
        state.num = new BigInteger(bits, state.rng);
        // force MSB set
        if(!state.num.testBit(bits1)) {
          state.num.bitwiseTo(
            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
        }
        // align number on 30k+1 boundary
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;

        ++state.pqState;
      } else if(state.pqState === 1) {
        // try to make the number a prime
        if(state.num.bitLength() &gt; bits) {
          // overflow, try again
          state.pqState = 0;
          // do primality test
        } else if(state.num.isProbablePrime(
          _getMillerRabinTests(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          // get next potential prime
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if(state.pqState === 2) {
        // ensure number is coprime with e
        state.pqState =
          (state.num.subtract(BigInteger.ONE).gcd(state.e)
          .compareTo(BigInteger.ONE) === 0) ? 3 : 0;
      } else if(state.pqState === 3) {
        // store p or q
        state.pqState = 0;
        if(state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }

        // advance state if both p and q are ready
        if(state.p !== null &amp;&amp; state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if(state.state === 1) {
      // ensure p is larger than q (swap them if not)
      if(state.p.compareTo(state.q) &lt; 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if(state.state === 2) {
      // compute phi: (p - 1)(q - 1) (Euler's totient function)
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if(state.state === 3) {
      // ensure e and phi are coprime
      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
        // phi and e are coprime, advance
        ++state.state;
      } else {
        // phi and e aren't coprime, so generate a new p and q
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 4) {
      // create n, ensure n is has the right number of bits
      state.n = state.p.multiply(state.q);

      // ensure n is right number of bits
      if(state.n.bitLength() === state.bits) {
        // success, advance
        ++state.state;
      } else {
        // failed, get new q
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 5) {
      // set keys
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// generate an RSA key pair in steps that attempt to run for a specified period
// of time on the main JS thread
var state = rsa.createKeyPairGenerationState(2048, 0x10001);
var step = function() {
  // run for 100 ms
  if(!rsa.<span class="apidocCodeKeywordSpan">stepKeyPairGenerationState</span>(state, 100)) {
    setTimeout(step, 1);
  }
  else {
    // done, turn off progress indicator, use state.keys
  }
};
// turn on progress indicator, schedule generation to run
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha1" id="apidoc.module.node-forge.sha1">module node-forge.sha1</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha1.create" id="apidoc.element.node-forge.sha1.create">
        function <span class="apidocSignatureSpan">node-forge.sha1.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-1 state contains five 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(80);

  // message digest object
  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

<span class="apidocCodeCommentSpan">  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
</span>  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i &lt; int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) &gt;&gt;&gt; 0, len &gt;&gt;&gt; 0];
    for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) &gt;&gt;&gt; 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] &gt;&gt;&gt; 0;
      len[0] = ((len[1] / 0x100000000) &gt;&gt;&gt; 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read &gt; 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

   /**
    * Produces the digest.
    *
    * @return a byte buffer containing the digest value.
    */
   md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha256" id="apidoc.module.node-forge.sha256">module node-forge.sha256</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha256.create" id="apidoc.element.node-forge.sha256.create">
        function <span class="apidocSignatureSpan">node-forge.sha256.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-256 state contains eight 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(64);

  // message digest object
  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

<span class="apidocCodeCommentSpan">  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
</span>  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i &lt; int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) &gt;&gt;&gt; 0, len &gt;&gt;&gt; 0];
    for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) &gt;&gt;&gt; 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] &gt;&gt;&gt; 0;
      len[0] = ((len[1] / 0x100000000) &gt;&gt;&gt; 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read &gt; 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for ov ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha384" id="apidoc.module.node-forge.sha384">module node-forge.sha384</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha384.create" id="apidoc.element.node-forge.sha384.create">
        function <span class="apidocSignatureSpan">node-forge.sha384.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  return sha512.create('SHA-384');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha512" id="apidoc.module.node-forge.sha512">module node-forge.sha512</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha512.create" id="apidoc.element.node-forge.sha512.create">
        function <span class="apidocSignatureSpan">node-forge.sha512.</span>create
        <span class="apidocSignatureSpan">(algorithm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (algorithm) {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  if(typeof algorithm === 'undefined') {
    algorithm = 'SHA-512';
  }

  if(!(algorithm in _states)) {
    throw new Error('Invalid SHA-512 algorithm: ' + algorithm);
  }

  // SHA-512 state contains eight 64-bit integers (each as two 32-bit ints)
  var _state = _states[algorithm];
  var _h = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for 64-bit word storage
  var _w = new Array(80);
  for(var wi = 0; wi &lt; 80; ++wi) {
    _w[wi] = new Array(2);
  }

  // determine digest length by algorithm name (default)
  var digestLength = 64;
  switch (algorithm) {
    case 'SHA-384':
      digestLength = 48;
      break;
    case 'SHA-512/256':
      digestLength = 32;
      break;
    case 'SHA-512/224':
      digestLength = 28;
      break;
  }

  // message digest object
  var md = {
    // SHA-512 =&gt; sha512
    algorithm: algorithm.replace('-', '').toLowerCase(),
    blockLength: 128,
    digestLength: digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };

<span class="apidocCodeCommentSpan">  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
</span>  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength128 for backwards-compatibility)
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i &lt; int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _h = new Array(_state.length);
    for(var i = 0; i &lt; _state.length; ++i) {
      _h[i] = _state[i].slice(0);
    }
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) &gt;&gt;&gt; 0, len &gt;&gt;&gt; 0];
    for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) &gt;&gt;&gt; 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] &gt;&gt;&gt; 0;
      len[0] = ((len[1] / 0x100000000) &gt;&gt;&gt; 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_h, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read &gt; 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-512 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 896 mod 1024. In other words,
    the data to be digested must be a multiple of 1024 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 16 bytes (128
    bits), that means that the last segment of the data must have 112 bytes
    (896 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 896 mod 1024 bec ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha512.sha224" id="apidoc.module.node-forge.sha512.sha224">module node-forge.sha512.sha224</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha512.sha224.create" id="apidoc.element.node-forge.sha512.sha224.create">
        function <span class="apidocSignatureSpan">node-forge.sha512.sha224.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  return sha512.create('SHA-512/224');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.sha512.sha256" id="apidoc.module.node-forge.sha512.sha256">module node-forge.sha512.sha256</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.sha512.sha256.create" id="apidoc.element.node-forge.sha512.sha256.create">
        function <span class="apidocSignatureSpan">node-forge.sha512.sha256.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  return sha512.create('SHA-512/256');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3DES key and IV sizes
var keySize = 24;
var ivSize = 8;

// get derived bytes
// Notes:
// 1. If using an alternative hash (eg: "-md sha1") pass
//   "forge.md.sha1.<span class="apidocCodeKeywordSpan">create</span>()" as the final parameter.
// 2. If using "-nosalt", set salt to null.
var salt = forge.random.getBytesSync(8);
// var md = forge.md.sha1.create(); // "-md sha1"
var derivedBytes = forge.pbe.opensslDeriveBytes(
  password, salt, keySize + ivSize/*, md*/);
var buffer = forge.util.createBuffer(derivedBytes);
var key = buffer.getBytes(keySize);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.ssh" id="apidoc.module.node-forge.ssh">module node-forge.ssh</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.ssh.getPublicKeyFingerprint" id="apidoc.element.node-forge.ssh.getPublicKeyFingerprint">
        function <span class="apidocSignatureSpan">node-forge.ssh.</span>getPublicKeyFingerprint
        <span class="apidocSignatureSpan">(key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicKeyFingerprint = function (key, options) {
  options = options || {};
  var md = options.md || forge.md.md5.create();

  var type = 'ssh-rsa';
  var buffer = forge.util.createBuffer();
  _addStringToBuffer(buffer, type);
  _addBigIntegerToBuffer(buffer, key.e);
  _addBigIntegerToBuffer(buffer, key.n);

  // hash public key bytes
  md.start();
  md.update(buffer.getBytes());
  var digest = md.digest();
  if(options.encoding === 'hex') {
    var hex = digest.toHex();
    if(options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if(options.encoding === 'binary') {
    return digest.getBytes();
  } else if(options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// encodes a public RSA key as an OpenSSH file
forge.ssh.publicKeyToOpenSSH(key, comment);

// encodes a private RSA key as an OpenSSH file
forge.ssh.privateKeyToOpenSSH(privateKey, passphrase);

// gets the SSH public key fingerprint in a byte buffer
forge.ssh.<span class="apidocCodeKeywordSpan">getPublicKeyFingerprint</span>(key);

// gets a hex-encoded, colon-delimited SSH public key fingerprint
forge.ssh.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});
```

&lt;a name="xhr" /&gt;
### XHR
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.ssh.privateKeyToOpenSSH" id="apidoc.element.node-forge.ssh.privateKeyToOpenSSH">
        function <span class="apidocSignatureSpan">node-forge.ssh.</span>privateKeyToOpenSSH
        <span class="apidocSignatureSpan">(privateKey, passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyToOpenSSH = function (privateKey, passphrase) {
  if(!passphrase) {
    return forge.pki.privateKeyToPem(privateKey);
  }
  // OpenSSH private key is just a legacy format, it seems
  return forge.pki.encryptRsaPrivateKey(privateKey, passphrase,
    {legacy: true, algorithm: 'aes128'});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// encodes (and optionally encrypts) a private RSA key as a Putty PPK file
forge.ssh.privateKeyToPutty(privateKey, passphrase, comment);

// encodes a public RSA key as an OpenSSH file
forge.ssh.publicKeyToOpenSSH(key, comment);

// encodes a private RSA key as an OpenSSH file
forge.ssh.<span class="apidocCodeKeywordSpan">privateKeyToOpenSSH</span>(privateKey, passphrase);

// gets the SSH public key fingerprint in a byte buffer
forge.ssh.getPublicKeyFingerprint(key);

// gets a hex-encoded, colon-delimited SSH public key fingerprint
forge.ssh.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.ssh.privateKeyToPutty" id="apidoc.element.node-forge.ssh.privateKeyToPutty">
        function <span class="apidocSignatureSpan">node-forge.ssh.</span>privateKeyToPutty
        <span class="apidocSignatureSpan">(privateKey, passphrase, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateKeyToPutty = function (privateKey, passphrase, comment) {
  comment = comment || '';
  passphrase = passphrase || '';
  var algorithm = 'ssh-rsa';
  var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';

  var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\r\n';
  ppk += 'Encryption: ' + encryptionAlgorithm + '\r\n';
  ppk += 'Comment: ' + comment + '\r\n';

  // public key into buffer for ppk
  var pubbuffer = forge.util.createBuffer();
  _addStringToBuffer(pubbuffer, algorithm);
  _addBigIntegerToBuffer(pubbuffer, privateKey.e);
  _addBigIntegerToBuffer(pubbuffer, privateKey.n);

  // write public key
  var pub = forge.util.encode64(pubbuffer.bytes(), 64);
  var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \r\n
  ppk += 'Public-Lines: ' + length + '\r\n';
  ppk += pub;

  // private key into a buffer
  var privbuffer = forge.util.createBuffer();
  _addBigIntegerToBuffer(privbuffer, privateKey.d);
  _addBigIntegerToBuffer(privbuffer, privateKey.p);
  _addBigIntegerToBuffer(privbuffer, privateKey.q);
  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);

  // optionally encrypt the private key
  var priv;
  if(!passphrase) {
    // use the unencrypted buffer
    priv = forge.util.encode64(privbuffer.bytes(), 64);
  } else {
    // encrypt RSA key using passphrase
    var encLen = privbuffer.length() + 16 - 1;
    encLen -= encLen % 16;

    // pad private key with sha1-d data -- needs to be a multiple of 16
    var padding = _sha1(privbuffer.bytes());

    padding.truncate(padding.length() - encLen + privbuffer.length());
    privbuffer.putBuffer(padding);

    var aeskey = forge.util.createBuffer();
    aeskey.putBuffer(_sha1('\x00\x00\x00\x00', passphrase));
    aeskey.putBuffer(_sha1('\x00\x00\x00\x01', passphrase));

    // encrypt some bytes using CBC mode
    // key is 40 bytes, so truncate *by* 8 bytes
    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');
    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
    cipher.update(privbuffer.copy());
    cipher.finish();
    var encrypted = cipher.output;

    // Note: this appears to differ from Putty -- is forge wrong, or putty?
    // due to padding we finish as an exact multiple of 16
    encrypted.truncate(16); // all padding

    priv = forge.util.encode64(encrypted.bytes(), 64);
  }

  // output private key
  length = Math.floor(priv.length / 66) + 1; // 64 + \r\n
  ppk += '\r\nPrivate-Lines: ' + length + '\r\n';
  ppk += priv;

  // MAC
  var mackey = _sha1('putty-private-key-file-mac-key', passphrase);

  var macbuffer = forge.util.createBuffer();
  _addStringToBuffer(macbuffer, algorithm);
  _addStringToBuffer(macbuffer, encryptionAlgorithm);
  _addStringToBuffer(macbuffer, comment);
  macbuffer.putInt32(pubbuffer.length());
  macbuffer.putBuffer(pubbuffer);
  macbuffer.putInt32(privbuffer.length());
  macbuffer.putBuffer(privbuffer);

  var hmac = forge.hmac.create();
  hmac.start('sha1', mackey);
  hmac.update(macbuffer.bytes());

  ppk += '\r\nPrivate-MAC: ' + hmac.digest().toHex() + '\r\n';

  return ppk;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Provides some SSH utility functions.

__Examples__

```js
// encodes (and optionally encrypts) a private RSA key as a Putty PPK file
forge.ssh.<span class="apidocCodeKeywordSpan">privateKeyToPutty</span>(privateKey, passphrase, comment);

// encodes a public RSA key as an OpenSSH file
forge.ssh.publicKeyToOpenSSH(key, comment);

// encodes a private RSA key as an OpenSSH file
forge.ssh.privateKeyToOpenSSH(privateKey, passphrase);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.ssh.publicKeyToOpenSSH" id="apidoc.element.node-forge.ssh.publicKeyToOpenSSH">
        function <span class="apidocSignatureSpan">node-forge.ssh.</span>publicKeyToOpenSSH
        <span class="apidocSignatureSpan">(key, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicKeyToOpenSSH = function (key, comment) {
  var type = 'ssh-rsa';
  comment = comment || '';

  var buffer = forge.util.createBuffer();
  _addStringToBuffer(buffer, type);
  _addBigIntegerToBuffer(buffer, key.e);
  _addBigIntegerToBuffer(buffer, key.n);

  return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__Examples__

```js
// encodes (and optionally encrypts) a private RSA key as a Putty PPK file
forge.ssh.privateKeyToPutty(privateKey, passphrase, comment);

// encodes a public RSA key as an OpenSSH file
forge.ssh.<span class="apidocCodeKeywordSpan">publicKeyToOpenSSH</span>(key, comment);

// encodes a private RSA key as an OpenSSH file
forge.ssh.privateKeyToOpenSSH(privateKey, passphrase);

// gets the SSH public key fingerprint in a byte buffer
forge.ssh.getPublicKeyFingerprint(key);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.task" id="apidoc.module.node-forge.task">module node-forge.task</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.task.cancel" id="apidoc.element.node-forge.task.cancel">
        function <span class="apidocSignatureSpan">node-forge.task.</span>cancel
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancel = function (type) {
  // find the task queue
  if(type in sTaskQueues) {
    // empty all but the current task from the queue
    sTaskQueues[type] = [sTaskQueues[type][0]];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.task.createCondition" id="apidoc.element.node-forge.task.createCondition">
        function <span class="apidocSignatureSpan">node-forge.task.</span>createCondition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCondition = function () {
  var cond = {
    // all tasks that are blocked
    tasks: {}
  };

<span class="apidocCodeCommentSpan">  /**
   * Causes the given task to block until notify is called. If the task
   * is already waiting on this condition then this is a no-op.
   *
   * @param task the task to cause to wait.
   */
</span>  cond.wait = function(task) {
    // only block once
    if(!(task.id in cond.tasks)) {
       task.block();
       cond.tasks[task.id] = task;
    }
  };

  /**
   * Notifies all waiting tasks to wake up.
   */
  cond.notify = function() {
    // since unblock() will run the next task from here, make sure to
    // clear the condition's blocked task list before unblocking
    var tmp = cond.tasks;
    cond.tasks = {};
    for(var id in tmp) {
      tmp[id].unblock();
    }
  };

  return cond;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  runNext(self, 0);
}, n);
};

/**
 * Waits on a condition variable until notified. The next task will
 * not be scheduled until notification. A condition variable can be
 * created with forge.task.<span class="apidocCodeKeywordSpan">createCondition</span>().
 *
 * Once cond.notify() is called, the task will continue.
 *
 * @param cond the condition variable to wait on.
 */
Task.prototype.wait = function(cond) {
cond.wait(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.task.start" id="apidoc.element.node-forge.task.start">
        function <span class="apidocSignatureSpan">node-forge.task.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (options) {
  // create a new task
  var task = new Task({
    run: options.run,
    name: options.name || sNoTaskName
  });
  task.type = options.type;
  task.successCallback = options.success || null;
  task.failureCallback = options.failure || null;

  // append the task onto the appropriate queue
  if(!(task.type in sTaskQueues)) {
    if(sVL &gt;= 1) {
      forge.log.verbose(cat, '[%s][%s] create queue [%s]',
        task.id, task.name, task.type);
    }
    // create the queue with the new task
    sTaskQueues[task.type] = [task];
    start(task);
  } else {
    // push the task onto the queue, it will be run after a task
    // with the same type completes
    sTaskQueues[options.type].push(task);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
*/

// encrypt some bytes using CBC mode
// (other modes include: ECB, CFB, OFB, CTR, and GCM)
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.<span class="apidocCodeKeywordSpan">start</span>({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.toHex());

// decrypt some bytes using CBC mode
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.tls" id="apidoc.module.node-forge.tls">module node-forge.tls</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.tls.createConnection" id="apidoc.element.node-forge.tls.createConnection">
        function <span class="apidocSignatureSpan">node-forge.tls.</span>createConnection
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function (options) {
  var caStore = null;
  if(options.caStore) {
    // if CA store is an array, convert it to a CA store object
    if(forge.util.isArray(options.caStore)) {
      caStore = forge.pki.createCaStore(options.caStore);
    } else {
      caStore = options.caStore;
    }
  } else {
    // create empty CA store
    caStore = forge.pki.createCaStore();
  }

  // setup default cipher suites
  var cipherSuites = options.cipherSuites || null;
  if(cipherSuites === null) {
    cipherSuites = [];
    for(var key in tls.CipherSuites) {
      cipherSuites.push(tls.CipherSuites[key]);
    }
  }

  // set default entity
  var entity = (options.server || false) ?
    tls.ConnectionEnd.server : tls.ConnectionEnd.client;

  // create session cache if requested
  var sessionCache = options.sessionCache ?
    tls.createSessionCache(options.sessionCache) : null;

  // create TLS connection
  var c = {
    version: {major: tls.Version.major, minor: tls.Version.minor},
    entity: entity,
    sessionId: options.sessionId,
    caStore: caStore,
    sessionCache: sessionCache,
    cipherSuites: cipherSuites,
    connected: options.connected,
    virtualHost: options.virtualHost || null,
    verifyClient: options.verifyClient || false,
    verify: options.verify || function(cn, vfd, dpth, cts) {return vfd;},
    getCertificate: options.getCertificate || null,
    getPrivateKey: options.getPrivateKey || null,
    getSignature: options.getSignature || null,
    input: forge.util.createBuffer(),
    tlsData: forge.util.createBuffer(),
    data: forge.util.createBuffer(),
    tlsDataReady: options.tlsDataReady,
    dataReady: options.dataReady,
    heartbeatReceived: options.heartbeatReceived,
    closed: options.closed,
    error: function(c, ex) {
      // set origin if not set
      ex.origin = ex.origin ||
        ((c.entity === tls.ConnectionEnd.client) ? 'client' : 'server');

      // send TLS alert
      if(ex.send) {
        tls.queue(c, tls.createAlert(c, ex.alert));
        tls.flush(c);
      }

      // error is fatal by default
      var fatal = (ex.fatal !== false);
      if(fatal) {
        // set fail flag
        c.fail = true;
      }

      // call error handler first
      options.error(c, ex);

      if(fatal) {
        // fatal error, close connection, do not clear fail
        c.close(false);
      }
    },
    deflate: options.deflate || null,
    inflate: options.inflate || null
  };

<span class="apidocCodeCommentSpan">  /**
   * Resets a closed TLS connection for reuse. Called in c.close().
   *
   * @param clearFail true to clear the fail flag (default: true).
   */
</span>  c.reset = function(clearFail) {
    c.version = {major: tls.Version.major, minor: tls.Version.minor};
    c.record = null;
    c.session = null;
    c.peerCertificate = null;
    c.state = {
      pending: null,
      current: null
    };
    c.expect = (c.entity === tls.ConnectionEnd.client) ? SHE : CHE;
    c.fragmented = null;
    c.records = [];
    c.open = false;
    c.handshakes = 0;
    c.handshaking = false;
    c.isConnected = false;
    c.fail = !(clearFail || typeof(clearFail) === 'undefined');
    c.input.clear();
    c.tlsData.clear();
    c.data.clear();
    c.state.current = tls.createConnectionState(c);
  };

  // do initial reset of connection
  c.reset();

  /**
   * Updates the current TLS engine state based on the given record.
   *
   * @param c the TLS connection.
   * @param record the TLS record to act on.
   */
  var _update = function(c, record) {
    // get record handler (align type in table by subtracting lowest)
    var aligned = record.type - tls.ContentType.change_cipher_spec;
    var handlers = ctTable[c.entity][c.expect];
    if(aligned in handlers) {
      handlers[aligned](c, record);
    } else {
      // unexpected record
      tls.handleUnexpected(c, record);
    }
  };

  /**
   * Reads the record header and initializes the next record on the given
   * connection.
   *
   * @param c the TLS connection with the next record.
   *
   * @return 0 if the input data could be processed, otherwise the
   *         number of bytes required fo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Provides a native javascript client and server-side [TLS][] implementation.

__Examples__

```js
// create TLS client
var client = forge.tls.<span class="apidocCodeKeywordSpan">createConnection</span>({
server: false,
caStore: /* Array of PEM-formatted certs or a CA store object */,
sessionCache: {},
// supported cipher suites in order of preference
cipherSuites: [
  forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,
  forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.tls.createSessionCache" id="apidoc.element.node-forge.tls.createSessionCache">
        function <span class="apidocSignatureSpan">node-forge.tls.</span>createSessionCache
        <span class="apidocSignatureSpan">(cache, capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSessionCache = function (cache, capacity) {
  var rval = null;

  // assume input is already a session cache object
  if(cache &amp;&amp; cache.getSession &amp;&amp; cache.setSession &amp;&amp; cache.order) {
    rval = cache;
  } else {
    // create cache
    rval = {};
    rval.cache = cache || {};
    rval.capacity = Math.max(capacity || 100, 1);
    rval.order = [];

    // store order for sessions, delete session overflow
    for(var key in cache) {
      if(rval.order.length &lt;= capacity) {
        rval.order.push(key);
      } else {
        delete cache[key];
      }
    }

    // get a session from a session ID (or get any session)
    rval.getSession = function(sessionId) {
      var session = null;
      var key = null;

      // if session ID provided, use it
      if(sessionId) {
        key = forge.util.bytesToHex(sessionId);
      } else if(rval.order.length &gt; 0) {
        // get first session from cache
        key = rval.order[0];
      }

      if(key !== null &amp;&amp; key in rval.cache) {
        // get cached session and remove from cache
        session = rval.cache[key];
        delete rval.cache[key];
        for(var i in rval.order) {
          if(rval.order[i] === key) {
            rval.order.splice(i, 1);
            break;
          }
        }
      }

      return session;
    };

    // set a session in the cache
    rval.setSession = function(sessionId, session) {
      // remove session from cache if at capacity
      if(rval.order.length === rval.capacity) {
        var key = rval.order.shift();
        delete rval.cache[key];
      }
      // add session to cache
      var key = forge.util.bytesToHex(sessionId);
      rval.order.push(key);
      rval.cache[key] = session;
    };
  }

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// set default entity
var entity = (options.server || false) ?
  tls.ConnectionEnd.server : tls.ConnectionEnd.client;

// create session cache if requested
var sessionCache = options.sessionCache ?
  tls.<span class="apidocCodeKeywordSpan">createSessionCache</span>(options.sessionCache) : null;

// create TLS connection
var c = {
  version: {major: tls.Version.major, minor: tls.Version.minor},
  entity: entity,
  sessionId: options.sessionId,
  caStore: caStore,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.tls.hmac_sha1" id="apidoc.element.node-forge.tls.hmac_sha1">
        function <span class="apidocSignatureSpan">node-forge.tls.</span>hmac_sha1
        <span class="apidocSignatureSpan">(key, seqNum, record)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hmac_sha1 = function (key, seqNum, record) {
<span class="apidocCodeCommentSpan">  /* MAC is computed like so:
  HMAC_hash(
    key, seqNum +
      TLSCompressed.type +
      TLSCompressed.version +
      TLSCompressed.length +
      TLSCompressed.fragment)
  */
</span>  var hmac = forge.hmac.create();
  hmac.start('SHA1', key);
  var b = forge.util.createBuffer();
  b.putInt32(seqNum[0]);
  b.putInt32(seqNum[1]);
  b.putByte(record.type);
  b.putByte(record.version.major);
  b.putByte(record.version.minor);
  b.putInt16(record.length);
  b.putBytes(record.fragment.bytes());
  hmac.update(b.getBytes());
  return hmac.digest().getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.tls.prf_tls1" id="apidoc.element.node-forge.tls.prf_tls1">
        function <span class="apidocSignatureSpan">node-forge.tls.</span>prf_tls1
        <span class="apidocSignatureSpan">(secret, label, seed, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prf_tls1 = function (secret, label, seed, length) {
  var rval = forge.util.createBuffer();

<span class="apidocCodeCommentSpan">  /* For TLS 1.0, the secret is split in half, into two secrets of equal
    length. If the secret has an odd length then the last byte of the first
    half will be the same as the first byte of the second. The length of the
    two secrets is half of the secret rounded up. */
</span>  var idx = (secret.length &gt;&gt; 1);
  var slen = idx + (secret.length &amp; 1);
  var s1 = secret.substr(0, slen);
  var s2 = secret.substr(idx, slen);
  var ai = forge.util.createBuffer();
  var hmac = forge.hmac.create();
  seed = label + seed;

  // determine the number of iterations that must be performed to generate
  // enough output bytes, md5 creates 16 byte hashes, sha1 creates 20
  var md5itr = Math.ceil(length / 16);
  var sha1itr = Math.ceil(length / 20);

  // do md5 iterations
  hmac.start('MD5', s1);
  var md5bytes = forge.util.createBuffer();
  ai.putBytes(seed);
  for(var i = 0; i &lt; md5itr; ++i) {
    // HMAC_hash(secret, A(i-1))
    hmac.start(null, null);
    hmac.update(ai.getBytes());
    ai.putBuffer(hmac.digest());

    // HMAC_hash(secret, A(i) + seed)
    hmac.start(null, null);
    hmac.update(ai.bytes() + seed);
    md5bytes.putBuffer(hmac.digest());
  }

  // do sha1 iterations
  hmac.start('SHA1', s2);
  var sha1bytes = forge.util.createBuffer();
  ai.clear();
  ai.putBytes(seed);
  for(var i = 0; i &lt; sha1itr; ++i) {
    // HMAC_hash(secret, A(i-1))
    hmac.start(null, null);
    hmac.update(ai.getBytes());
    ai.putBuffer(hmac.digest());

    // HMAC_hash(secret, A(i) + seed)
    hmac.start(null, null);
    hmac.update(ai.bytes() + seed);
    sha1bytes.putBuffer(hmac.digest());
  }

  // XOR the md5 bytes with the sha1 bytes
  rval.putBytes(forge.util.xorBytes(
    md5bytes.getBytes(), sha1bytes.getBytes(), length));

  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.tls.wrapSocket" id="apidoc.element.node-forge.tls.wrapSocket">
        function <span class="apidocSignatureSpan">node-forge.tls.</span>wrapSocket
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapSocket = function (options) {
  // get raw socket
  var socket = options.socket;

  // create TLS socket
  var tlsSocket = {
    id: socket.id,
    // set handlers
    connected: socket.connected || function(e) {},
    closed: socket.closed || function(e) {},
    data: socket.data || function(e) {},
    error: socket.error || function(e) {}
  };

  // create TLS connection
  var c = forge.tls.createConnection({
    server: false,
    sessionId: options.sessionId || null,
    caStore: options.caStore || [],
    sessionCache: options.sessionCache || null,
    cipherSuites: options.cipherSuites || null,
    virtualHost: options.virtualHost,
    verify: options.verify,
    getCertificate: options.getCertificate,
    getPrivateKey: options.getPrivateKey,
    getSignature: options.getSignature,
    deflate: options.deflate,
    inflate: options.inflate,
    connected: function(c) {
      // first handshake complete, call handler
      if(c.handshakes === 1) {
        tlsSocket.connected({
          id: socket.id,
          type: 'connect',
          bytesAvailable: c.data.length()
        });
      }
    },
    tlsDataReady: function(c) {
      // send TLS data over socket
      return socket.send(c.tlsData.getBytes());
    },
    dataReady: function(c) {
      // indicate application data is ready
      tlsSocket.data({
        id: socket.id,
        type: 'socketData',
        bytesAvailable: c.data.length()
      });
    },
    closed: function(c) {
      // close socket
      socket.close();
    },
    error: function(c, e) {
      // send error, close socket
      tlsSocket.error({
        id: socket.id,
        type: 'tlsError',
        message: e.message,
        bytesAvailable: 0,
        error: e
      });
      socket.close();
    }
  });

  // handle doing handshake after connecting
  socket.connected = function(e) {
    c.handshake(options.sessionId);
  };

  // handle closing TLS connection
  socket.closed = function(e) {
    if(c.open &amp;&amp; c.handshaking) {
      // error
      tlsSocket.error({
        id: socket.id,
        type: 'ioError',
        message: 'Connection closed during handshake.',
        bytesAvailable: 0
      });
    }
    c.close();

    // call socket handler
    tlsSocket.closed({
      id: socket.id,
      type: 'close',
      bytesAvailable: 0
    });
  };

  // handle error on socket
  socket.error = function(e) {
    // error
    tlsSocket.error({
      id: socket.id,
      type: e.type,
      message: e.message,
      bytesAvailable: 0
    });
    c.close();
  };

  // handle receiving raw TLS data from socket
  var _requiredBytes = 0;
  socket.data = function(e) {
    // drop data if connection not open
    if(!c.open) {
      socket.receive(e.bytesAvailable);
    } else {
      // only receive if there are enough bytes available to
      // process a record
      if(e.bytesAvailable &gt;= _requiredBytes) {
        var count = Math.max(e.bytesAvailable, _requiredBytes);
        var data = socket.receive(count);
        if(data !== null) {
          _requiredBytes = c.process(data);
        }
      }
    }
  };

<span class="apidocCodeCommentSpan">  /**
   * Destroys this socket.
   */
</span>  tlsSocket.destroy = function() {
    socket.destroy();
  };

  /**
   * Sets this socket's TLS session cache. This should be called before
   * the socket is connected or after it is closed.
   *
   * The cache is an object mapping session IDs to internal opaque state.
   * An application might need to change the cache used by a particular
   * tlsSocket between connections if it accesses multiple TLS hosts.
   *
   * @param cache the session cache to use.
   */
  tlsSocket.setSessionCache = function(cache) {
    c.sessionCache = tls.createSessionCache(cache);
  };

  /**
   * Connects this socket.
   *
   * @param options:
   *           host: the host to connect to.
   *           port: the port to connect to.
   *           policyPort: the policy port to use (if non-default), 0 to
   *              use the flash default.
   *           policyUrl: the policy file URL to use (instead of port).
   */
  tlsSocket.connect = function(options) {
    socket ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    socket: socket
  });
  socket.close();
};

// wrap socket for TLS
if(tlsOptions) {
  socket = forge.tls.<span class="apidocCodeKeywordSpan">wrapSocket</span>({
    sessionId: null,
    sessionCache: {},
    caStore: tlsOptions.caStore,
    cipherSuites: tlsOptions.cipherSuites,
    socket: socket,
    virtualHost: tlsOptions.virtualHost,
    verify: tlsOptions.verify,
...</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.util" id="apidoc.module.node-forge.util">module node-forge.util</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer" id="apidoc.element.node-forge.util.ByteBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>ByteBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    // convert native buffer to forge buffer
    // FIXME: support native buffers internally instead
    var arr = new Uint8Array(b);
    try {
      this.data = String.fromCharCode.apply(null, arr);
    } catch(e) {
      for(var i = 0; i &lt; arr.length; ++i) {
        this.putByte(arr[i]);
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' &amp;&amp; typeof b.data === 'string' &amp;&amp;
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param x the binary-encoded byte string to generate a key from.
   * @param length the number of bytes to generate (the size of the key).
   *
   * @return the key as a binary-encoded string.
   */
  kdf.generate = function(x, length) {
var key = new forge.util.<span class="apidocCodeKeywordSpan">ByteBuffer</span>();

// run counter from counterStart to ceil(length / Hash.len)
var k = Math.ceil(length / digestLength) + counterStart;

var c = new forge.util.ByteBuffer();
for(var i = counterStart; i &lt; k; ++i) {
  // I2OSP(i, 4): convert counter to an octet string of 4 octets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteStringBuffer" id="apidoc.element.node-forge.util.ByteStringBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>ByteStringBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    // convert native buffer to forge buffer
    // FIXME: support native buffers internally instead
    var arr = new Uint8Array(b);
    try {
      this.data = String.fromCharCode.apply(null, arr);
    } catch(e) {
      for(var i = 0; i &lt; arr.length; ++i) {
        this.putByte(arr[i]);
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' &amp;&amp; typeof b.data === 'string' &amp;&amp;
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer" id="apidoc.element.node-forge.util.DataBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>DataBuffer
        <span class="apidocSignatureSpan">(b, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBuffer(b, options) {
  // default options
  options = options || {};

  // pointers for read from/write to buffer
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;

  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);
  if(isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if(isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = ('writeOffset' in options ?
      options.writeOffset : this.data.byteLength);
    return;
  }

  // initialize to empty array buffer and add any given bytes using putBytes
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if(b !== null &amp;&amp; b !== undefined) {
    this.putBytes(b);
  }

  if('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Creates a copy of this buffer.
*
* @return the copy.
*/
util.DataBuffer.prototype.copy = function() {
 return new util.<span class="apidocCodeKeywordSpan">DataBuffer</span>(this);
};

/**
* Compacts this buffer.
*
* @return this buffer.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesFromIP" id="apidoc.element.node-forge.util.bytesFromIP">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIP
        <span class="apidocSignatureSpan">(ip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesFromIP = function (ip) {
  if(ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }
  if(ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var altName;
for(var n = 0; n &lt; e.altNames.length; ++n) {
  altName = e.altNames[n];
  var value = altName.value;
  // handle IP
  if(altName.type === 7 &amp;&amp; altName.ip) {
    value = forge.util.<span class="apidocCodeKeywordSpan">bytesFromIP</span>(altName.ip);
    if(value === null) {
      var error = new Error(
        'Extension "ip" value is not a valid IPv4 or IPv6 address.');
      error.extension = e;
      throw error;
    }
  } else if(altName.type === 8) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesFromIPv4" id="apidoc.element.node-forge.util.bytesFromIPv4">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIPv4
        <span class="apidocSignatureSpan">(ip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesFromIPv4 = function (ip) {
  ip = ip.split('.');
  if(ip.length !== 4) {
    return null;
  }
  var b = util.createBuffer();
  for(var i = 0; i &lt; ip.length; ++i) {
    var num = parseInt(ip[i], 10);
    if(isNaN(num)) {
      return null;
    }
    b.putByte(num);
  }
  return b.getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */
util.bytesFromIP = function(ip) {
  if(ip.indexOf('.') !== -1) {
    return util.<span class="apidocCodeKeywordSpan">bytesFromIPv4</span>(ip);
  }
  if(ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }
  return null;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesFromIPv6" id="apidoc.element.node-forge.util.bytesFromIPv6">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesFromIPv6
        <span class="apidocSignatureSpan">(ip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesFromIPv6 = function (ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function(e) {
    if(e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();
  for(var i = 0; i &lt; 8; ++i) {
    if(!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes = util.hexToBytes(ip[i]);
    if(bytes.length &lt; 2) {
      b.putByte(0);
    }
    b.putBytes(bytes);
  }
  return b.getBytes();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         be parsed.
*/
util.bytesFromIP = function(ip) {
 if(ip.indexOf('.') !== -1) {
   return util.bytesFromIPv4(ip);
 }
 if(ip.indexOf(':') !== -1) {
   return util.<span class="apidocCodeKeywordSpan">bytesFromIPv6</span>(ip);
 }
 return null;
};

/**
* Converts an IPv4 string representation into bytes (in network order).
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesToHex" id="apidoc.element.node-forge.util.bytesToHex">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToHex
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesToHex = function (bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
be used automatically.

__Examples__

```js
// get some random bytes synchronously
var bytes = forge.random.getBytesSync(32);
console.log(forge.util.<span class="apidocCodeKeywordSpan">bytesToHex</span>(bytes));

// get some random bytes asynchronously
forge.random.getBytes(32, function(err, bytes) {
  console.log(forge.util.bytesToHex(bytes));
});

// collect some entropy if you'd like
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesToIP" id="apidoc.element.node-forge.util.bytesToIP">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIP
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesToIP = function (bytes) {
  if(bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }
  if(bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2:
// uniformResourceIdentifier (URI)
case 6:
  break;
// IPAddress
case 7:
  // convert to IPv4/IPv6 string representation
  altName.ip = forge.util.<span class="apidocCodeKeywordSpan">bytesToIP</span>(gn.value);
  break;
// registeredID
case 8:
  altName.oid = asn1.derToOid(gn.value);
  break;
default:
  // unsupported
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesToIPv4" id="apidoc.element.node-forge.util.bytesToIPv4">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIPv4
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesToIPv4 = function (bytes) {
  if(bytes.length !== 4) {
    return null;
  }
  var ip = [];
  for(var i = 0; i &lt; bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }
  return ip.join('.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */
util.bytesToIP = function(bytes) {
  if(bytes.length === 4) {
    return util.<span class="apidocCodeKeywordSpan">bytesToIPv4</span>(bytes);
  }
  if(bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }
  return null;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.bytesToIPv6" id="apidoc.element.node-forge.util.bytesToIPv6">
        function <span class="apidocSignatureSpan">node-forge.util.</span>bytesToIPv6
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytesToIPv6 = function (bytes) {
  if(bytes.length !== 16) {
    return null;
  }
  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for(var i = 0; i &lt; bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
    // canonicalize zero representation
    while(hex[0] === '0' &amp;&amp; hex !== '0') {
      hex = hex.substr(1);
    }
    if(hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;
      if(!last || idx !== last.end + 1) {
        zeroGroups.push({start: idx, end: idx});
      } else {
        last.end = idx;
        if((last.end - last.start) &gt;
          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip.push(hex);
  }
  if(zeroGroups.length &gt; 0) {
    var group = zeroGroups[zeroMaxGroup];
    // only shorten group of length &gt; 0
    if(group.end - group.start &gt; 0) {
      ip.splice(group.start, group.end - group.start + 1, '');
      if(group.start === 0) {
        ip.unshift('');
      }
      if(group.end === 7) {
        ip.push('');
      }
    }
  }
  return ip.join(':');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         respectively, are given, otherwise null.
*/
util.bytesToIP = function(bytes) {
 if(bytes.length === 4) {
   return util.bytesToIPv4(bytes);
 }
 if(bytes.length === 16) {
   return util.<span class="apidocCodeKeywordSpan">bytesToIPv6</span>(bytes);
 }
 return null;
};

/**
* Converts 4-bytes into an IPv4 string representation. The bytes must be
* in network order.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.clearItems" id="apidoc.element.node-forge.util.clearItems">
        function <span class="apidocSignatureSpan">node-forge.util.</span>clearItems
        <span class="apidocSignatureSpan">(api, id, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearItems = function (api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param client the client.
 */
var _clearCookies = function(client) {
if(client.persistCookies) {
  try {
    // only thing stored is 'cookies', so clear whole storage
    forge.util.<span class="apidocCodeKeywordSpan">clearItems</span>(
      client.socketPool.flashApi,
      _getStorageId(client));
  } catch(ex) {
    // no flash storage available, just silently fail
    // TODO: i assume we want this logged somewhere or
    // should it actually generate an error
    //forge.log.error(cat, ex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.createBuffer" id="apidoc.element.node-forge.util.createBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>createBuffer
        <span class="apidocSignatureSpan">(input, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBuffer = function (input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';
  if(input !== undefined &amp;&amp; encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }
  return new util.ByteBuffer(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
connected: function(connection) {
  console.log('connected');
  // send message to server
  connection.prepare(forge.util.encodeUtf8('Hi server!'));
  /* NOTE: experimental, start heartbeat retransmission timer
  myHeartbeatTimer = setInterval(function() {
    connection.prepareHeartbeatRequest(forge.util.<span class="apidocCodeKeywordSpan">createBuffer</span>('1234'));
  }, 5*60*1000);*/
},
/* provide a client-side cert if you want
getCertificate: function(connection, hint) {
  return myClientCertificate;
},
/* the private key for the client-side cert if provided */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.decode64" id="apidoc.element.node-forge.util.decode64">
        function <span class="apidocSignatureSpan">node-forge.util.</span>decode64
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode64 = function (input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."

  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while(i &lt; input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

    output += String.fromCharCode((enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4));
    if(enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode(((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2));
      if(enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode(((enc3 &amp; 3) &lt;&lt; 6) | enc4);
      }
    }
  }

  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a PKCS#12 container, try using the TripleDES algorithm. It can be passed
to `forge.pkcs12.toPkcs12Asn1` using the `{algorithm: '3des'}` option.

__Examples__

```js
// decode p12 from base64
var p12Der = forge.util.<span class="apidocCodeKeywordSpan">decode64</span>(p12b64);
// get p12 as ASN.1 object
var p12Asn1 = forge.asn1.fromDer(p12Der);
// decrypt p12 using the password 'password'
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'password');
// decrypt p12 using non-strict parsing mode (resolves some ASN.1 parse errors)
var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, 'password');
// decrypt p12 using literally no password (eg: Mac OS X/apple push)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.decodeUtf8" id="apidoc.element.node-forge.util.decodeUtf8">
        function <span class="apidocSignatureSpan">node-forge.util.</span>decodeUtf8
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeUtf8 = function (str) {
  return decodeURIComponent(escape(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sendToServerSomehow(connection.tlsData.getBytes());
  // if you were communicating with the server below, you'd do:
  // server.process(connection.tlsData.getBytes());
},
dataReady: function(connection) {
  // clear data from the server is ready
  console.log('the server sent: ' +
    forge.util.<span class="apidocCodeKeywordSpan">decodeUtf8</span>(connection.data.getBytes()));
  // close connection
  connection.close();
},
/* NOTE: experimental
heartbeatReceived: function(connection, payload) {
  // restart retransmission timer, look at payload
  clearInterval(myHeartbeatTimer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.deflate" id="apidoc.element.node-forge.util.deflate">
        function <span class="apidocSignatureSpan">node-forge.util.</span>deflate
        <span class="apidocSignatureSpan">(api, bytes, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflate = function (api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);

  // strip zlib header and trailer if necessary
  if(raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);
    if(flg &amp; 0x20) {
      start = 6;
    }
    // zlib trailer is 4 bytes of adler-32
    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    prime: options.primeTlsSockets || false
  };

  // if socket pool uses a flash api, then add deflate support to TLS
  if(sp.flashApi !== null) {
    tlsOptions.deflate = function(bytes) {
      // strip 2 byte zlib header and 4 byte trailer
      return forge.util.<span class="apidocCodeKeywordSpan">deflate</span>(sp.flashApi, bytes, true);
    };
    tlsOptions.inflate = function(bytes) {
      return forge.util.inflate(sp.flashApi, bytes, true);
    };
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.deletePath" id="apidoc.element.node-forge.util.deletePath">
        function <span class="apidocSignatureSpan">node-forge.util.</span>deletePath
        <span class="apidocSignatureSpan">(object, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deletePath = function (object, keys) {
  // need to start at an object
  if(typeof(object) === 'object' &amp;&amp; object !== null) {
    var i = 0;
    var len = keys.length;
    while(i &lt; len) {
      var next = keys[i++];
      if(i == len) {
        // last
        delete object[next];
      } else {
        // more
        if(!(next in object) ||
          (typeof(object[next]) !== 'object') ||
          (object[next] === null)) {
           break;
        }
        object = object[next];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.encode64" id="apidoc.element.node-forge.util.encode64">
        function <span class="apidocSignatureSpan">node-forge.util.</span>encode64
        <span class="apidocSignatureSpan">(input, maxline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode64 = function (input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;
  while(i &lt; input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    // encode 4 character group
    line += _base64.charAt(chr1 &gt;&gt; 2);
    line += _base64.charAt(((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4));
    if(isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt(((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6));
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 &amp; 63);
    }

    if(maxline &amp;&amp; line.length &gt; maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (requires the use of Triple DES instead of AES)
var p12Asn1 = forge.pkcs12.toPkcs12Asn1(
  privateKey, certificateChain, 'password',
  {algorithm: '3des'});

// base64-encode p12
var p12Der = forge.asn1.toDer(p12Asn1).getBytes();
var p12b64 = forge.util.<span class="apidocCodeKeywordSpan">encode64</span>(p12Der);

// create download link for p12
var a = document.createElement('a');
a.download = 'example.p12';
a.setAttribute('href', 'data:application/x-pkcs12;base64,' + p12b64);
a.appendChild(document.createTextNode('Download'));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.encodeUtf8" id="apidoc.element.node-forge.util.encodeUtf8">
        function <span class="apidocSignatureSpan">node-forge.util.</span>encodeUtf8
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeUtf8 = function (str) {
  return unescape(encodeURIComponent(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return verified;
},
connected: function(connection) {
  console.log('connected');
  // send message to server
  connection.prepare(forge.util.<span class="apidocCodeKeywordSpan">encodeUtf8</span>('Hi server!'));
  /* NOTE: experimental, start heartbeat retransmission timer
  myHeartbeatTimer = setInterval(function() {
    connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));
  }, 5*60*1000);*/
},
/* provide a client-side cert if you want
getCertificate: function(connection, hint) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.estimateCores" id="apidoc.element.node-forge.util.estimateCores">
        function <span class="apidocSignatureSpan">node-forge.util.</span>estimateCores
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">estimateCores = function (options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};
  if('cores' in util &amp;&amp; !options.update) {
    return callback(null, util.cores);
  }
  if(typeof navigator !== 'undefined' &amp;&amp;
    'hardwareConcurrency' in navigator &amp;&amp;
    navigator.hardwareConcurrency &gt; 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }
  if(typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }
  if(typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  }

  // create worker concurrency estimation code as blob
  var blobUrl = URL.createObjectURL(new Blob(['(',
    function() {
      self.addEventListener('message', function(e) {
        // run worker for 4 ms
        var st = Date.now();
        var et = st + 4;
        while(Date.now() &lt; et);
        self.postMessage({st: st, et: et});
      });
    }.toString(),
  ')()'], {type: 'application/javascript'}));

  // take 5 samples using 16 workers
  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if(samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function(avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }
    map(numWorkers, function(err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];
    for(var i = 0; i &lt; numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function(e) {
        results.push(e.data);
        if(results.length === numWorkers) {
          for(var i = 0; i &lt; numWorkers; ++i) {
            workers[i].terminate();
          }
          callback(null, results);
        }
      });
      workers.push(worker);
    }
    for(var i = 0; i &lt; numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];
    for(var n = 0; n &lt; numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for(var i = 0; i &lt; numWorkers; ++i) {
        if(n === i) {
          continue;
        }
        var r2 = results[i];
        if((r1.st &gt; r2.st &amp;&amp; r1.st &lt; r2.et) ||
          (r2.st &gt; r1.st &amp;&amp; r2.st &lt; r1.et)) {
          overlap.push(i);
        }
      }
    }
    // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway
    return overlaps.reduce(function(max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// use web workers to generate keys
var numWorkers = options.workers;
var workLoad = options.workLoad || 100;
var range = workLoad * 30 / 8;
var workerScript = options.workerScript || 'forge/prime.worker.js';
if(numWorkers === -1) {
  return forge.util.<span class="apidocCodeKeywordSpan">estimateCores</span>(function(err, cores) {
    if(err) {
      // default to 2
      cores = 2;
    }
    numWorkers = cores - 1;
    generate();
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.fillString" id="apidoc.element.node-forge.util.fillString">
        function <span class="apidocSignatureSpan">node-forge.util.</span>fillString
        <span class="apidocSignatureSpan">(c, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillString = function (c, n) {
  var s = '';
  while(n &gt; 0) {
    if(n &amp; 1) {
      s += c;
    }
    n &gt;&gt;&gt;= 1;
    if(n &gt; 0) {
      c += c;
    }
  }
  return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    16).mod(publicKey.n);
} while(r.equals(BigInteger.ZERO));

// prepend r with zeros
r = forge.util.hexToBytes(r.toString(16));
var zeros = byteLength - r.length;
if(zeros &gt; 0) {
  r = forge.util.<span class="apidocCodeKeywordSpan">fillString</span>(String.fromCharCode(0), zeros) + r;
}

// encrypt the random
var encapsulation = publicKey.encrypt(r, 'NONE');

// generate the secret key
var key = kdf.generate(r, keyLength);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.format" id="apidoc.element.node-forge.util.format">
        function <span class="apidocSignatureSpan">node-forge.util.</span>format
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (format) {
  var re = /%./g;
  // current match
  var match;
  // current part
  var part;
  // current arg index
  var argi = 0;
  // collected parts to recombine later
  var parts = [];
  // last index found
  var last = 0;
  // loop while matches remain
  while((match = re.exec(format))) {
    part = format.substring(last, re.lastIndex - 2);
    // don't add empty strings (ie, parts between %s%s)
    if(part.length &gt; 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    // switch on % code
    var code = match[0][1];
    switch(code) {
    case 's':
    case 'o':
      // check if enough arguments were given
      if(argi &lt; arguments.length) {
        parts.push(arguments[argi++ + 1]);
      } else {
        parts.push('&lt;?&gt;');
      }
      break;
    // FIXME: do proper formating for numbers, etc
    //case 'f':
    //case 'd':
    case '%':
      parts.push('%');
      break;
    default:
      parts.push('&lt;%' + code + '?&gt;');
    }
  }
  // add trailing part of format string
  parts.push(format.substring(last));
  return parts.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.formatNumber" id="apidoc.element.node-forge.util.formatNumber">
        function <span class="apidocSignatureSpan">node-forge.util.</span>formatNumber
        <span class="apidocSignatureSpan">(number, decimals, dec_point, thousands_sep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatNumber = function (number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57

  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ?
   '.' : thousands_sep, s = n &lt; 0 ? '-' : '';
  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
  var j = (i.length &gt; 3) ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') +
    i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) +
    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */
util.formatSize = function(size) {
if(size &gt;= 1073741824) {
  size = util.<span class="apidocCodeKeywordSpan">formatNumber</span>(size / 1073741824, 2, '.', '') + '
; GiB';
} else if(size &gt;= 1048576) {
  size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
} else if(size &gt;= 1024) {
  size = util.formatNumber(size / 1024, 0) + ' KiB';
} else {
  size = util.formatNumber(size, 0) + ' bytes';
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.formatSize" id="apidoc.element.node-forge.util.formatSize">
        function <span class="apidocSignatureSpan">node-forge.util.</span>formatSize
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatSize = function (size) {
  if(size &gt;= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if(size &gt;= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if(size &gt;= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }
  return size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.getItem" id="apidoc.element.node-forge.util.getItem">
        function <span class="apidocSignatureSpan">node-forge.util.</span>getItem
        <span class="apidocSignatureSpan">(api, id, key, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getItem = function (api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Loads persistent cookies from disk for the given client.
 *
 * @param client the client.
 */
var _loadCookies = function(client) {
if(client.persistCookies) {
  try {
    var cookies = forge.util.<span class="apidocCodeKeywordSpan">getItem</span>(
      client.socketPool.flashApi,
      _getStorageId(client), 'cookies');
    client.cookies = cookies || {};
  } catch(ex) {
    // no flash storage available, just silently fail
    // TODO: i assume we want this logged somewhere or
    // should it actually generate an error
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.getPath" id="apidoc.element.node-forge.util.getPath">
        function <span class="apidocSignatureSpan">node-forge.util.</span>getPath
        <span class="apidocSignatureSpan">(object, keys, _default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPath = function (object, keys, _default) {
  var i = 0;
  var len = keys.length;
  var hasNext = true;
  while(hasNext &amp;&amp; i &lt; len &amp;&amp;
    typeof(object) === 'object' &amp;&amp; object !== null) {
    var next = keys[i++];
    hasNext = next in object;
    if(hasNext) {
      object = object[next];
    }
  }
  return (hasNext ? object : _default);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.getQueryVariables" id="apidoc.element.node-forge.util.getQueryVariables">
        function <span class="apidocSignatureSpan">node-forge.util.</span>getQueryVariables
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getQueryVariables = function (query) {
  var parse = function(q) {
    var rval = {};
    var kvpairs = q.split('&amp;');
    for(var i = 0; i &lt; kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;
      if(pos &gt; 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }
      if(!(key in rval)) {
        rval[key] = [];
      }
      // disallow overriding object prototype keys
      if(!(key in Object.prototype) &amp;&amp; val !== null) {
        rval[key].push(unescape(val));
      }
    }
    return rval;
  };

   var rval;
   if(typeof(query) === 'undefined') {
     // set cached variables if needed
     if(_queryVariables === null) {
       if(typeof(window) !== 'undefined' &amp;&amp; window.location &amp;&amp; window.location.search) {
          // parse window search query
          _queryVariables = parse(window.location.search.substring(1));
       } else {
          // no query variables available
          _queryVariables = {};
       }
     }
     rval = _queryVariables;
   } else {
     // parse given query
     rval = parse(query);
   }
   return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * console.lock=&lt;true|false&gt;
 * Lock the console log level at whatever level it is set at.  This is run
 * after console.level is processed.  Useful to force a level of verbosity
 * that could otherwise be limited by a user config.
 */
if(sConsoleLogger !== null) {
var query = forge.util.<span class="apidocCodeKeywordSpan">getQueryVariables</span>();
if('console.level' in query) {
  // set with last value
  forge.log.setLevel(
    sConsoleLogger, query['console.level'].slice(-1)[0]);
}
if('console.lock' in query) {
  // set with last value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.hexToBytes" id="apidoc.element.node-forge.util.hexToBytes">
        function <span class="apidocSignatureSpan">node-forge.util.</span>hexToBytes
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hexToBytes = function (hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;
  if(hex.length &amp; 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  // convert 2 characters (1 byte) at a time
  for(; i &lt; hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var str = forge.util.decode64(encoded);

// encode/decode UTF-8
var encoded = forge.util.encodeUtf8(str);
var str = forge.util.decodeUtf8(encoded);

// bytes to/from hex
var bytes = forge.util.<span class="apidocCodeKeywordSpan">hexToBytes</span>(hex);
var hex = forge.util.bytesToHex(bytes);

// create an empty byte buffer
var buffer = forge.util.createBuffer();
// create a byte buffer from raw binary bytes
var buffer = forge.util.createBuffer(input, 'raw');
// create a byte buffer from utf8 bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.inflate" id="apidoc.element.node-forge.util.inflate">
        function <span class="apidocSignatureSpan">node-forge.util.</span>inflate
        <span class="apidocSignatureSpan">(api, bytes, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inflate = function (api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return (rval === null) ? null : util.decode64(rval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // if socket pool uses a flash api, then add deflate support to TLS
  if(sp.flashApi !== null) {
    tlsOptions.deflate = function(bytes) {
      // strip 2 byte zlib header and 4 byte trailer
      return forge.util.deflate(sp.flashApi, bytes, true);
    };
    tlsOptions.inflate = function(bytes) {
      return forge.util.<span class="apidocCodeKeywordSpan">inflate</span>(sp.flashApi, bytes, true);
    };
  }
}

// create and initialize sockets
for(var i = 0; i &lt; options.connections; ++i) {
  _initSocket(client, sp.createSocket(), tlsOptions);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.int32ToBytes" id="apidoc.element.node-forge.util.int32ToBytes">
        function <span class="apidocSignatureSpan">node-forge.util.</span>int32ToBytes
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">int32ToBytes = function (i) {
  return (
    String.fromCharCode(i &gt;&gt; 24 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 16 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // sync version
  if(!callback) {
    for(var i = 1; i &lt;= len; ++i) {
// PRF(P, S || INT(i)) (first iteration)
prf.start(null, null);
prf.update(s);
prf.update(forge.util.<span class="apidocCodeKeywordSpan">int32ToBytes</span>(i));
xor = u_c1 = prf.digest().getBytes();

// PRF(P, u_{c-1}) (other iterations)
for(var j = 2; j &lt;= c; ++j) {
  prf.start(null, null);
  prf.update(u_c1);
  u_c = prf.digest().getBytes();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.isArray" id="apidoc.element.node-forge.util.isArray">
        function <span class="apidocSignatureSpan">node-forge.util.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it must be 16, 24, or 32 bytes in length. If it is in 32-bit
  integers, it must be 4, 6, or 8 integers long. */

if(typeof key === 'string' &amp;&amp;
  (key.length === 16 || key.length === 24 || key.length === 32)) {
  // convert key string into byte buffer
  key = forge.util.createBuffer(key);
} else if(forge.util.<span class="apidocCodeKeywordSpan">isArray</span>(key) &amp;&amp;
  (key.length === 16 || key.length === 24 || key.length === 32)) {
  // convert key integer array into byte buffer
  tmp = key;
  key = forge.util.createBuffer();
  for(var i = 0; i &lt; tmp.length; ++i) {
    key.putByte(tmp[i]);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.isArrayBuffer" id="apidoc.element.node-forge.util.isArrayBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>isArrayBuffer
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArrayBuffer = function (x) {
  return typeof ArrayBuffer !== 'undefined' &amp;&amp; x instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// define isArrayBuffer
util.isArrayBuffer = function(x) {
 return typeof ArrayBuffer !== 'undefined' &amp;&amp; x instanceof ArrayBuffer;
};

// define isArrayBufferView
util.isArrayBufferView = function(x) {
 return x &amp;&amp; util.<span class="apidocCodeKeywordSpan">isArrayBuffer</span>(x.buffer) &amp;&amp; x.byteLength !== undefined
;
};

/**
* Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
* algorithms where bit manipulation, JavaScript limitations, and/or algorithm
* design only allow for byte operations of a limited size.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.isArrayBufferView" id="apidoc.element.node-forge.util.isArrayBufferView">
        function <span class="apidocSignatureSpan">node-forge.util.</span>isArrayBufferView
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArrayBufferView = function (x) {
  return x &amp;&amp; util.isArrayBuffer(x.buffer) &amp;&amp; x.byteLength !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// the data in this buffer
this.data = '';
// the pointer for reading from this buffer
this.read = 0;

if(typeof b === 'string') {
  this.data = b;
} else if(util.isArrayBuffer(b) || util.<span class="apidocCodeKeywordSpan">isArrayBufferView</span>(b)) {
  // convert native buffer to forge buffer
  // FIXME: support native buffers internally instead
  var arr = new Uint8Array(b);
  try {
    this.data = String.fromCharCode.apply(null, arr);
  } catch(e) {
    for(var i = 0; i &lt; arr.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.isEmpty" id="apidoc.element.node-forge.util.isEmpty">
        function <span class="apidocSignatureSpan">node-forge.util.</span>isEmpty
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (obj) {
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    // process next record if no failure, process will be called after
    // each record is handled (since handling can be asynchronous)
    if(!c.fail) {
// reset record if ready and now empty
if(c.record !== null &amp;&amp;
  c.record.ready &amp;&amp; c.record.fragment.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
  c.record = null;
}

// if there is no pending record, try to read record header
if(c.record === null) {
  rval = _readRecordHeader(c);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.makeLink" id="apidoc.element.node-forge.util.makeLink">
        function <span class="apidocSignatureSpan">node-forge.util.</span>makeLink
        <span class="apidocSignatureSpan">(path, query, fragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeLink = function (path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;

  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path +
    ((qstr.length &gt; 0) ? ('?' + qstr) : '') +
    ((fragment.length &gt; 0) ? ('#' + fragment) : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.makeRequest" id="apidoc.element.node-forge.util.makeRequest">
        function <span class="apidocSignatureSpan">node-forge.util.</span>makeRequest
        <span class="apidocSignatureSpan">(reqString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeRequest = function (reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,
<span class="apidocCodeCommentSpan">    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
</span>    getPath: function(i) {
      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];
    },
    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function(k, i) {
      var rval;
      if(typeof(k) === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];
        if(rval &amp;&amp; typeof(i) !== 'undefined') {
           rval = rval[i];
        }
      }
      return rval;
    },
    getQueryLast: function(k, _default) {
      var rval;
      var vals = req.getQuery(k);
      if(vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }
      return rval;
    }
  };
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.nextTick" id="apidoc.element.node-forge.util.nextTick">
        function <span class="apidocSignatureSpan">node-forge.util.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== 'function')
    throw new TypeError('callback is not a function');
  // on the way out, don't bother. it won't get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &gt; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &lt; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated &gt; 0xfffff) {
  ctx.key = null;
}

if(ctx.key === null) {
  // prevent stack overflow
  return forge.util.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
    _reseed(generate);
  });
}

// generate the random bytes
var bytes = cipher(ctx.key, ctx.seed);
ctx.generated += bytes.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.parseFragment" id="apidoc.element.node-forge.util.parseFragment">
        function <span class="apidocSignatureSpan">node-forge.util.</span>parseFragment
        <span class="apidocSignatureSpan">(fragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFragment = function (fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = '';
  // split into path and query if possible at the first '?'
  var pos = fragment.indexOf('?');
  if(pos &gt; 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  }
  // split path based on '/' and ignore first element if empty
  var path = fp.split('/');
  if(path.length &gt; 0 &amp;&amp; path[0] === '') {
    path.shift();
  }
  // convert query into object
  var query = (fq === '') ? {} : util.getQueryVariables(fq);

  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */
util.makeRequest = function(reqString) {
var frag = util.<span class="apidocCodeKeywordSpan">parseFragment</span>(reqString);
var req = {
  // full path string
  path: frag.pathString,
  // full query string
  query: frag.queryString,
  /**
   * Get path or element in path.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.parseUrl" id="apidoc.element.node-forge.util.parseUrl">
        function <span class="apidocSignatureSpan">node-forge.util.</span>parseUrl
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseUrl = function (str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&amp;^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = (m === null) ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };
  if(url) {
    url.fullHost = url.host;
    if(url.port) {
      if(url.port !== 80 &amp;&amp; url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if(url.port !== 443 &amp;&amp; url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if(url.scheme === 'http') {
      url.port = 80;
    } else if(url.scheme === 'https') {
      url.port = 443;
    }
    url.full = url.scheme + '://' + url.fullHost;
  }
  return url;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// convert a Node.js Buffer into a forge buffer
// make sure you specify the encoding as 'binary'
var nodeBuffer = new Buffer();
var forgeBuffer = forge.util.createBuffer(nodeBuffer.toString('binary'));

// parse a URL
var parsed = forge.util.<span class="apidocCodeKeywordSpan">parseUrl</span>('http://example.com/foo?bar=baz');
// parsed.scheme, parsed.host, parsed.port, parsed.path, parsed.fullHost
```

&lt;a name="log" /&gt;
### Logging

Provides logging to a javascript console using various categories and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.removeItem" id="apidoc.element.node-forge.util.removeItem">
        function <span class="apidocSignatureSpan">node-forge.util.</span>removeItem
        <span class="apidocSignatureSpan">(api, id, key, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeItem = function (api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var _setStorageObject = function(api, id, obj) {
if(!api) {
  throw new Error('WebStorage not available.');
}

var rval;
if(obj === null) {
  rval = api.<span class="apidocCodeKeywordSpan">removeItem</span>(id);
} else {
  // json-encode and base64-encode object
  obj = util.encode64(JSON.stringify(obj));
  rval = api.setItem(id, obj);
}

// handle potential flash error
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.setImmediate" id="apidoc.element.node-forge.util.setImmediate">
        function <span class="apidocSignatureSpan">node-forge.util.</span>setImmediate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  prf.start(null, null);
  prf.update(u_c1);
  u_c = prf.digest().getBytes();
  // F(p, s, c, i)
  xor = forge.util.xorBytes(xor, u_c, hLen);
  u_c1 = u_c;
  ++j;
  return forge.util.<span class="apidocCodeKeywordSpan">setImmediate</span>(inner);
}

/* 4. Concatenate the blocks and extract the first dkLen octets to
  produce a derived key DK:

  DK = T_1 || T_2 ||  ...  || T_len&lt;0..r-1&gt; */
dk += (i &lt; len) ? xor : xor.substr(0, r);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.setItem" id="apidoc.element.node-forge.util.setItem">
        function <span class="apidocSignatureSpan">node-forge.util.</span>setItem
        <span class="apidocSignatureSpan">(api, id, key, data, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setItem = function (api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Saves persistent cookies on disk for the given client.
 *
 * @param client the client.
 */
var _saveCookies = function(client) {
if(client.persistCookies) {
  try {
    forge.util.<span class="apidocCodeKeywordSpan">setItem</span>(
      client.socketPool.flashApi,
      _getStorageId(client), 'cookies', client.cookies);
  } catch(ex) {
    // no flash storage available, just silently fail
    // TODO: i assume we want this logged somewhere or
    // should it actually generate an error
    //forge.log.error(cat, ex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.setPath" id="apidoc.element.node-forge.util.setPath">
        function <span class="apidocSignatureSpan">node-forge.util.</span>setPath
        <span class="apidocSignatureSpan">(object, keys, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPath = function (object, keys, value) {
  // need to start at an object
  if(typeof(object) === 'object' &amp;&amp; object !== null) {
    var i = 0;
    var len = keys.length;
    while(i &lt; len) {
      var next = keys[i++];
      if(i == len) {
        // last
        object[next] = value;
      } else {
        // more
        var hasNext = (next in object);
        if(!hasNext ||
          (hasNext &amp;&amp; typeof(object[next]) !== 'object') ||
          (hasNext &amp;&amp; object[next] === null)) {
          object[next] = {};
        }
        object = object[next];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.xorBytes" id="apidoc.element.node-forge.util.xorBytes">
        function <span class="apidocSignatureSpan">node-forge.util.</span>xorBytes
        <span class="apidocSignatureSpan">(s1, s2, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorBytes = function (s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;
  for(; n &gt; 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
    if(c &gt;= 10) {
      s3 += t;
      t = '';
      c = 0;
    }
    t += String.fromCharCode(b);
    ++c;
  }
  s3 += t;
  return s3;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j &lt;= c; ++j) {
prf.start(null, null);
prf.update(u_c1);
u_c = prf.digest().getBytes();
// F(p, s, c, i)
xor = forge.util.<span class="apidocCodeKeywordSpan">xorBytes</span>(xor, u_c, hLen);
u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
produce a derived key DK:

DK = T_1 || T_2 ||  ...  || T_len&lt;0..r-1&gt; */
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.util.ByteBuffer" id="apidoc.module.node-forge.util.ByteBuffer">module node-forge.util.ByteBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.ByteBuffer" id="apidoc.element.node-forge.util.ByteBuffer.ByteBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>ByteBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    // convert native buffer to forge buffer
    // FIXME: support native buffers internally instead
    var arr = new Uint8Array(b);
    try {
      this.data = String.fromCharCode.apply(null, arr);
    } catch(e) {
      for(var i = 0; i &lt; arr.length; ++i) {
        this.putByte(arr[i]);
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' &amp;&amp; typeof b.data === 'string' &amp;&amp;
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param x the binary-encoded byte string to generate a key from.
   * @param length the number of bytes to generate (the size of the key).
   *
   * @return the key as a binary-encoded string.
   */
  kdf.generate = function(x, length) {
var key = new forge.util.<span class="apidocCodeKeywordSpan">ByteBuffer</span>();

// run counter from counterStart to ceil(length / Hash.len)
var k = Math.ceil(length / digestLength) + counterStart;

var c = new forge.util.ByteBuffer();
for(var i = counterStart; i &lt; k; ++i) {
  // I2OSP(i, 4): convert counter to an octet string of 4 octets
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.util.ByteBuffer.prototype" id="apidoc.module.node-forge.util.ByteBuffer.prototype">module node-forge.util.ByteBuffer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype._optimizeConstructedString" id="apidoc.element.node-forge.util.ByteBuffer.prototype._optimizeConstructedString">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>_optimizeConstructedString
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_optimizeConstructedString = function (x) {
  this._constructedStringLength += x;
  if(this._constructedStringLength &gt; _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
   n &gt;&gt;&gt;= 1;
   if(n &gt; 0) {
     b += b;
   }
 }
 this.data = d;
 this.<span class="apidocCodeKeywordSpan">_optimizeConstructedString</span>(n);
 return this;
};

/**
* Puts bytes in this buffer.
*
* @param bytes the bytes (as a UTF-8 encoded string) to put.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.at" id="apidoc.element.node-forge.util.ByteBuffer.prototype.at">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>at
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at = function (i) {
  return this.data.charCodeAt(this.read + i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    including itself. Each of the padding bytes has the same value as that
    last byte (known as the padding_length). Here we check all padding
    bytes to ensure they have the value of padding_length even if one of
    them is bad in order to ward-off timing attacks. */
  var len = output.length();
  var paddingLength = output.last();
  for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
    rval = rval &amp;&amp; (output.<span class="apidocCodeKeywordSpan">at</span>(i) == paddingLength);
  }
  if(rval) {
    // trim off padding bytes and last padding length byte
    output.truncate(paddingLength + 1);
  }
}
return rval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.bytes" id="apidoc.element.node-forge.util.ByteBuffer.prototype.bytes">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>bytes
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytes = function (count) {
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (defaults to RSASSA PKCS#1 v1.5)
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
var signature = privateKey.sign(md);

// verify data with a public key
// (defaults to RSASSA PKCS#1 v1.5)
var verified = publicKey.verify(md.digest().<span class="apidocCodeKeywordSpan">bytes</span>(), signature);

// sign data using RSASSA-PSS where PSS uses a SHA-1 hash, a SHA-1 based
// masking function MGF1, and a 20 byte salt
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
var pss = forge.pss.create({
md: forge.md.sha1.create(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.clear" id="apidoc.element.node-forge.util.ByteBuffer.prototype.clear">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.data = '';
  this.read = 0;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handle partial block
var partialBytes = (this.blockSize - inputLength) % this.blockSize;
if(partialBytes &gt; 0) {
  partialBytes = this.blockSize - partialBytes;
}

// XOR input with output, write input as partial output
this._partialOutput.<span class="apidocCodeKeywordSpan">clear</span>();
for(var i = 0; i &lt; this._ints; ++i) {
  this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
  this._partialOutput.putInt32(this._partialBlock[i]);
}

if(partialBytes &gt; 0) {
  // block still incomplete, restore input buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.compact" id="apidoc.element.node-forge.util.ByteBuffer.prototype.compact">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>compact
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compact = function () {
  if(this.read &gt; 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 // do cipher operation until it needs more input and not finished
 while(!this._op.call(this.mode, this._input, this.output, this._finish) &amp;&amp;
   !this._finish) {}

 // free consumed memory from input buffer
 this._input.<span class="apidocCodeKeywordSpan">compact</span>();
};

/**
* Finishes encrypting or decrypting.
*
* @param pad a padding function to use in CBC mode, null for default,
*          signature(blockSize, buffer, decrypt).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.copy" id="apidoc.element.node-forge.util.ByteBuffer.prototype.copy">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   value: value
 };
 if(options &amp;&amp; 'bitStringContents' in options) {
   // TODO: copy byte buffer if it's a buffer not a string
   obj.bitStringContents = options.bitStringContents;
   // TODO: add readonly flag to avoid this overhead
   // save copy to detect changes
   obj.original = asn1.<span class="apidocCodeKeywordSpan">copy</span>(obj);
 }
 return obj;
};

/**
* Copies an asn1 object.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.fillWithByte" id="apidoc.element.node-forge.util.ByteBuffer.prototype.fillWithByte">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>fillWithByte
        <span class="apidocSignatureSpan">(b, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillWithByte = function (b, n) {
  b = String.fromCharCode(b);
  var d = this.data;
  while(n &gt; 0) {
    if(n &amp; 1) {
      d += b;
    }
    n &gt;&gt;&gt;= 1;
    if(n &gt; 0) {
      b += b;
    }
  }
  this.data = d;
  this._optimizeConstructedString(n);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  less than the actual number of padding bytes if you include the
  padding_length uint8 itself as a padding byte. */
 if(!decrypt) {
   // get the number of padding bytes required to reach the blockSize and
   // subtract 1 for the padding value (to make room for the padding_length
   // uint8)
   var padding = blockSize - (input.length() % blockSize);
   input.<span class="apidocCodeKeywordSpan">fillWithByte</span>(padding - 1, padding);
 }
 return true;
}

/**
* Handles padding for aes_cbc_sha1 in decrypt mode.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getByte" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getByte">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getByte
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getByte = function () {
  return this.data.charCodeAt(this.read++);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2 = b.<span class="apidocCodeKeywordSpan">getByte</span>();
if(b2 === 0x80) {
  return undefined;
}

// see if the length is "short form" or "long form" (bit 8 set)
var length;
var longForm = b2 &amp; 0x80;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getBytes" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getBytes">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getBytes
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function (count) {
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/* the private key for the client-side cert if provided */
getPrivateKey: function(connection, cert) {
  return myClientPrivateKey;
},
tlsDataReady: function(connection) {
  // TLS data (encrypted) is ready to be sent to the server
  sendToServerSomehow(connection.tlsData.<span class="apidocCodeKeywordSpan">getBytes</span>());
  // if you were communicating with the server below, you'd do:
  // server.process(connection.tlsData.getBytes());
},
dataReady: function(connection) {
  // clear data from the server is ready
  console.log('the server sent: ' +
    forge.util.decodeUtf8(connection.data.getBytes()));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt = function (n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval &lt;&lt; 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while(n &gt; 0);
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var longForm = b2 &amp; 0x80;
 if(!longForm) {
   // length is just the first byte
   length = b2;
 } else {
   // the number of bytes the length is specified in bits 7 through 1
   // and each length byte is in big-endian base-256
   length = b.<span class="apidocCodeKeywordSpan">getInt</span>((b2 &amp; 0x7F) &lt;&lt; 3);
 }
 return length;
};

/**
* Check if the byte buffer has enough bytes. Throws an Error if not.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt16 = function () {
  var rval = (
    this.data.charCodeAt(this.read) &lt;&lt; 8 ^
    this.data.charCodeAt(this.read + 1));
  this.read += 2;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    length = remaining;
  }

  if(type === asn1.Type.BMPSTRING) {
    value = '';
    for(; length &gt; 0; length -= 2) {
      _checkBufferLength(bytes, remaining, 2);
      value += String.fromCharCode(bytes.<span class="apidocCodeKeywordSpan">getInt16</span>());
      remaining -= 2;
    }
  } else {
    value = bytes.getBytes(length);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt16Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt16Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt16Le = function () {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) &lt;&lt; 8);
  this.read += 2;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var _finish = false, _input = null, _output = null, _iv = null;
var mixRound, mashRound;
var i, j, K = [];

/* Expand key and fill into K[] Array */
key = forge.rc2.expandKey(key, bits);
for(i = 0; i &lt; 64; i++) {
  K.push(key.<span class="apidocCodeKeywordSpan">getInt16Le</span>());
}

if(encrypt) {
  /**
   * Perform one mixing round "in place".
   *
   * @param R Array of four words to perform mixing on.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt24
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt24 = function () {
  var rval = (
    this.data.charCodeAt(this.read) &lt;&lt; 16 ^
    this.data.charCodeAt(this.read + 1) &lt;&lt; 8 ^
    this.data.charCodeAt(this.read + 2));
  this.read += 3;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
  len = b.getByte();
  break;
case 2:
  len = b.getInt16();
  break;
case 3:
  len = b.<span class="apidocCodeKeywordSpan">getInt24</span>();
  break;
case 4:
  len = b.getInt32();
  break;
}

// read vector bytes into a new buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt24Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt24Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt24Le = function () {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) &lt;&lt; 8 ^
    this.data.charCodeAt(this.read + 2) &lt;&lt; 16);
  this.read += 3;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt32 = function () {
  var rval = (
    this.data.charCodeAt(this.read) &lt;&lt; 24 ^
    this.data.charCodeAt(this.read + 1) &lt;&lt; 16 ^
    this.data.charCodeAt(this.read + 2) &lt;&lt; 8 ^
    this.data.charCodeAt(this.read + 3));
  this.read += 4;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = [];

  // key lengths of 16, 24, 32 bytes allowed
  var len = tmp.length();
  if(len === 16 || len === 24 || len === 32) {
    len = len &gt;&gt;&gt; 2;
    for(var i = 0; i &lt; len; ++i) {
      key.push(tmp.<span class="apidocCodeKeywordSpan">getInt32</span>());
    }
  }
}

// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key) ||
  !(key.length === 4 || key.length === 6 || key.length === 8)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getInt32Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getInt32Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt32Le = function () {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) &lt;&lt; 8 ^
    this.data.charCodeAt(this.read + 2) &lt;&lt; 16 ^
    this.data.charCodeAt(this.read + 3) &lt;&lt; 24);
  this.read += 4;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a = s.h0;
b = s.h1;
c = s.h2;
d = s.h3;

// round 1
for(i = 0; i &lt; 16; ++i) {
  w[i] = bytes.<span class="apidocCodeKeywordSpan">getInt32Le</span>();
  f = d ^ (b &amp; (c ^ d));
  t = (a + f + _k[i] + w[i]);
  r = _r[i];
  a = d;
  d = c;
  c = b;
  b += (t &lt;&lt; r) | (t &gt;&gt;&gt; (32 - r));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.getSignedInt" id="apidoc.element.node-forge.util.ByteBuffer.prototype.getSignedInt">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>getSignedInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 &lt;&lt; (n - 2);
  if(x &gt;= max) {
    x -= max &lt;&lt; 1;
  }
  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   bytes = forge.util.createBuffer(bytes);
 }

 var n = bytes.length() * 8;
 if(n &gt; 32) {
   throw new Error('Integer too large; max is 32-bits.');
 }
 return bytes.<span class="apidocCodeKeywordSpan">getSignedInt</span>(n);
};

/**
* Validates the that given ASN.1 object is at least a super set of the
* given ASN.1 structure. Only tag classes and types are checked. An
* optional map may also be provided to capture ASN.1 values while the
* structure is checked.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.isEmpty" id="apidoc.element.node-forge.util.ByteBuffer.prototype.isEmpty">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this.length() &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    // process next record if no failure, process will be called after
    // each record is handled (since handling can be asynchronous)
    if(!c.fail) {
// reset record if ready and now empty
if(c.record !== null &amp;&amp;
  c.record.ready &amp;&amp; c.record.fragment.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
  c.record = null;
}

// if there is no pending record, try to read record header
if(c.record === null) {
  rval = _readRecordHeader(c);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.last" id="apidoc.element.node-forge.util.ByteBuffer.prototype.last">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.data.charCodeAt(this.data.length - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(decrypt) {
/* The last byte in the output specifies the number of padding bytes not
  including itself. Each of the padding bytes has the same value as that
  last byte (known as the padding_length). Here we check all padding
  bytes to ensure they have the value of padding_length even if one of
  them is bad in order to ward-off timing attacks. */
var len = output.length();
var paddingLength = output.<span class="apidocCodeKeywordSpan">last</span>();
for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
  rval = rval &amp;&amp; (output.at(i) == paddingLength);
}
if(rval) {
  // trim off padding bytes and last padding length byte
  output.truncate(paddingLength + 1);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.length" id="apidoc.element.node-forge.util.ByteBuffer.prototype.length">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () {
  return this.data.length - this.read;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buffer = forge.util.createBuffer();
// create a byte buffer from raw binary bytes
var buffer = forge.util.createBuffer(input, 'raw');
// create a byte buffer from utf8 bytes
var buffer = forge.util.createBuffer(input, 'utf8');

// get the length of the buffer in bytes
buffer.<span class="apidocCodeKeywordSpan">length</span>();
// put bytes into the buffer
buffer.putBytes(bytes);
// put a 32-bit integer into the buffer
buffer.putInt32(10);
// buffer to hex
buffer.toHex();
// get a copy of the bytes in the buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putBuffer" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putBuffer
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putBuffer = function (buffer) {
  return this.putBytes(buffer.getBytes());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var output = forge.util.createBuffer();

// if using a salt, prepend this to the output:
if(salt !== null) {
  output.putBytes('Salted__'); // (add to match openssl tool output)
  output.putBytes(salt);
}
output.<span class="apidocCodeKeywordSpan">putBuffer</span>(cipher.output);

fs.writeFileSync('input.enc', output.getBytes(), {encoding: 'binary'});
}

// openssl enc -d -des3 -in input.enc -out input.dec.txt
function decrypt(password) {
var input = fs.readFileSync('input.enc', {encoding: 'binary'});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putByte" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putByte">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putByte
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putByte = function (b) {
  return this.putBytes(String.fromCharCode(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = forge.util.createBuffer(key);
} else if(forge.util.isArray(key) &amp;&amp;
  (key.length === 16 || key.length === 24 || key.length === 32)) {
  // convert key integer array into byte buffer
  tmp = key;
  key = forge.util.createBuffer();
  for(var i = 0; i &lt; tmp.length; ++i) {
    key.<span class="apidocCodeKeywordSpan">putByte</span>(tmp[i]);
  }
}

// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)) {
  tmp = key;
  key = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putBytes" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putBytes">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putBytes = function (bytes) {
  this.data += bytes;
  this._optimizeConstructedString(bytes.length);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sendSomehow(request.toString());

// receive response
var buffer = forge.util.createBuffer();
var response = forge.http.createResponse();
var someAsyncDataHandler = function(bytes) {
if(!response.bodyReceived) {
  buffer.<span class="apidocCodeKeywordSpan">putBytes</span>(bytes);
  if(!response.headerReceived) {
    if(response.readHeader(buffer)) {
      console.log('HTTP response header: ' + response.toString());
    }
  }
  if(response.headerReceived &amp;&amp; !response.bodyReceived) {
    if(response.readBody(buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt
        <span class="apidocSignatureSpan">(i, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt = function (i, n) {
  _checkBitsParam(n);
  var bytes = '';
  do {
    n -= 8;
    bytes += String.fromCharCode((i &gt;&gt; n) &amp; 0xFF);
  } while(n &gt; 0);
  return this.putBytes(bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param lenBytes the number of bytes required to store the length.
 * @param v the byte buffer vector.
 */
var writeVector = function(b, lenBytes, v) {
  // encode length at the start of the vector, where the number of bytes for
  // the length is the maximum number of bytes it would take to encode the
  // vector's ceiling
  b.<span class="apidocCodeKeywordSpan">putInt</span>(v.length(), lenBytes &lt;&lt; 3);
  b.putBuffer(v);
};

/**
 * The tls implementation.
 */
var tls = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt16
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt16 = function (i) {
  return this.putBytes(
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      value.putBuffer(asn1.toDer(obj.value[i]));
    }
  }
} else {
  // use asn1.value directly
  if(obj.type === asn1.Type.BMPSTRING) {
    for(var i = 0; i &lt; obj.value.length; ++i) {
      value.<span class="apidocCodeKeywordSpan">putInt16</span>(obj.value.charCodeAt(i));
    }
  } else {
    // ensure integer is minimally-encoded
    // TODO: should all leading bytes be stripped vs just one?
    // .. ex '00 00 01' =&gt; '01'?
    if(obj.type === asn1.Type.INTEGER &amp;&amp;
      obj.value.length &gt; 1 &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt16Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt16Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt16Le = function (i) {
  return this.putBytes(
    String.fromCharCode(i &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if(_iv !== null) {
    if(encrypt) {
      /* We're encrypting, apply the IV first. */
      val ^= _iv.getInt16Le();
    } else {
      /* We're decryption, keep cipher text for next block. */
      _iv.<span class="apidocCodeKeywordSpan">putInt16Le</span>(val);
    }
  }

  R.push(val &amp; 0xffff);
}

/* Reset global "j" variable as per spec. */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt24
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt24 = function (i) {
  return this.putBytes(
    String.fromCharCode(i &gt;&gt; 16 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  2 + cSuites +          // cipher suites vector
  1 + cMethods +         // compression methods vector
  extLength;             // extensions vector

// build record fragment
var rval = forge.util.createBuffer();
rval.putByte(tls.HandshakeType.client_hello);
rval.<span class="apidocCodeKeywordSpan">putInt24</span>(length);                     // handshake length
rval.putByte(c.version.major);             // major version
rval.putByte(c.version.minor);             // minor version
rval.putBytes(c.session.sp.client_random); // random time + bytes
writeVector(rval, 1, forge.util.createBuffer(sessionId));
writeVector(rval, 2, cipherSuites);
writeVector(rval, 1, compressionMethods);
if(extLength &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt24Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt24Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt24Le = function (i) {
  return this.putBytes(
    String.fromCharCode(i &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 16 &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt32
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt32 = function (i) {
  return this.putBytes(
    String.fromCharCode(i &gt;&gt; 24 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 16 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buffer = forge.util.createBuffer(input, 'utf8');

// get the length of the buffer in bytes
buffer.length();
// put bytes into the buffer
buffer.putBytes(bytes);
// put a 32-bit integer into the buffer
buffer.<span class="apidocCodeKeywordSpan">putInt32</span>(10);
// buffer to hex
buffer.toHex();
// get a copy of the bytes in the buffer
bytes.bytes(/* count */);
// empty this buffer and get its contents
bytes.getBytes(/* count */);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32Le" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putInt32Le">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putInt32Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt32Le = function (i) {
  return this.putBytes(
    String.fromCharCode(i &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 8 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 16 &amp; 0xFF) +
    String.fromCharCode(i &gt;&gt; 24 &amp; 0xFF));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// serialize message length in bits in little-endian order; since length
// is stored in bytes we multiply by 8 and add carry
var bits, carry = 0;
for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
  bits = md.fullMessageLength[i] * 8 + carry;
  carry = (bits / 0x100000000) &gt;&gt;&gt; 0;
  finalBlock.<span class="apidocCodeKeywordSpan">putInt32Le</span>(bits &gt;&gt;&gt; 0);
}

var s2 = {
  h0: _state.h0,
  h1: _state.h1,
  h2: _state.h2,
  h3: _state.h3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putSignedInt" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putSignedInt">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putSignedInt
        <span class="apidocSignatureSpan">(i, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putSignedInt = function (i, n) {
  // putInt checks n
  if(i &lt; 0) {
    i += 2 &lt;&lt; (n - 1);
  }
  return this.putInt(i, n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param x the integer.
 *
 * @return the byte buffer.
 */
asn1.integerToDer = function(x) {
var rval = forge.util.createBuffer();
if(x &gt;= -0x80 &amp;&amp; x &lt; 0x80) {
  return rval.<span class="apidocCodeKeywordSpan">putSignedInt</span>(x, 8);
}
if(x &gt;= -0x8000 &amp;&amp; x &lt; 0x8000) {
  return rval.putSignedInt(x, 16);
}
if(x &gt;= -0x800000 &amp;&amp; x &lt; 0x800000) {
  return rval.putSignedInt(x, 24);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.putString" id="apidoc.element.node-forge.util.ByteBuffer.prototype.putString">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>putString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putString = function (str) {
  return this.putBytes(util.encodeUtf8(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Adds len(val) then val to a buffer.
*
* @param buffer the buffer to add to.
* @param val a string.
*/
function _addStringToBuffer(buffer, val) {
 buffer.putInt32(val.length);
 buffer.<span class="apidocCodeKeywordSpan">putString</span>(val);
}

/**
* Hashes the arguments into one value using SHA-1.
*
* @return the sha1 hash of the provided arguments.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.setAt" id="apidoc.element.node-forge.util.ByteBuffer.prototype.setAt">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>setAt
        <span class="apidocSignatureSpan">(i, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAt = function (i, b) {
  this.data = this.data.substr(0, this.read + i) +
    String.fromCharCode(b) +
    this.data.substr(this.read + i + 1);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Inew = new forge.util.ByteBuffer();
for(j = 0; j &lt; k; j++) {
  var chunk = new forge.util.ByteBuffer(I.getBytes(v));
  var x = 0x1ff;
  for(l = B.length() - 1; l &gt;= 0; l--) {
    x = x &gt;&gt; 8;
    x += B.at(l) + chunk.at(l);
    chunk.<span class="apidocCodeKeywordSpan">setAt</span>(l, x &amp; 0xff);
  }
  Inew.putBuffer(chunk);
}
I = Inew;

/* Add Ai to A. */
result.putBuffer(buf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.toHex" id="apidoc.element.node-forge.util.ByteBuffer.prototype.toHex">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>toHex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function () {
  var rval = '';
  for(var i = this.read; i &lt; this.data.length; ++i) {
    var b = this.data.charCodeAt(i);
    if(b &lt; 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.<span class="apidocCodeKeywordSpan">toHex</span>());

// decrypt some bytes using CBC mode
// (other modes include: CFB, OFB, CTR, and GCM)
var decipher = forge.cipher.createDecipher('AES-CBC', key);
decipher.start({iv: iv});
decipher.update(encrypted);
decipher.finish();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.toString" id="apidoc.element.node-forge.util.ByteBuffer.prototype.toString">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return util.decodeUtf8(this.bytes());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

socket.on('connect', function() {
  console.log('[socket] connected');
  client.handshake();
});
socket.on('data', function(data) {
  client.process(data.<span class="apidocCodeKeywordSpan">toString</span>('binary')); // encoding should be 'binary
'
});
socket.on('end', function() {
  console.log('[socket] disconnected');
});

// connect to google.com
socket.connect(443, 'google.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.ByteBuffer.prototype.truncate" id="apidoc.element.node-forge.util.ByteBuffer.prototype.truncate">
        function <span class="apidocSignatureSpan">node-forge.util.ByteBuffer.prototype.</span>truncate
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function (count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var len = output.length();
   var paddingLength = output.last();
   for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
     rval = rval &amp;&amp; (output.at(i) == paddingLength);
   }
   if(rval) {
     // trim off padding bytes and last padding length byte
     output.<span class="apidocCodeKeywordSpan">truncate</span>(paddingLength + 1);
   }
 }
 return rval;
}

/**
* Decrypts a TLSCipherText record into a TLSCompressed record using
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.util.DataBuffer" id="apidoc.module.node-forge.util.DataBuffer">module node-forge.util.DataBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.DataBuffer" id="apidoc.element.node-forge.util.DataBuffer.DataBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.</span>DataBuffer
        <span class="apidocSignatureSpan">(b, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBuffer(b, options) {
  // default options
  options = options || {};

  // pointers for read from/write to buffer
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;

  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);
  if(isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if(isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = ('writeOffset' in options ?
      options.writeOffset : this.data.byteLength);
    return;
  }

  // initialize to empty array buffer and add any given bytes using putBytes
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if(b !== null &amp;&amp; b !== undefined) {
    this.putBytes(b);
  }

  if('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Creates a copy of this buffer.
*
* @return the copy.
*/
util.DataBuffer.prototype.copy = function() {
 return new util.<span class="apidocCodeKeywordSpan">DataBuffer</span>(this);
};

/**
* Compacts this buffer.
*
* @return this buffer.
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-forge.util.DataBuffer.prototype" id="apidoc.module.node-forge.util.DataBuffer.prototype">module node-forge.util.DataBuffer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.accommodate" id="apidoc.element.node-forge.util.DataBuffer.prototype.accommodate">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>accommodate
        <span class="apidocSignatureSpan">(amount, growSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accommodate = function (amount, growSize) {
  if(this.length() &gt;= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);

  // grow buffer
  var src = new Uint8Array(
    this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Puts a byte in this buffer.
*
* @param b the byte to put.
*
* @return this buffer.
*/
util.DataBuffer.prototype.putByte = function(b) {
 this.<span class="apidocCodeKeywordSpan">accommodate</span>(1);
 this.data.setUint8(this.write++, b);
 return this;
};

/**
* Puts a byte in this buffer N times.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.at" id="apidoc.element.node-forge.util.DataBuffer.prototype.at">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>at
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at = function (i) {
  return this.data.getUint8(this.read + i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    including itself. Each of the padding bytes has the same value as that
    last byte (known as the padding_length). Here we check all padding
    bytes to ensure they have the value of padding_length even if one of
    them is bad in order to ward-off timing attacks. */
  var len = output.length();
  var paddingLength = output.last();
  for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
    rval = rval &amp;&amp; (output.<span class="apidocCodeKeywordSpan">at</span>(i) == paddingLength);
  }
  if(rval) {
    // trim off padding bytes and last padding length byte
    output.truncate(paddingLength + 1);
  }
}
return rval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.bytes" id="apidoc.element.node-forge.util.DataBuffer.prototype.bytes">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>bytes
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytes = function (count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (defaults to RSASSA PKCS#1 v1.5)
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
var signature = privateKey.sign(md);

// verify data with a public key
// (defaults to RSASSA PKCS#1 v1.5)
var verified = publicKey.verify(md.digest().<span class="apidocCodeKeywordSpan">bytes</span>(), signature);

// sign data using RSASSA-PSS where PSS uses a SHA-1 hash, a SHA-1 based
// masking function MGF1, and a 20 byte salt
var md = forge.md.sha1.create();
md.update('sign this', 'utf8');
var pss = forge.pss.create({
md: forge.md.sha1.create(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.clear" id="apidoc.element.node-forge.util.DataBuffer.prototype.clear">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handle partial block
var partialBytes = (this.blockSize - inputLength) % this.blockSize;
if(partialBytes &gt; 0) {
  partialBytes = this.blockSize - partialBytes;
}

// XOR input with output, write input as partial output
this._partialOutput.<span class="apidocCodeKeywordSpan">clear</span>();
for(var i = 0; i &lt; this._ints; ++i) {
  this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
  this._partialOutput.putInt32(this._partialBlock[i]);
}

if(partialBytes &gt; 0) {
  // block still incomplete, restore input buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.compact" id="apidoc.element.node-forge.util.DataBuffer.prototype.compact">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>compact
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compact = function () {
  if(this.read &gt; 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 // do cipher operation until it needs more input and not finished
 while(!this._op.call(this.mode, this._input, this.output, this._finish) &amp;&amp;
   !this._finish) {}

 // free consumed memory from input buffer
 this._input.<span class="apidocCodeKeywordSpan">compact</span>();
};

/**
* Finishes encrypting or decrypting.
*
* @param pad a padding function to use in CBC mode, null for default,
*          signature(blockSize, buffer, decrypt).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.copy" id="apidoc.element.node-forge.util.DataBuffer.prototype.copy">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
  return new util.DataBuffer(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   value: value
 };
 if(options &amp;&amp; 'bitStringContents' in options) {
   // TODO: copy byte buffer if it's a buffer not a string
   obj.bitStringContents = options.bitStringContents;
   // TODO: add readonly flag to avoid this overhead
   // save copy to detect changes
   obj.original = asn1.<span class="apidocCodeKeywordSpan">copy</span>(obj);
 }
 return obj;
};

/**
* Copies an asn1 object.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.fillWithByte" id="apidoc.element.node-forge.util.DataBuffer.prototype.fillWithByte">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>fillWithByte
        <span class="apidocSignatureSpan">(b, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillWithByte = function (b, n) {
  this.accommodate(n);
  for(var i = 0; i &lt; n; ++i) {
    this.data.setUint8(b);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  less than the actual number of padding bytes if you include the
  padding_length uint8 itself as a padding byte. */
 if(!decrypt) {
   // get the number of padding bytes required to reach the blockSize and
   // subtract 1 for the padding value (to make room for the padding_length
   // uint8)
   var padding = blockSize - (input.length() % blockSize);
   input.<span class="apidocCodeKeywordSpan">fillWithByte</span>(padding - 1, padding);
 }
 return true;
}

/**
* Handles padding for aes_cbc_sha1 in decrypt mode.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getByte" id="apidoc.element.node-forge.util.DataBuffer.prototype.getByte">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getByte
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getByte = function () {
  return this.data.getInt8(this.read++);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2 = b.<span class="apidocCodeKeywordSpan">getByte</span>();
if(b2 === 0x80) {
  return undefined;
}

// see if the length is "short form" or "long form" (bit 8 set)
var length;
var longForm = b2 &amp; 0x80;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getBytes" id="apidoc.element.node-forge.util.DataBuffer.prototype.getBytes">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getBytes
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function (count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
/* the private key for the client-side cert if provided */
getPrivateKey: function(connection, cert) {
  return myClientPrivateKey;
},
tlsDataReady: function(connection) {
  // TLS data (encrypted) is ready to be sent to the server
  sendToServerSomehow(connection.tlsData.<span class="apidocCodeKeywordSpan">getBytes</span>());
  // if you were communicating with the server below, you'd do:
  // server.process(connection.tlsData.getBytes());
},
dataReady: function(connection) {
  // clear data from the server is ready
  console.log('the server sent: ' +
    forge.util.decodeUtf8(connection.data.getBytes()));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt = function (n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval &lt;&lt; 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while(n &gt; 0);
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var longForm = b2 &amp; 0x80;
 if(!longForm) {
   // length is just the first byte
   length = b2;
 } else {
   // the number of bytes the length is specified in bits 7 through 1
   // and each length byte is in big-endian base-256
   length = b.<span class="apidocCodeKeywordSpan">getInt</span>((b2 &amp; 0x7F) &lt;&lt; 3);
 }
 return length;
};

/**
* Check if the byte buffer has enough bytes. Throws an Error if not.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt16" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt16">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt16 = function () {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    length = remaining;
  }

  if(type === asn1.Type.BMPSTRING) {
    value = '';
    for(; length &gt; 0; length -= 2) {
      _checkBufferLength(bytes, remaining, 2);
      value += String.fromCharCode(bytes.<span class="apidocCodeKeywordSpan">getInt16</span>());
      remaining -= 2;
    }
  } else {
    value = bytes.getBytes(length);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt16Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt16Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt16Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt16Le = function () {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var _finish = false, _input = null, _output = null, _iv = null;
var mixRound, mashRound;
var i, j, K = [];

/* Expand key and fill into K[] Array */
key = forge.rc2.expandKey(key, bits);
for(i = 0; i &lt; 64; i++) {
  K.push(key.<span class="apidocCodeKeywordSpan">getInt16Le</span>());
}

if(encrypt) {
  /**
   * Perform one mixing round "in place".
   *
   * @param R Array of four words to perform mixing on.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt24" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt24">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt24
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt24 = function () {
  var rval = (
    this.data.getInt16(this.read) &lt;&lt; 8 ^
    this.data.getInt8(this.read + 2));
  this.read += 3;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
  len = b.getByte();
  break;
case 2:
  len = b.getInt16();
  break;
case 3:
  len = b.<span class="apidocCodeKeywordSpan">getInt24</span>();
  break;
case 4:
  len = b.getInt32();
  break;
}

// read vector bytes into a new buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt24Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt24Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt24Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt24Le = function () {
  var rval = (
    this.data.getInt8(this.read) ^
    this.data.getInt16(this.read + 1, true) &lt;&lt; 8);
  this.read += 3;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt32" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt32">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt32 = function () {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = [];

  // key lengths of 16, 24, 32 bytes allowed
  var len = tmp.length();
  if(len === 16 || len === 24 || len === 32) {
    len = len &gt;&gt;&gt; 2;
    for(var i = 0; i &lt; len; ++i) {
      key.push(tmp.<span class="apidocCodeKeywordSpan">getInt32</span>());
    }
  }
}

// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key) ||
  !(key.length === 4 || key.length === 6 || key.length === 8)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getInt32Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.getInt32Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getInt32Le
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInt32Le = function () {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a = s.h0;
b = s.h1;
c = s.h2;
d = s.h3;

// round 1
for(i = 0; i &lt; 16; ++i) {
  w[i] = bytes.<span class="apidocCodeKeywordSpan">getInt32Le</span>();
  f = d ^ (b &amp; (c ^ d));
  t = (a + f + _k[i] + w[i]);
  r = _r[i];
  a = d;
  d = c;
  c = b;
  b += (t &lt;&lt; r) | (t &gt;&gt;&gt; (32 - r));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.getSignedInt" id="apidoc.element.node-forge.util.DataBuffer.prototype.getSignedInt">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>getSignedInt
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 &lt;&lt; (n - 2);
  if(x &gt;= max) {
    x -= max &lt;&lt; 1;
  }
  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   bytes = forge.util.createBuffer(bytes);
 }

 var n = bytes.length() * 8;
 if(n &gt; 32) {
   throw new Error('Integer too large; max is 32-bits.');
 }
 return bytes.<span class="apidocCodeKeywordSpan">getSignedInt</span>(n);
};

/**
* Validates the that given ASN.1 object is at least a super set of the
* given ASN.1 structure. Only tag classes and types are checked. An
* optional map may also be provided to capture ASN.1 values while the
* structure is checked.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.isEmpty" id="apidoc.element.node-forge.util.DataBuffer.prototype.isEmpty">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this.length() &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    // process next record if no failure, process will be called after
    // each record is handled (since handling can be asynchronous)
    if(!c.fail) {
// reset record if ready and now empty
if(c.record !== null &amp;&amp;
  c.record.ready &amp;&amp; c.record.fragment.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
  c.record = null;
}

// if there is no pending record, try to read record header
if(c.record === null) {
  rval = _readRecordHeader(c);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.last" id="apidoc.element.node-forge.util.DataBuffer.prototype.last">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.data.getUint8(this.write - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(decrypt) {
/* The last byte in the output specifies the number of padding bytes not
  including itself. Each of the padding bytes has the same value as that
  last byte (known as the padding_length). Here we check all padding
  bytes to ensure they have the value of padding_length even if one of
  them is bad in order to ward-off timing attacks. */
var len = output.length();
var paddingLength = output.<span class="apidocCodeKeywordSpan">last</span>();
for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
  rval = rval &amp;&amp; (output.at(i) == paddingLength);
}
if(rval) {
  // trim off padding bytes and last padding length byte
  output.truncate(paddingLength + 1);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.length" id="apidoc.element.node-forge.util.DataBuffer.prototype.length">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () {
  return this.write - this.read;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buffer = forge.util.createBuffer();
// create a byte buffer from raw binary bytes
var buffer = forge.util.createBuffer(input, 'raw');
// create a byte buffer from utf8 bytes
var buffer = forge.util.createBuffer(input, 'utf8');

// get the length of the buffer in bytes
buffer.<span class="apidocCodeKeywordSpan">length</span>();
// put bytes into the buffer
buffer.putBytes(bytes);
// put a 32-bit integer into the buffer
buffer.putInt32(10);
// buffer to hex
buffer.toHex();
// get a copy of the bytes in the buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putBuffer" id="apidoc.element.node-forge.util.DataBuffer.prototype.putBuffer">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putBuffer
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putBuffer = function (buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var output = forge.util.createBuffer();

// if using a salt, prepend this to the output:
if(salt !== null) {
  output.putBytes('Salted__'); // (add to match openssl tool output)
  output.putBytes(salt);
}
output.<span class="apidocCodeKeywordSpan">putBuffer</span>(cipher.output);

fs.writeFileSync('input.enc', output.getBytes(), {encoding: 'binary'});
}

// openssl enc -d -des3 -in input.enc -out input.dec.txt
function decrypt(password) {
var input = fs.readFileSync('input.enc', {encoding: 'binary'});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putByte" id="apidoc.element.node-forge.util.DataBuffer.prototype.putByte">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putByte
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putByte = function (b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = forge.util.createBuffer(key);
} else if(forge.util.isArray(key) &amp;&amp;
  (key.length === 16 || key.length === 24 || key.length === 32)) {
  // convert key integer array into byte buffer
  tmp = key;
  key = forge.util.createBuffer();
  for(var i = 0; i &lt; tmp.length; ++i) {
    key.<span class="apidocCodeKeywordSpan">putByte</span>(tmp[i]);
  }
}

// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)) {
  tmp = key;
  key = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putBytes" id="apidoc.element.node-forge.util.DataBuffer.prototype.putBytes">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putBytes
        <span class="apidocSignatureSpan">(bytes, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putBytes = function (bytes, encoding) {
  if(util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if(util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  }

  // bytes is a util.DataBuffer or equivalent
  if(bytes instanceof util.DataBuffer ||
    (typeof bytes === 'object' &amp;&amp;
    typeof bytes.read === 'number' &amp;&amp; typeof bytes.write === 'number' &amp;&amp;
    util.isArrayBufferView(bytes.data))) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if(bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  }

  // string conversion
  encoding = encoding || 'binary';
  if(typeof bytes === 'string') {
    var view;

    // decode from string
    if(encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }
    if(encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    }

    // encode text as UTF-8 bytes
    if(encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    }

    // decode string as raw binary
    if(encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    }

    // encode text as UTF-16 bytes
    if(encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sendSomehow(request.toString());

// receive response
var buffer = forge.util.createBuffer();
var response = forge.http.createResponse();
var someAsyncDataHandler = function(bytes) {
if(!response.bodyReceived) {
  buffer.<span class="apidocCodeKeywordSpan">putBytes</span>(bytes);
  if(!response.headerReceived) {
    if(response.readHeader(buffer)) {
      console.log('HTTP response header: ' + response.toString());
    }
  }
  if(response.headerReceived &amp;&amp; !response.bodyReceived) {
    if(response.readBody(buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt
        <span class="apidocSignatureSpan">(i, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt = function (i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, (i &gt;&gt; n) &amp; 0xFF);
  } while(n &gt; 0);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param lenBytes the number of bytes required to store the length.
 * @param v the byte buffer vector.
 */
var writeVector = function(b, lenBytes, v) {
  // encode length at the start of the vector, where the number of bytes for
  // the length is the maximum number of bytes it would take to encode the
  // vector's ceiling
  b.<span class="apidocCodeKeywordSpan">putInt</span>(v.length(), lenBytes &lt;&lt; 3);
  b.putBuffer(v);
};

/**
 * The tls implementation.
 */
var tls = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt16" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt16">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt16
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt16 = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      value.putBuffer(asn1.toDer(obj.value[i]));
    }
  }
} else {
  // use asn1.value directly
  if(obj.type === asn1.Type.BMPSTRING) {
    for(var i = 0; i &lt; obj.value.length; ++i) {
      value.<span class="apidocCodeKeywordSpan">putInt16</span>(obj.value.charCodeAt(i));
    }
  } else {
    // ensure integer is minimally-encoded
    // TODO: should all leading bytes be stripped vs just one?
    // .. ex '00 00 01' =&gt; '01'?
    if(obj.type === asn1.Type.INTEGER &amp;&amp;
      obj.value.length &gt; 1 &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt16Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt16Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt16Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt16Le = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if(_iv !== null) {
    if(encrypt) {
      /* We're encrypting, apply the IV first. */
      val ^= _iv.getInt16Le();
    } else {
      /* We're decryption, keep cipher text for next block. */
      _iv.<span class="apidocCodeKeywordSpan">putInt16Le</span>(val);
    }
  }

  R.push(val &amp; 0xffff);
}

/* Reset global "j" variable as per spec. */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt24" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt24">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt24
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt24 = function (i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i &gt;&gt; 8 &amp; 0xFFFF);
  this.data.setInt8(this.write, i &gt;&gt; 16 &amp; 0xFF);
  this.write += 3;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  2 + cSuites +          // cipher suites vector
  1 + cMethods +         // compression methods vector
  extLength;             // extensions vector

// build record fragment
var rval = forge.util.createBuffer();
rval.putByte(tls.HandshakeType.client_hello);
rval.<span class="apidocCodeKeywordSpan">putInt24</span>(length);                     // handshake length
rval.putByte(c.version.major);             // major version
rval.putByte(c.version.minor);             // minor version
rval.putBytes(c.session.sp.client_random); // random time + bytes
writeVector(rval, 1, forge.util.createBuffer(sessionId));
writeVector(rval, 2, cipherSuites);
writeVector(rval, 1, compressionMethods);
if(extLength &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt24Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt24Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt24Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt24Le = function (i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i &gt;&gt; 16 &amp; 0xFF);
  this.data.setInt16(this.write, i &gt;&gt; 8 &amp; 0xFFFF, true);
  this.write += 3;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt32" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt32">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt32
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt32 = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buffer = forge.util.createBuffer(input, 'utf8');

// get the length of the buffer in bytes
buffer.length();
// put bytes into the buffer
buffer.putBytes(bytes);
// put a 32-bit integer into the buffer
buffer.<span class="apidocCodeKeywordSpan">putInt32</span>(10);
// buffer to hex
buffer.toHex();
// get a copy of the bytes in the buffer
bytes.bytes(/* count */);
// empty this buffer and get its contents
bytes.getBytes(/* count */);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putInt32Le" id="apidoc.element.node-forge.util.DataBuffer.prototype.putInt32Le">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putInt32Le
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putInt32Le = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// serialize message length in bits in little-endian order; since length
// is stored in bytes we multiply by 8 and add carry
var bits, carry = 0;
for(var i = md.fullMessageLength.length - 1; i &gt;= 0; --i) {
  bits = md.fullMessageLength[i] * 8 + carry;
  carry = (bits / 0x100000000) &gt;&gt;&gt; 0;
  finalBlock.<span class="apidocCodeKeywordSpan">putInt32Le</span>(bits &gt;&gt;&gt; 0);
}

var s2 = {
  h0: _state.h0,
  h1: _state.h1,
  h2: _state.h2,
  h3: _state.h3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putSignedInt" id="apidoc.element.node-forge.util.DataBuffer.prototype.putSignedInt">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putSignedInt
        <span class="apidocSignatureSpan">(i, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putSignedInt = function (i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if(i &lt; 0) {
    i += 2 &lt;&lt; (n - 1);
  }
  return this.putInt(i, n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param x the integer.
 *
 * @return the byte buffer.
 */
asn1.integerToDer = function(x) {
var rval = forge.util.createBuffer();
if(x &gt;= -0x80 &amp;&amp; x &lt; 0x80) {
  return rval.<span class="apidocCodeKeywordSpan">putSignedInt</span>(x, 8);
}
if(x &gt;= -0x8000 &amp;&amp; x &lt; 0x8000) {
  return rval.putSignedInt(x, 16);
}
if(x &gt;= -0x800000 &amp;&amp; x &lt; 0x800000) {
  return rval.putSignedInt(x, 24);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.putString" id="apidoc.element.node-forge.util.DataBuffer.prototype.putString">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>putString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putString = function (str) {
  return this.putBytes(str, 'utf16');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Adds len(val) then val to a buffer.
*
* @param buffer the buffer to add to.
* @param val a string.
*/
function _addStringToBuffer(buffer, val) {
 buffer.putInt32(val.length);
 buffer.<span class="apidocCodeKeywordSpan">putString</span>(val);
}

/**
* Hashes the arguments into one value using SHA-1.
*
* @return the sha1 hash of the provided arguments.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.setAt" id="apidoc.element.node-forge.util.DataBuffer.prototype.setAt">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>setAt
        <span class="apidocSignatureSpan">(i, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAt = function (i, b) {
  this.data.setUint8(i, b);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Inew = new forge.util.ByteBuffer();
for(j = 0; j &lt; k; j++) {
  var chunk = new forge.util.ByteBuffer(I.getBytes(v));
  var x = 0x1ff;
  for(l = B.length() - 1; l &gt;= 0; l--) {
    x = x &gt;&gt; 8;
    x += B.at(l) + chunk.at(l);
    chunk.<span class="apidocCodeKeywordSpan">setAt</span>(l, x &amp; 0xff);
  }
  Inew.putBuffer(chunk);
}
I = Inew;

/* Add Ai to A. */
result.putBuffer(buf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.toHex" id="apidoc.element.node-forge.util.DataBuffer.prototype.toHex">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>toHex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function () {
  var rval = '';
  for(var i = this.read; i &lt; this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);
    if(b &lt; 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Note: CBC and ECB modes use PKCS#7 padding as default
var cipher = forge.cipher.createCipher('AES-CBC', key);
cipher.start({iv: iv});
cipher.update(forge.util.createBuffer(someBytes));
cipher.finish();
var encrypted = cipher.output;
// outputs encrypted hex
console.log(encrypted.<span class="apidocCodeKeywordSpan">toHex</span>());

// decrypt some bytes using CBC mode
// (other modes include: CFB, OFB, CTR, and GCM)
var decipher = forge.cipher.createDecipher('AES-CBC', key);
decipher.start({iv: iv});
decipher.update(encrypted);
decipher.finish();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.toString" id="apidoc.element.node-forge.util.DataBuffer.prototype.toString">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>toString
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8';

  // encode to string
  if(encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }
  if(encoding === 'hex') {
    return util.binary.hex.encode(view);
  }
  if(encoding === 'base64') {
    return util.binary.base64.encode(view);
  }

  // decode to text
  if(encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }
  if(encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

socket.on('connect', function() {
  console.log('[socket] connected');
  client.handshake();
});
socket.on('data', function(data) {
  client.process(data.<span class="apidocCodeKeywordSpan">toString</span>('binary')); // encoding should be 'binary
'
});
socket.on('end', function() {
  console.log('[socket] disconnected');
});

// connect to google.com
socket.connect(443, 'google.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-forge.util.DataBuffer.prototype.truncate" id="apidoc.element.node-forge.util.DataBuffer.prototype.truncate">
        function <span class="apidocSignatureSpan">node-forge.util.DataBuffer.prototype.</span>truncate
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function (count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var len = output.length();
   var paddingLength = output.last();
   for(var i = len - 1 - paddingLength; i &lt; len - 1; ++i) {
     rval = rval &amp;&amp; (output.at(i) == paddingLength);
   }
   if(rval) {
     // trim off padding bytes and last padding length byte
     output.<span class="apidocCodeKeywordSpan">truncate</span>(paddingLength + 1);
   }
 }
 return rval;
}

/**
* Decrypts a TLSCipherText record into a TLSCompressed record using
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>